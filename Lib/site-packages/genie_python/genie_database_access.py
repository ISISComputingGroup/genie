import sys

from genie_python.mysql_abstraction_layer import SQLAbstraction

SELECT_FOR_EXP_DETAILS = """SELECT e.experimentID, u.name as userName, r.name as roleName, t.startDate, e.duration FROM `experimentteams` t
JOIN experiment e ON e.experimentID = t.experimentID
JOIN user u ON u.userID = t.userID
JOIN role r ON r.roleID = t.roleID"""


class DatabaseAccess():

    def __init__(self):
        self._sql = None

    def get_sql(self):
        """
        Get the one and only sql abstraction layer (created if it has not been created already)
        :return: sql abstraction layer
        """
        if self._sql is None:
            self._sql = SQLAbstraction(dbid='exp_data', user='report', password='$report')
        return self._sql

    def _validate_parameter(self, value, column, table):
        if value is None:
            return True


        user_id = self.get_sql().query(command=f"SELECT * FROM `{table}` WHERE {column}name = %s", bound_variables=(value,))
        if not user_id:
            raise NotFoundError(f"{value} is not a valid parameter")

    def get_exp_data(self, rb: int = None, user: str = None, role: str = None, verbose: bool = False):
        """
        Prints the data of experiments that match the given criteria, or all if none is given, from the exp_data database.

        Args:
            rb (int, optional): The RB number of the experiment to look for, Defaults to None (any).
            user (str, optional): The name of the user who is running/has run the experiment, Defaults to None (any).
            role (str, optional): The user role, Defaults to None (any).

        """
        if rb is not None:
            self._validate_parameter(rb, "experimentID", "experimentteams")
        if user is not None:
            self._validate_parameter(user, "name", "user")
        if role is not None:
            self._validate_parameter(user, "name", "role")

        args, sql = self._create_sql_statement_and_args(rb, role, user)

        exp_data = self._query_database_for_data(args, sql)

        if verbose:
            self._pretty_print(exp_data)

        return exp_data

    def _query_database_for_data(self, args, sql):
        exp_data = []
        for exp_id, user, role, start_date, duration in self.get_sql().query_returning_cursor(sql, args):
            start_date = start_date.strftime('%Y-%m-%d %H:%M:%S')
            experiment_details = {
                "rb_number": exp_id,
                "user": user,
                "role": role,
                "start_date": start_date,
                "duration": duration
            }
            exp_data.append(experiment_details)
        return exp_data

    def _create_sql_statement_and_args(self, rb, role, user):
        """
        Prepare the statement and bound variables

        Args:
            rb: rb number of the experiment; None for don't search on this term
            role: role being searched for; None for don't search on this term
            user: user being searched for; None for don't search on this term

        Returns:

        """
        args = []
        sql = SELECT_FOR_EXP_DETAILS
        if any(x is not None for x in [rb, user, role]):
            sql += ' WHERE '
            where_clauses = []
            if rb is not None:
                where_clauses.append("e.experimentID = %s")
                args.append(rb)
            if user is not None:
                where_clauses.append('upper(u.name) like upper("%%s%")')
                args.append(user)
            if role is not None:
                where_clauses.append('upper(r.name) like upper("%%s%")')
                args.append(role)
            sql += " AND ".join(where_clauses)
        sql += "ORDER BY experimentID DESC"
        return args, sql

    def _pretty_print(self, exp_data):
        # For pretty printing
        rb_padding = max(len(x) for x in [y["rb_number"] for y in exp_data])
        user_padding = max(len(x) for x in [y["user"] for y in exp_data])
        role_padding = max(len(x) for x in [y["role"] for y in exp_data])
        for exp in exp_data:
            print(f'Experiment RB number: {exp["rb_number"]:{rb_padding}} | '
                  f'User: {exp["user"]:{user_padding}} | '
                  f'Role: {exp["role"]:{role_padding}} | '
                  f'Start date: {exp["start_date"]} | '
                  f'Duration: {exp["duration"]}')