from __future__ import absolute_import, print_function
from builtins import str
import types
import os
import imp
import sys
import re
import datetime
import six
from io import open

os.environ["EPICS_CA_MAX_ARRAY_BYTES"] = "1000000"

from collections import OrderedDict
from genie_python.genie_script_checker import ScriptChecker
from genie_python.utilities import EnvironmentDetails, get_correct_path, get_correct_filepath_existing
from genie_python.genie_api_setup import __api, helparglist, usercommand, _handle_exception, \
    set_user_script_dir, get_user_script_dir

# Import required for g.my_pv_prefix
from genie_python.genie_api_setup import my_pv_prefix
# for user import this functionality so they can do g.adv
import genie_python.genie_advanced as adv

from genie_python.version import VERSION
print("\ngenie_python version " + VERSION)

SUPPORTED_PYTHON_VERSION = (3, 8, 1)
if sys.version_info[0:3] != SUPPORTED_PYTHON_VERSION[0:3]:
    message = "WARNING: genie_python only guarantees support for Python version {0[0]}.{0[1]}.{0[2]}, you are running {1}" \
        .format(SUPPORTED_PYTHON_VERSION, sys.version)
    print(message, file=sys.stderr)



def set_instrument(pv_prefix, import_instrument_init=True):
    """
    Sets the instrument this session is communicating with.
    Used for remote access - do not delete.

    Args:
        pv_prefix (string): the PV prefix
        import_instrument_init (bool): if True import the instrument init from the config area; otherwise don't
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        globs = _get_correct_globals()
        __api.set_instrument(pv_prefix, globs, import_instrument_init)
    except Exception as e:
        _handle_exception(e)


def reload_current_config():
    """
    Reload the current configuration.
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.reload_current_config()
    except Exception as e:
        _handle_exception(e)


def check_lowlimit_against_highlimit(lowlimit, highlimit):
    """
    Check the lowlimit is below the highlimit, and warns if this is the case
    """
    if lowlimit is not None and highlimit is not None and lowlimit > highlimit:
        print("WARNING: You have set the lowlimit({}) above the highlimit({})".format(lowlimit, highlimit))


@usercommand
@helparglist('')
def get_blocks():
    """
    Get the names of the blocks.

    Returns:
        list: the blocknames
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.get_blocks()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('...')
def cset(*args, **kwargs):
    """
    Sets the setpoint and runcontrol settings for blocks.

    Args:
        runcontrol (bool, optional): whether to set runcontrol for this block
        wait (bool, optional): pause execution until setpoint is reached (one block only)
        lowlimit (float, optional): the lower limit for runcontrol or waiting
        highlimit (float, optional): the upper limit for runcontrol or waiting

    Note: cannot use wait and runcontrol in the same command

    Examples:
        Setting a value for a block:

        >>> cset(block1=100)

        Or:

        >>> cset("block1", 100)

        Setting values for more than one block:

        >>> cset(block1=100, block2=200, block3=300)

        NOTE: the order in which the values are set is random,
        e.g. block1 may or may not be set before block2 and block3

        Setting runcontrol values for a block:

        >>> cset(block1=100, runcontrol=True, lowlimit=99, highlimit=101)

        Changing runcontrol settings for a block without changing the setpoint:

        >>> cset("block1", runcontrol=False)      
        >>> cset(block1=None, runcontrol=False)

        Wait for setpoint to be reached (one block only):

        >>> cset(block1=100, wait=True)

        Wait for limits to be reached - this does NOT change the runcontrol limits:

        >>> cset(block1=100, wait=True, lowlimit=99, highlimit=101)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    # Block names contain alpha-numeric and underscores only
    try:
        run_control = kwargs.pop('runcontrol', None)
        low_limit = kwargs.pop('lowlimit', None)
        high_limit = kwargs.pop('highlimit', None)
        wait = kwargs.pop('wait', None)

        # See if single block name was entered, i.e. cset("block1", runcontrol=True)
        if len(args) > 0:
            if len(args) > 2:
                raise Exception('Too many arguments, please type: help(g.cset) for more information on the syntax')
            else:
                blocks = [args[0]]

            values = [args[1]] if len(args) == 2 else [None]
        elif len(kwargs) > 0:
            # Check for specifying blocks via the cset(block=value) syntax
            blocks, values = zip(*kwargs.items())
        else:
            raise Exception('Incorrect syntax, please type: help(g.cset) for more information on the syntax')

        for block in blocks:
            if not __api.block_exists(block):
                raise Exception('No block with the name "{}" exists'.format(block))

        if wait and run_control is not None:
            raise Exception("Cannot enable or disable runcontrol at the same time as setting a wait")
        if wait and values[0] is None:
            raise Exception('Cannot wait as no setpoint specified. Please type: help(g.cset) for help')

        # Warn if highlimit and lowlimit are round the incorrect way
        check_lowlimit_against_highlimit(low_limit, high_limit)

        if len(blocks) > 1:
            # Setting multiple blocks, so other settings not allowed
            if not all(argument is None for argument in [run_control, low_limit, high_limit, wait]):
                raise Exception('Runcontrol and wait can only be changed for one block at a time')

        for block, value in list(zip(blocks, values)):
            # If there are multiple blocks then runcontrol etc. should be None anyway so pass them through
            __api.set_block_value(block, value, run_control, low_limit, high_limit, wait)
            _warn_if_block_alarm(block)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('block')
def cget(block):
    """
    Gets the useful values associated with a block.

    The value will be None if the block is not "connected".

    Args:
        block (string): the name of the block

    Returns
        dict: details about about the block. Contains:
            name - name of the block
            value - value of the block
            connected - True if connected; False otherwise
            runcontrol - NO not in runcontrol, YES otherwise
            lowlimit - run control low limit set
            highlimit - run control high limit set
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        if not __api.block_exists(block):
            raise Exception('No block with the name "%s" exists' % block)

        blk = __api.correct_blockname(block, False)
        blks = __api.get_current_block_values()

        if blk in blks:
            ans = OrderedDict()
            ans['name'] = blk
            connected = _check_block_connected(blks[blk][0])
            if connected:
                ans['value'] = blks[blk][0]
                ans['connected'] = True
            else:
                ans['value'] = None
                ans['connected'] = False
            ans['runcontrol'] = blks[blk][1]
            ans['lowlimit'] = blks[blk][2]
            ans['highlimit'] = blks[blk][3]
            ans['alarm'] = __api.get_alarm_from_block(blk)

            _warn_if_block_alarm(blk)
            return ans
        else:
            raise KeyError('No block with the name "%s" exists' % block)
    except Exception as e:
        _handle_exception(e)


def _cshow_all():
    """
    Handles the cshow command for all the blocks.
    """
    blks = __api.get_current_block_values()
    for bn, bv in six.iteritems(blks):
        _print_cshow(bn, bv)


def _cshow_one(block):
    """
    Handles the cshow command for one block only.

    Args:
        block (list): the block values
    """
    blk = __api.correct_blockname(block, False)
    blks = __api.get_current_block_values()
    if blk in blks:
        _print_cshow(blk, blks[blk])
    else:
        raise Exception('No block with the name "%s" exists' % block)


def _warn_if_block_alarm(block):
    """
    Checks whether a block is in an alarmed state and warn user (inc log)

    Args:
        block (object): The block to be checked
    """
    minor, major, invalid = check_alarms(block)
    alarms = {"MINOR": minor, "MAJOR": major, "INVALID": invalid}
    for alarm_type, alarm in six.iteritems(alarms):
        if alarm:
            __api.log_info_msg("BLOCK {} IN {} ALARM".format(alarm[0], alarm_type))
            print("Block {} is in alarm: {}".format(alarm[0], alarm_type), file=sys.stdout)


def _check_block_connected(value):
    """
    Checks whether a block is connected and if it isn't sets the value appropriately.

    Args:
        value (object): the block value

    Returns:
        True if connected otherwise False
    """
    if value == "*** disconnected" or value is None:
        return False
    else:
        return True


def _print_cshow(name, value):
    """
    Prints the cshow string for one block.

    Args:
        name (string): the block name
        value (list): the block values
    """
    if _check_block_connected(value[0]):
        print('{} = {} (runcontrol = {}, lowlimit = {}, highlimit = {}, alarm = {})'.format(
            name, value[0], value[1], value[2], value[3], __api.get_alarm_from_block(name)))
    else:
        print('{} = {} (runcontrol = {}, lowlimit = {}, highlimit = {}, alarm = {})'.format(
            name, "*** disconnected ***", value[1], value[2], value[3], __api.get_alarm_from_block(name)))


def cshow(block=None):
    """
    Show the current settings for one block or for all blocks.

    Args:
        block (string, optional): the name of the block

    Examples:
        Showing all block values:
        
        >>> cshow()

        Showing values for one block only (name must be quoted):
        
        >>> cshow("block1")
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        if block:
            # Show only one block
            if __api.block_exists(block):
                _cshow_one(block)
            else:
                raise Exception('No block with the name "%s" exists' % block)
        else:
            # Show all blocks
            _cshow_all()
    except Exception as e:
        _handle_exception(e)


def waitfor(block=None, value=None, lowlimit=None, highlimit=None, maxwait=None,
            wait_all=False, seconds=None, minutes=None, hours=None, time=None,
            frames=None, raw_frames=None, uamps=None, mevents=None, early_exit=lambda: False, **pars):
    """
    Interrupts execution until certain conditions are met.

    Args:
        block (string, optional): the name of the block to wait for
        value (float, optional): the block value to wait for
        lowlimit (float, optional): wait for the block to be >= this value (numeric only)
        highlimit (float, optional): wait for the block to be <= this value (numeric only)
        maxwait (float, optional): wait no longer that the specified number of seconds
        wait_all (bool, optional): wait for all conditions to be met (e.g. a number of frames and an amount of uamps)
        seconds (float, optional): wait for a specified number of seconds
        minutes (float, optional): wait for a specified number of minutes
        hours (float, optional): wait for a specified number of hours
        time (string, optional): a quicker way of setting hours, minutes and seconds (must be of format "HH:MM:SS")
        frames (int, optional): wait for a total number of good frames to be collected
        raw_frames (int, optional): wait for a total number of raw frames to be collected
        uamps (float, optional): wait for a total number of uamps to be received
        mevents (float, optional): wait for a total number of millions of events to be collected
        early_exit (lambda, optional): stop waiting if the function evaluates to True

    Examples:
        Wait for a block to reach a specific value:
        
        >>> waitfor(myblock=123)       
        >>> waitfor("myblock", 123)      
        >>> waitfor("myblock", True)     
        >>> waitfor("myblock", "OPEN")
        
        Wait for a block to be between limits:
        
        >>> waitfor("myblock", lowlimit=100, highlimit=110)

        Wait for a block to reach a specific value, but no longer than 60 seconds:
        
        >>> waitfor(myblock=123, maxwait=60)

        Wait for a specified time interval:
        
        >>> waitfor(seconds=10)       
        >>> waitfor(hours=1, minutes=30, seconds=15)      
        >>> waitfor(time="1:30:15")

        Wait for a data collection condition:
        
        >>> waitfor(frames=5000)       
        >>> waitfor(uamps=200)

        Wait for either a number of frames OR a time interval to occur:
        
        >>> waitfor(frames=5000, hours=2)

        Wait for a number of frames AND a time interval to occur:
        
        >>> waitfor(frames=5000, hours=2, wait_all=True)

        Wait for either the block to reach a value or a condition to be met:
        
        >>> waitfor(myblock=123, early_exit=lambda: some_function(cget("another_block")["value"]) > 123)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        if block is None:
            # Search through the params to see if there is a block there
            blks = __api.get_blocks()
            for k in pars:
                if k in blks:
                    if block is not None:
                        raise Exception('Can set waitfor for only one block at a time')
                    block = k
                    value = pars[k]
                else:
                    raise ValueError("Block named '{}' did not exist.".format(k))
        # Check that wait_for object exists
        if __api.waitfor is None:
            raise Exception("Cannot execute waitfor - try calling set_instrument first")
        # Warn if highlimit and lowlimit are round correct way
        check_lowlimit_against_highlimit(lowlimit, highlimit)
        # Start_waiting checks the block exists
        __api.waitfor.start_waiting(block, value, lowlimit, highlimit, maxwait, wait_all, seconds, minutes, hours, time,
                                    frames, raw_frames, uamps, mevents, early_exit)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('block[, value][, lowlimit][, highlimit][, maxwait]')
def waitfor_block(block, value=None, lowlimit=None, highlimit=None, maxwait=None, early_exit=lambda: False):
    """
    Interrupts execution until block reaches specific value

    Args:
        block: the name of the block to wait for
        value: the target block value
        lowlimit: waits for the block to be >= this value (numeric only)
        highlimit: waits for the block to be <= this value (numeric only)
        maxwait: wait no longer that the specified number of seconds
        early_exit: stop waiting if the exception evaluates to True

    Examples:
    
        >>> waitfor_block("myblock", value=123)       
        >>> waitfor_block("myblock", value=True, maxwait=15)      
        >>> waitfor_block("myblock", lowlimit=100, highlimit=110)       
        >>> waitfor_block("myblock", highlimit=1.0, maxwait=60)       
        >>> waitfor_block("myblock", value=123, early_exit=lambda: cget("myblock_limit_reached")["value"] != 0)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        if __api.waitfor is None:
            raise Exception("Cannot execute waitfor_block - try calling set_instrument first")
        # Warn if highlimit and lowlimit are round correct way
        check_lowlimit_against_highlimit(lowlimit, highlimit)
        __api.waitfor.start_waiting(block=block, value=value, lowlimit=lowlimit, highlimit=highlimit, maxwait=maxwait,
                                    early_exit=early_exit)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[seconds][, minutes][, hours][, time]')
def waitfor_time(seconds=None, minutes=None, hours=None, time=None):
    """
    Interrupts execution for a specified amount of time

    Args:
        seconds (float, optional): wait for a specified number of seconds
        minutes (float, optional): wait for a specified number of minutes
        hours (float, optional): wait for a specified number of hours
        time (string, optional): a quicker way of setting hours, minutes and seconds (must be of format "HH:MM:SS")

    Examples:
    
        >>> waitfor_time(seconds=10)       
        >>> waitfor_time(hours=1, minutes=30, seconds=15)       
        >>> waitfor_time(time="1:30:15")
    """
    try:
        if all(t is None for t in (seconds, minutes, hours, time)):
            raise TypeError("Cannot execute waitfor_time - need to set at least one parameter. Type help(waitfor_time) "
                            "to see guidelines")
        if any(t is not None and t < 0 for t in (seconds, minutes, hours)):
            raise ValueError("Cannot execute waitfor_time - Time parameters cannot be negative")
        if __api.waitfor is None:
            raise TypeError("Cannot execute waitfor_time - try calling set_instrument first")
        __api.waitfor.start_waiting(seconds=seconds, minutes=minutes, hours=hours, time=time)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('frames')
def waitfor_frames(frames):
    """
    Interrupts execution to wait for number of total good frames to reach parameter value

    Args:
        frames (int): the number of frames to wait for

    Example:
    
        >>> waitfor_frames(4000)
    """
    try:
        if frames is None:
            raise TypeError("Cannot execute waitfor_frames - need to set frames parameter. Type help(waitfor_frames")
        if frames < 0:
            raise ValueError("Cannot execute waitfor_frames - frames parameter cannot be negative")
        if __api.waitfor is None:
            raise Exception("Cannot execute waitfor_frames - try calling set_instrument first")
        __api.waitfor.start_waiting(frames=frames)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('raw_frames')
def waitfor_raw_frames(raw_frames):
    """
    Interrupts execution to wait for number of total raw frames to reach parameter value

    Args:
        raw frames (int): the number of raw frames to wait for

    Example:

        >>> waitfor_raw_frames(4000)
    """
    try:
        if raw_frames is None:
            raise TypeError("Cannot execute waitfor_raw_frames - need to set raw_frames parameter. Type help(waitfor_raw_frames")
        if raw_frames < 0:
            raise ValueError("Cannot execute waitfor_raw_frames - raw_frames parameter cannot be negative")
        if __api.waitfor is None:
            raise Exception("Cannot execute waitfor_raw_frames - try calling set_instrument first")
        __api.waitfor.start_waiting(raw_frames=raw_frames)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('uamps')
def waitfor_uamps(uamps):
    """
    Interrupts execution to wait for a specific total charge

    Args:
        uamps: the charge to wait for

    Example:
    
        >>> waitfor_uamps(115.5)
    """
    try:
        if __api.waitfor is None:
            raise Exception("Cannot execute waitfor_uamps - try calling set_instrument first")
        __api.waitfor.start_waiting(uamps=uamps)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('mevents')
def waitfor_mevents(mevents):
    """
    Interrupts execution to wait for number of millions of events to reach parameter value

    Args:
        mevents (float): the number of millions of events to wait for

    Example:

        >>> waitfor_mevents(0.0004)
    """
    try:
        if mevents is None:
            raise TypeError("Cannot execute waitfor_mevents - need to set mevents parameter. Type help(waitfor_mevents)")
        if mevents < 0:
            raise ValueError("Cannot execute waitfor_mevents - mevents parameter cannot be negative")
        if __api.waitfor is None:
            raise Exception("Cannot execute waitfor_mevents - try calling set_instrument first")
        __api.waitfor.start_waiting(mevents=mevents)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('state[, maxwaitsecs][, onexit]')
def waitfor_runstate(state, maxwaitsecs=3600, onexit=False):
    """
    Wait for a particular instrument run state.

    Args:
        state (string): the state to wait for (e.g. "paused")
        maxwaitsecs (int, optional): the maximum time to wait for the state before carrying on
        onexit (bool, optional): wait for runstate to change from the specified state

    Examples:
        Wait for a run to enter the paused state:
        
        >>> waitfor_runstate("paused")

        Wait for a run to exit the paused state:
        
        >>> waitfor_runstate("paused", onexit=True)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        # Check that wait_for object exists
        if __api.waitfor is None:
            raise Exception("Cannot execute waitfor_runstate - try calling set_instrument first")
        __api.waitfor.wait_for_runstate(state, maxwaitsecs, onexit)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[block, ...][, start_timeout][, move_timeout]')
def waitfor_move(*blocks, **kwargs):
    """
    Wait for all motion or specific motion to complete.

    If block names are supplied then it will only wait for those to stop moving. Otherwise, it will wait for all motion
    to stop.

    Args:
        blocks (string, multiple, optional): the names of specific blocks to wait for
        start_timeout (int, optional): the number of seconds to wait for the movement to begin (default = 2 seconds)
        move_timeout (int, optional): the maximum number of seconds to wait for motion to stop

    Examples:
        Wait for all motors to stop moving:
        
        >>> waitfor_move()

        Wait for all motors to stop moving with a timeout of 30 seconds:
        
        >>> waitfor_move(move_timeout=30)

        Wait for only slit1 and slit2 motors to stop moving:
        
        >>> waitfor_move("slit1", "slit2")
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())

    # Sort out the parameters
    # Standard parameters
    if 'start_timeout' in kwargs:
        start_timeout = kwargs['start_timeout']
    else:
        start_timeout = 2
    if 'move_timeout' in kwargs:
        move_timeout = kwargs['move_timeout']
    else:
        move_timeout = None

    try:
        # Check that wait_for_move object exists
        if __api.wait_for_move is None:
            raise Exception("Cannot execute waitfor_move - try calling set_instrument first")

        if len(blocks) > 0:
            # Specified blocks waitfor_move
            move_blocks = list()
            # Check blocks exist
            for b in blocks:
                if __api.block_exists(b):
                    move_blocks.append(b)
                else:
                    print("Block %s does not exist, so ignoring it" % b)
            __api.wait_for_move.wait_specific(move_blocks, start_timeout, move_timeout)
        else:
            # Standard waitfor_move
            __api.wait_for_move.wait(start_timeout, move_timeout)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('name[, to_string][, is_local]')
def get_pv(name, to_string=False, is_local=False):
    """
    Get the value for the specified PV.

    Args:
        name (string): the name of the PV to get the value for
        to_string (bool, optional): whether to get the value as a string
        is_local (bool, optional): whether to automatically prepend the local inst prefix to the PV name

    Returns:
        the current PV value
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.get_pv_value(name, to_string, is_local=is_local)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('name, value[, wait][, is_local]')
def set_pv(name, value, wait=False, is_local=False):
    """
    Set the value for the specified PV.

    Args:
        name (string): the PV name
        value: the new value to set
        wait (bool, optional): whether to wait until the value has been received by the hardware
        is_local (bool, optional): whether to automatically prepend the local inst prefix to the PV name
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.set_pv_value(name, value, wait, is_local=is_local)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('verbose')
def set_messages_verbosity(verbose):
    """
    Set the global verbosity of messages.

    Args:
        verbose (bool): set the verbosity
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    __api.dae.set_verbose(verbose)


@usercommand
@helparglist('...')
def begin(period=1, meas_id=None, meas_type="", meas_subid="",
          sample_id="", delayed=False, quiet=False, paused=False, verbose=False):
    """
    Starts a data collection run.

    Args:
        period (int, optional): the period to begin data collection in
        meas_id (string, optional): the measurement id
        meas_type (string, optional): the type of measurement
        meas_subid (string, optional): the measurement sub-id
        sample_id (string, optional): the sample id
        delayed (bool, optional): puts the period card to into delayed start mode
        quiet (bool, optional): suppress the output to the screen
        paused (bool, optional): begin in the paused state
        verbose (bool, optional): show the messages from the DAE
    Returns:
        Any: return what the begin_postcmd method returns
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())

    try:
        # Returns None if we should start the run or the reason why if not
        pre_post_cmd_return = __api.pre_post_cmd_manager.begin_precmd(quiet=quiet)
        if pre_post_cmd_return is None:
            __api.dae.begin_run(period, meas_id, meas_type, meas_subid, sample_id, delayed, quiet, paused)
            waitfor_runstate("SETUP", onexit=True)
            __api.dae.post_begin_check(verbose)
            __api.pre_post_cmd_manager.begin_postcmd(run_num=__api.dae.get_run_number(), quiet=quiet)
        else:
            print(str(pre_post_cmd_return))
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[verbose]')
def abort(verbose=False):
    """
    Abort the current run.

    Args:
        verbose (bool, optional): show the messages from the DAE
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.pre_post_cmd_manager.abort_precmd()
        __api.dae.abort_run()
        __api.dae.post_abort_check(verbose)
        __api.pre_post_cmd_manager.abort_postcmd()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[verbose], [quiet]')
def end(verbose=False, quiet=False, immediate=False):
    """
    End the current run.

    Args:
        verbose (bool, optional): show the messages from the DAE
        quiet (bool, optional): suppress the end_precmd output to the screen
        immediate: end immediately, without waiting for a period sequence to complete
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.pre_post_cmd_manager.end_precmd(quiet=quiet)
        __api.dae.end_run(verbose=verbose, quiet=quiet, immediate=immediate)
        waitfor_runstate("SETUP")
        __api.dae.post_end_check(verbose)
        __api.pre_post_cmd_manager.end_postcmd(quiet=quiet)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[verbose]')
def pause(verbose=False, immediate=False):
    """
    Pause the current run.

    Args:
        verbose (bool, optional): show the messages from the DAE
        immediate: pause immediately, without waiting for a period sequence to complete
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.pre_post_cmd_manager.pause_precmd()
        __api.dae.pause_run(immediate=immediate)
        __api.dae.post_pause_check(verbose)
        __api.pre_post_cmd_manager.pause_postcmd()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[verbose]')
def resume(verbose=False):
    """
    Resume the current run after it has been paused.

    Args:
        verbose (bool, optional): show the messages from the DAE
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.pre_post_cmd_manager.resume_precmd()
        __api.dae.resume_run()
        __api.dae.post_resume_check(verbose)
        __api.pre_post_cmd_manager.resume_postcmd()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[verbose]')
def recover(verbose=False):
    """
    Recovers the run if it has been aborted.
    The command should be run before the next run is started.

    Note: the run will be recovered in the paused state.

    Args:
        verbose (bool, optional): show the messages from the DAE
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.recover_run()
        waitfor_runstate("SETUP", onexit=True)
        __api.dae.post_recover_check(verbose)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[verbose]')
def updatestore(verbose=False):
    """
    Performs an update and a store operation in a combined operation.
    This is more efficient than doing the commands separately.

    Args:
        verbose (bool, optional): show the messages from the DAE
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.update_store_run()
        waitfor_runstate("SAVING", onexit=True)
        __api.dae.post_update_store_check(verbose)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[pause_run], [verbose]')
def update(pause_run=True, verbose=False):
    """
    Data is loaded from the DAE into the computer memory, but is not written to disk.

    Args:
        pause_run (bool, optional): whether to pause data collection first [optional]
        verbose (bool, optional): show the messages from the DAE
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        if pause_run:
            # Pause
            pause(verbose=verbose)

        # Update
        __api.dae.update_run()
        waitfor_runstate("UPDATING", onexit=True)
        __api.dae.post_update_check(verbose)

        if pause_run:
            # Resume
            resume(verbose=verbose)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[verbose]')
def store(verbose=False):
    """
    Data loaded into memory by a previous update command is now written to disk.

    Args:
        verbose (bool, optional): show the messages from the DAE
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.store_run()
        waitfor_runstate("STORING", onexit=True)
        __api.dae.post_store_check(verbose)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[filename], [verbose]')
def snapshot_crpt(filename="c:\\Data\snapshot_crpt.tmp", verbose=False):
    """
    Create a snapshot of the current data.

    Args:
        filename (string, optional): where to write the data file(s)
        verbose (bool, optional): show the messages from the DAE

    Examples:
        Snapshot to a file called my_snapshot:

        >>> snapshot_crpt("c:\\Data\my_snapshot")
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        name = get_correct_path(filename)
        __api.dae.snapshot_crpt(name)
        waitfor_runstate("STORING", onexit=True)
        __api.dae.post_snapshot_check(verbose)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[period]')
def get_uamps(period=False):
    """
    Get the current number of micro-amp hours.

    Args:
        period (bool, optional): whether to return the value for the current period only

    Returns:
        float: the number of uamps
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_uamps(period)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[period]')
def get_frames(period=False):
    """
    Gets the current number of good frames.

    Args:
        period (bool, optional): whether to return the value for the current period only

    Returns:
        int: the number of frames
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_good_frames(period)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[period]')
def get_raw_frames(period=False):
    """
    Gets the current number of raw frames.

    Args:
        period (bool, optional): whether to return the value for the current period only

    Returns:
        int: the number of raw frames
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_raw_frames(period)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_runstate():
    """
    Get the current status of the instrument as a string.

    Note: this value can take a few seconds to update after a change of state.

    Returns:
        string: the current run state
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_run_state()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_events():
    """
    Gets the total events for all the detectors.

    Returns:
        int: the number of events
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_events()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_mevents():
    """
    Gets the total millions of events for all the detectors.

    Returns:
        float: the number of millions of events
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_mevents()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_period():
    """
    Gets the current period number.

    Returns:
        int: the current period
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_period()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_number_periods():
    """
    Get the number of software periods.

    Returns:
        int: the number of periods
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_num_periods()
    except Exception as e:
        _handle_exception(e)


def set_period(period):
    """
    Sets the current period number.

    Deprecated - use change_period.

    Args:
        period (int): the period to switch to
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    print("set_period is deprecated - use change_period")
    change_period(period)


@usercommand
@helparglist('')
def get_runnumber():
    """
    Get the current run-number.

    Returns:
        string: the run-number
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_run_number()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_totalcounts():
    """
    Get the total counts for the current run.

    Returns:
        int: the total counts
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_total_counts()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_title():
    """
    Returns the current title.

    Returns:
        string: the title
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_title()
    except Exception as e:
        _handle_exception(e)


def set_title(title):
    """
    Sets the current title.

    Deprecated - use change_title.

    Args:
        title: the new title
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    print("set_title is deprecated - use change_title")
    change_title(title)


@usercommand
@helparglist('')
def get_rb():
    """
    Returns the current RB number.

    Returns:
        string: the RB number
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_rb_number()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_dashboard():
    """
    Get the current experiment values.

    Returns:
        dict: the experiment values
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        data = dict()
        data["status"] = __api.dae.get_run_state()
        data["run_number"] = __api.dae.get_run_number()
        data["rb_number"] = __api.dae.get_rb_number()
        data["user"] = __api.dae.get_users()
        data["title"] = __api.dae.get_title()
        data["run_time"] = __api.dae.get_run_duration()
        data["good_frames_total"] = __api.dae.get_good_frames()
        data["good_frames_period"] = __api.dae.get_good_frames(True)
        data["raw_frames_total"] = __api.dae.get_raw_frames()
        data["raw_frames_period"] = __api.dae.get_good_frames(True)
        data["beam_current"] = __api.dae.get_beam_current()
        data["total_current"] = __api.dae.get_total_uamps()
        data["spectra"] = __api.dae.get_num_spectra()
        # data["dae_memory_used"] = __api.dae.get_memory_used()         #Not implemented in EPICS system
        data["periods"] = __api.dae.get_num_periods()
        data["time_channels"] = __api.dae.get_num_timechannels()
        data["monitor_spectrum"] = __api.dae.get_monitor_spectrum()
        data["monitor_from"] = __api.dae.get_monitor_from()
        data["monitor_to"] = __api.dae.get_monitor_to()
        data["monitor_counts"] = __api.dae.get_monitor_counts()
        return data
    except Exception as e:
        _handle_exception(e)


def _get_correct_globals():
    """
    This is a hack to find the frame in which to add the script function(s).

    The frame we want is the outermost one that contains a reference to cshow().
    """
    import inspect

    globs = dict()

    for i in inspect.stack():
        if "cshow" in i[0].f_globals:
            globs = i[0].f_globals
    return globs


def load_script(name, check_script=True, warnings_as_error=False):
    """
    Loads a user script.

    Args:
        name (string): the name of the file to load. If this is not a full path the file is assumed to be in C:\\scripts
        check_script: When True run the script checker on the script; False otherwise (default True)
        warnings_as_error: When true throw an exception on a warning; False otherwise (default False)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())

    try:
        globs = _get_correct_globals()

        try:
            try:
                full_name = get_correct_filepath_existing(name)
            except Exception:
                # Try with default script directory prepended

                full_name = get_correct_filepath_existing(os.path.join(get_user_script_dir(), name))
        except Exception:
            raise Exception("Script file was not found (%s)" % get_correct_path(name))

        directory, filename = os.path.split(os.path.abspath(full_name))

        # Add the directory to the path in case there are relative imports
        if directory not in sys.path:
            sys.path.append(directory)

        try:

            # Now check the script details with a linter
            if check_script:
                instrument_full_name = __api.get_instrument_full_name()
                sc = ScriptChecker()
                errs = sc.check_script(full_name, instrument_full_name, warnings_as_error=warnings_as_error)
                if len(errs) > 0:
                    combined = "script not loaded as errors found in script: "
                    for e in errs:
                        combined += "\n\t" + e
                    raise Exception(combined)

            mod = __load_module(filename[0:-3], directory)

            # Safe to load
            # Read the file to get the name of the functions
            funcs = []
            file_path = os.path.join(directory, filename)

            with open(file_path) as f:
                for l in f.readlines():
                    m = re.match("^def\s+(.+)\(", l)
                    if m is not None:
                        funcs.append(m.group(1))

            scripts = []
            for att in dir(mod):
                if isinstance(mod.__dict__.get(att), types.FunctionType):
                    # Check function comes from script file not an import
                    if att in funcs:
                        scripts.append(att)

            if len(scripts) > 0:
                # This is where the script file is actually loaded
                with open(file_path) as f:
                    file_contents = f.read()

                # dont_inherit=True so that __future__ statements in this file are not propagated to user scripts
                code = compile(file_contents, file_path, 'exec', dont_inherit=True)
                exec(code, globs)

                msg = "Loaded the following script(s): "
                for script in scripts:
                    msg += script + ", "
                print(msg[0:-2])
                print("From: %s" % file_path)

                print("File last modified: %s" %
                      datetime.datetime.fromtimestamp(os.path.getmtime(file_path)).strftime("%Y-%m-%d %H:%M:%S"))
            else:
                raise Exception("No scripts found in {} - please ensure all your code is contained within functions."
                                .format(file_path))
        except Exception as e:
            if directory in sys.path:
                sys.path.remove(directory)
            raise
    except Exception as e:
        _handle_exception(e)


def __load_module(name, directory):
    """
    This will reload the module if it has already been loaded.
    """
    fpath = None
    try:
        fpath, pathname, description = imp.find_module(name, [directory])
        return imp.load_module(name, fpath, pathname, description)
    finally:
        # Since we may exit via an exception, close fpath explicitly.
        if fpath is not None:
            fpath.close()


def get_script_dir():
    """
    Get the current script directory.

    Returns:
        string: the directory
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    return get_user_script_dir()


def set_script_dir(directory):
    """
    Set the directory for loading scripts from.

    Deprecated - use change_script_dir.

    Args:
        directory (string): the directory to load scripts from
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    print("set_script_dir is deprecated - use change_script_dir")
    change_script_dir(directory)


def change_script_dir(directory):
    """
    Set the directory for loading user scripts from.

    Args:
        directory (string): the directory to load user scripts from
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        set_user_script_dir(directory)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def change_start():
    """
    Start a change operation.

    The operation is finished when change_finish is called.

    Between these two calls a sequence of other change commands can be called.
    For example: change_tables, change_tcb etc.
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:

        __api.dae.change_start()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def change_finish():
    """
    End a change operation.

    The operation is begun when change_start is called.

    Between these two calls a sequence of other change commands can be called.
    For example: change_tables, change_tcb etc.
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.change_finish()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('spec, low, high')
def change_monitor(spec, low, high):
    """
    Change the monitor to a specified spectrum and range.

    Args:
        spec (int): the spectrum number
        low (float): the low end of the integral
        high (float): the high end of the integral
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.change_monitor(spec, low, high)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[wiring], [detector], [spectra]')
def change_tables(wiring=None, detector=None, spectra=None):
    """
    Load the wiring, detector and/or spectra tables.
    Checks that the file paths are valid, throws exception if not.
    Tables are confirmed as correct in _change_dae_settings (genie_dae)
    Args:
        wiring (string, optional): the filename of the wiring table file
        detector (string, optional): the filename of the detector table file
        spectra (string, optional): the filename of the spectra table file
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:

        #check for filepath exceptions. None guard for correct exception

        if wiring is not None:
            wiring = get_correct_filepath_existing(get_absolute_path(wiring))
        if spectra is not None:
            spectra = get_correct_filepath_existing(get_absolute_path(spectra))
        if detector is not None:
            detector = get_correct_filepath_existing(get_absolute_path(detector))
        
        #if they're not all empty, change the tables.
        if not all(path is None for path in (wiring, detector, spectra)):
            __api.dae.change_tables(wiring, detector, spectra)
        else:
            raise ValueError("No file paths were provided.")
    except Exception as e:
        _handle_exception(e)

def get_absolute_path(path):
    """ Returns the absolute table path for a given filename

    If the path is already absolute, the path is returned unchanged
    Else, the path is added onto the instruments full table path.
    """
    ED = EnvironmentDetails()
    table_path_template = "C:/Instrument/Settings/config/{}/configurations/tables/{}".format(ED.get_host_name(),"{}")
    if not is_absolute(path):
        return table_path_template.format(path)
    else:
        return path

def is_absolute(path):
    """ returns true if the path is absolute, i.e. contains slashes
    """
    match = re.search("^((?![\\\/]).)*$", path)
    return match is None


@usercommand
@helparglist('source')
def change_sync(source):
    """
    Change the source the DAE using for synchronisation.

    Args:
        source (string): the source to use ('isis', 'internal', 'smp', 'muon cerenkov', 'muon ms', 'isis (first ts1)')
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.change_sync(source)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[tcbfile], [default]')
def change_tcb_file(tcbfile=None, default=False):
    """
    Change the time channel boundaries.

    Args:
        tcbfile (string, optional): the file to load
        default (bool, optional): load the default file
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.change_tcb_file(tcbfile, default)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[low], [high], [step], [trange], [log], [regime]')
def change_tcb(low=None, high=None, step=None, trange=1, log=False, regime=1):
    """
    Change the time channel boundaries.
    If None is specified for low, high or step then the values are left unchanged.

    Args
        low (float, optional): the lower limit. Default is no change from the current value.
        high (float, optional): the upper limit. Default is no change from the current value.
        step (float,optional): the step size. Default is no change from the current value.
        trange (int, optional): the time range (1 to 5). Default is 1.
        log (bool, optional): whether to use LOG binning. Default is no.
        regime (int, optional): the time regime to set (1 to 6). Default is 1.

    Examples:
        Changes the from, to and step of the 1st range to 0, 10 and 5 respectively.
        
        >>> change_tcb(0, 10, 5)

        Changes the step size of the 2nd range to 2, leaving other parameters unchanged.
        
        >>> change_tcb(step=2, trange=2)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.change_tcb(low, high, step, trange, log, regime)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('trange, [regime]')
def get_tcb_settings(trange, regime=1):
    """
    Gets a dictionary of the time channel settings.

    Args:
        trange (int): the time range to read (1 to 5)
        regime (int, optional): the regime to read (1 to 6). Default is 1.

    Returns:
        dict: the low, high and step for the supplied range and regime

    Examples:
        Get the step size for the 2nd range in the 3rd regime:
        
        >>> get_tcb_settings(2, 3)["Steps"]

        Get the step size for the 2nd range in the 3rd regime:
        
        >>> get_tcb_settings(2, 3)["Steps"]
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_tcb_settings(trange, regime)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[...]')
def change_vetos(**params):
    """
    Change the DAE veto settings.

    Args:
        clearall (bool, optional): remove all vetos
        smp (bool, optional): set SMP veto
        ts2 (bool, optional): set TS2 veto
        hz50 (bool, optional): set 50 hz veto
        ext0  (bool, optional): set external veto 0
        ext1  (bool, optional): set external veto 1
        ext2 (bool, optional): set external veto 2
        ext3 (bool, optional): set external veto 3
        fifo (bool, optional): set FIFO veto

    Note: If clearall is specified then all vetos (excluding the FIFO veto) are turned off,
    but it is possible to turn other vetoes back on at the same time.

    Note: FIFO veto is automatically enabled on run begin, but can be changed whilst running.

    Examples:
        Turns all vetoes off then turns the SMP veto back on:
        
        >>> change_vetos(clearall=True, smp=True)

        Turn off FIFO:
        
        >>> change_vetos(fifo=False)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.change_vetos(**params)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[enable], [delay], [width]')
def change_fermi_veto(enable=None, delay=1.0, width=1.0):
    """
    Configure the fermi chopper veto.

    Args:
        enable (bool, optional): enable the fermi veto
        delay (float, optional): the veto delay
        width (float, optional): the veto width
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.set_fermi_veto(enable, delay, width)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[nperiods]')
def enable_soft_periods(nperiods=None):
    """
    Switch the DAE to software periods mode.

    Args:
        nperiods (int, optional): the number of software periods
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.set_period_mode('soft')
        if nperiods is not None:
            __api.dae.set_num_soft_periods(nperiods)
    except Exception as e:
        _handle_exception(e)


def set_number_soft_periods(number, enable=None):
    """
    Sets the number of software periods for the DAE.

    Deprecated - use change_number_soft_periods.

    Args:
        number (int): the number of periods to create
        enable (bool, optional): switch to soft period mode
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    print("set_number_soft_periods is deprecated - use change_number_soft_periods")
    change_number_soft_periods(number, enable)


@usercommand
@helparglist('mode[, ...]')
def enable_hard_periods(mode, period_file=None, sequences=None, output_delay=None, period=None, daq=False, dwell=False,
                        unused=False, frames=None, output=None, label=None):
    """
    Sets the DAE to use hardware periods.

    Args:
        mode (string): set the mode to internal ('int') or external ('ext')
        period_file (string, optional): the file containing the internal period settings (ignores any other settings)
        sequences (int, optional): the number of times to repeat the period loop (0 = infinite loop)
        output_delay (int, optional): the output delay in microseconds
        period (int, optional): the number of the period to set the following parameters for
        daq (bool, optional):  the specified period is a acquisition period
        dwell (bool, optional): the specified period is a dwell period
        unused (bool, optional): the specified period is a unused period
        frames (int, optional): the number of frames to count for the specified period
        output (int, optional): the binary output the specified period
        label (string, optional): the label for the period the specified period

    Note: if the period number is unspecified then the settings will be applied to all periods

    Examples:
        Setting external periods:
        
        >>> enable_hard_periods('ext')

        Setting internal periods from a file:
        
        >>> enable_hard_periods('int', 'c:\\myperiods.txt')
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.configure_hard_periods(mode, period_file, sequences, output_delay, period, daq, dwell, unused, frames,
                                         output, label)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[...]')
def configure_internal_periods(sequences=None, output_delay=None, period=None, daq=False, dwell=False, unused=False,
                               frames=None, output=None, label=None):
    """
    Configure the internal periods without switching to internal period mode.

    Args:
        sequences (int, optional): the number of times to repeat the period loop (0 = infinite loop)
        output_delay (int, optional): the output delay in microseconds
        period (int, optional): the number of the period to set the following parameters for
        daq (bool, optional):  the specified period is a acquisition period
        dwell (bool, optional): the specified period is a dwell period
        unused (bool, optional): the specified period is a unused period
        frames (int, optional): the number of frames to count for the specified period
        output (int, optional): the binary output the specified period
        label (string, optional): the label for the period the specified period

    Note: if the period number is unspecified then the settings will be applied to all periods
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.configure_internal_periods(sequences, output_delay, period, daq, dwell, unused, frames, output, label)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('[...]')
def define_hard_period(period=None, daq=False, dwell=False, unused=False, frames=None, output=None, label=None):
    """
    Define the internal hardware periods.

    Args:
        period (int, optional): the number of the period to set the following parameters for
        daq (bool, optional):  the specified period is a acquisition period
        dwell (bool, optional): the specified period is a dwell period
        unused (bool, optional): the specified period is a unused period
        frames (int, optional): the number of frames to count for the specified period
        output (int, optional): the binary output the specified period
        label (string, optional): the label for the period the specified period

    Note: if the period number is unspecified then the settings will be applied to all periods
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        configure_internal_periods(None, None, period, daq, dwell, unused, frames, output, label)
    except Exception as e:
        _handle_exception(e)


def change(**params):
    """
    Change experiment parameters.

    Note: it is possible to change more than one item at a time.

    Args:
        title (string, optional): the new title
        period (int, optional): the new period (must be in a non-running state)
        nperiods (int, optional): the new number of software periods (must be in a non-running state)
        user (string, optional): the new user(s) as a comma-separated list
        rb (int, optional): the new RB number

    Examples:
        Change the title:
        
        >>> change(title="The new title")

        Change the user:
        
        >>> change(user="Instrument Team")

        Set multiple users:
        
        >>> change(user="Thouless, Haldane, Kosterlitz")

        Change the RB number and the users:
        
        >>> change(rb=123456, user="Smith, Jones")
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        for k in params:
            key = k.lower().strip()
            if key == 'title':
                change_title(params[k])
            elif key == 'period':
                change_period(params[k])
            elif key == 'nperiods':
                change_number_soft_periods(params[k])
            elif key == 'user' or key == 'users':
                change_users(params[k])
            elif key == 'rb':
                change_rb(params[k])
            else:
                raise KeyError("Unknown parameter supplied. Type help(change) for more information")
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('title')
def change_title(title):
    """
    Sets the current title.

    Args:
        title: the new title
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.set_title(title)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('period')
def change_period(period):
    """
    Changes the current period number.

    Args:
        period (int): the period to switch to
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.set_period(period)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('number[, enable]')
def change_number_soft_periods(number, enable=False):
    """
    Sets the number of software periods for the DAE.

    Args:
        number (int): the number of periods to create
        enable (bool, optional): switch to soft period mode
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        if enable:
            __api.dae.set_period_mode('soft')
        __api.dae.set_num_soft_periods(number)
    except Exception as e:
        _handle_exception(e)

@usercommand
@helparglist('')
def get_users():
    """
    Get the users.

    Returns:
        str: the users.
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_users()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('users')
def change_users(users):
    """
    Changes the users.

    Args:
        users: a string containing the user name(s)

    Example:
        
        >>> change_users("Emerson, Lake, Palmer")
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.dae.set_users(users)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('rb')
def change_rb(rb):
    """
    Changes the RB number.

    Args:
        rb (int or string): the new RB number
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        if isinstance(rb, int):
            # If it is an int then that is fine, just cast to str as the PV is a string
            rb = str(rb)
        elif isinstance(rb, str):
            # Let's be kind in case they enter a string.
            # Check string contains only digits though
            if not rb.isdigit():
                raise TypeError("RB number must be a number.")
        else:
            raise TypeError("RB number must be a number.")
        __api.dae.set_rb_number(rb)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('spectrum[, period][, dist]')
def get_spectrum(spectrum, period=1, dist=True):
    """
    Get the specified spectrum from the DAE.

    Args:
        spectrum (int): the spectrum number
        period (int, optional): the period
        dist (bool, optional): whether to get the spectrum as a distribution. Default is True.

    Returns:
        dict: dictionary of values
    """
    try:
        return __api.dae.get_spectrum(spectrum, period, dist)
    except Exception as e:
        _handle_exception(e)

@usercommand
@helparglist('spectrum[, period][, dist]')
def plot_spectrum(spectrum, period=1, dist=True):
    """
    Get the specified spectrum from the DAE and plot it. Returns the plot that was created.

    Note: this will replace any other plots which are open.

    Args:
        spectrum (int): the spectrum number
        period (int, optional): the period. Default is 1
        dist (bool, optional): whether to get the spectrum as a distribution. Default is True

    Returns:
        The created plot

    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        # Import SpectraPlot locally as it uses matplotlib, and the user may want to change
        # some matplotlib config parameters before it is used for the first time.
        from genie_python.genie_plot import SpectraPlot
        return SpectraPlot(__api, spectrum, period, dist)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def add_spectrum(*a, **kw):
    """
    add_spectrum has been removed from genie_python.

    You can now add additional spectra to an existing plot using the following:
    >>> spectra_graph = g.plot_spectrum(1)
    >>> spectra_graph.add_spectrum(2)
    >>> spectra_graph.add_spectrum(3, period=2)
    >>> ...
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    print(add_spectrum.__doc__)


@usercommand
@helparglist('spectrum[, period][, t_min][, t_max]')
def integrate_spectrum(spectrum, period=1, t_min=None, t_max=None):
    """
    Integrates the spectrum within the time period and returns neutron counts.

    The underlying algorithm sums the counts from each bin, if a bin is split by the time region then a proportional
         fraction of the count for that bin is used.

    Args:
        spectrum (int): the spectrum number
        period (int, optional): the period
        t_min (float, optional): time of flight to start from
        t_max (float, optional): time of flight to finish at

    Returns:
        float: integral of the spectrum (neutron counts); None spectrum can not be read
    """
    try:
        return __api.dae.integrate_spectrum(spectrum, period, t_min, t_max)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_sample_pars():
    """
    Get the current sample parameter values.

    Returns:
        dict: the sample parameters
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        names = __api.get_sample_pars()
        return names
    except Exception as e:
        _handle_exception(e)


def set_sample_par(name, value):
    """
    Set a new value for a sample parameter.

    Deprecated - use change_sample_par.

    Args:
        name (string): the name of the parameter to change
        value: the new value
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    print("set_sample_par is deprecated - use change_sample_par")
    change_sample_par(name, value)


@usercommand
@helparglist('name, value')
def change_sample_par(name, value):
    """
    Set a new value for a sample parameter.

    Args:
        name (string): the name of the parameter to change
        value: the new value
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.set_sample_par(name, value)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_beamline_pars():
    """
    Get the current beamline parameter values.

    Returns:
        dict: the beamline parameters
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        names = __api.get_beamline_pars()
        return names
    except Exception as e:
        _handle_exception(e)


def set_beamline_par(name, value):
    """
    Set a new value for a beamline parameter

    Deprecated - use change_beamline_par

    Args:
        name (string): the name of the parameter to change
        value: the new value
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    print("set_beamline_par is deprecated - use change_beamline_par")
    change_beamline_par(name, value)


@usercommand
@helparglist('name, value')
def change_beamline_par(name, value):
    """
    Set a new value for a beamline parameter

    Args:
        name (string): the name of the parameter to change
        value: the new value
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        __api.set_beamline_par(name, value)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('phone_num, message')
def send_sms(phone_num, message):
    """
    Sends an SMS message to a phone number.

    Args:
        phone_num (string): the phone number to send the SMS to
        message (string): the message to send
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    __api.send_sms(phone_num, message)


@usercommand
@helparglist('message, inst')
def send_alert(message, inst=None):
    """
    Sends an alert message for the specified instrument.

    Args:
        message (string): the message to send
        inst (string, optional): the instrument to generate the alert for. Defaults to current instrument.
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    __api.send_alert(message, inst)


@usercommand
@helparglist('address, message')
def send_email(address, message):
    """
    Sends a message to an email address.

    Args:
        address (string): the email address to use
        message (string): the message to send
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    __api.send_email(address, message)

@usercommand
@helparglist('message, host, port, reply')
def send_tcpip(message, host="localhost", port=80, reply=True):
    """
    Sends a message to tcp port on host.

    Args:
        message (string):  the message to send
        host    (string):  the host address to use (default: localhost)
        port    (integer): the tcpip port to use (default: 80)
        reply   (bool):    whether to wait for a reply (default: True)
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    return __api.send_tcpip(message, host, port, reply)

@usercommand
@helparglist('')
def get_wiring_tables():
    """
    Gets a list of possible wiring table choices.

    Returns:
        list: the files
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_wiring_tables()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_spectra_tables():
    """
    Gets a list of possible spectra table choices.

    Returns:
        list: the files
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_spectra_tables()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_detector_tables():
    """
    Gets a list of possible detector table choices.

    Returns:
        list: the files
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_detector_tables()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_period_files():
    """
    Gets a list of possible period file choices.

    Returns:
        list: the files
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_period_files()
    except Exception as e:
        _handle_exception(e)


def check_alarms(*blocks):
    """
    Checks whether the specified blocks are in alarm.

    Args:
        blocks (string, multiple): the block(s) to check

    Returns:
        list, list: the blocks in minor alarm and major alarm respectively

    Example:
        Check alarm state for block1 and block2:
        
        >>> check_alarms("block1", "block2")
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.check_alarms(blocks)
    except Exception as e:
        _handle_exception(e)


def check_limit_violations(*blocks):
    """
    Checks whether the specified blocks have soft limit violations.

    Args:
        blocks (string, multiple): the block(s) to check

    Returns:
        list: the blocks that have soft limit violations

    Example:
        Check soft limit violations for block1 and block2:
        
        >>> check_limit_violations("block1", "block2")
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.check_limit_violations(blocks)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('name')
def prefix_pv_name(name):
    """
    Prepends the instrument PV prefix on to the supplied PV name

    Args:
        name (string): The PV without the prefix.

    Returns:
        string: The PV with the instrument prefix prepended
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.prefix_pv_name(name)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_version():
    """
    Tells you the version of genie_python that is used.

    Returns:
        string: The current version number of genie python
    """
    return VERSION


@usercommand
@helparglist('mode')
def set_dae_simulation_mode(mode, skip_required_runstates=False):
    """
    Sets the DAE into simulation mode.
    Args:
         mode: True to set the DAE into simulated mode, False to set the DAE into non-simulated (hardware) mode
         skip_required_runstates: Ignore all checks, use with caution
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        # skip_required_runstates must be passed as a keyword argument for wrapper to catch it.
        return __api.dae.set_simulation_mode(mode, skip_required_runstates=skip_required_runstates)
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_dae_simulation_mode():
    """
    Gets the DAE simulation mode.
    Returns:
        True if the DAE is in simulation mode, False otherwise.
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.dae.get_simulation_mode()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_instrument():
    """
    Gets the name of the local instrument (e.g. NDW1234, DEMO, EMMA-A)

    Returns:
        the name of the local instrument
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.get_instrument()
    except Exception as e:
        _handle_exception(e)


@usercommand
@helparglist('')
def get_instrument_py_name():
    """
    Gets the name of the local instrument in lowercase and with "-" replaced with "_"

    Returns:
        the name of the local instrument in a python-friendly format
    """
    __api.log_command(sys._getframe().f_code.co_name, locals())
    try:
        return __api.get_instrument_py_name()
    except Exception as e:
        _handle_exception(e)


def load(name):
    """
    Informs the user that load may not be the function they want.
    Prints a message telling the user about g.loadscript and numpy.load.
    
    Args:
        name (string): The script the user is trying to load.
    """
    print("This function does not load a script; you probably wanted g.load_script(\"{0}\")."
          "If you wanted numpy load please call it directly with import numpy as numpy; "
          "numpy.load(\"{0}\")".format(get_correct_path(name)))
    return

@usercommand
def get_wiring_table():
    """ Gets the current wiring table path"

    Returns:
            The file path of the current wiring table.
    """       
    try:
        return __api.dae.get_table_path("Wiring")
    except Exception as e:
        _handle_exception(e)

@usercommand
def get_spectra_table():
    """ Gets the current spectra table path"

    Returns:
            The file path of the current spectra table.
    """    
    try:
        return __api.dae.get_table_path("Spectra")
    except Exception as e:
        _handle_exception(e)

@usercommand
def get_detector_table():
    """ Gets the current detector table path"

    Returns:
            The file path of the current detector table.
    """
    try:
        return __api.dae.get_table_path("Detector")
    except Exception as e:
        _handle_exception(e)
