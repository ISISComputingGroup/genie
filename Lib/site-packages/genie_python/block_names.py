import zlib
from keyword import iskeyword

from threading import Timer

from .genie_blockserver import BLOCK_SERVER_PREFIX, PV_BLOCK_NAMES

from .channel_access_exceptions import UnableToConnectToPVException
from .genie_cachannel_wrapper import CaChannelWrapper
from .utilities import dehex_decompress_and_dejson

DELAY_BEFORE_RETRYING_BLOCK_NAMES_PV_ON_FAIL = 30.0


class BlockNamesManager:
    """
    Manager for a blocks name object. It makes sure that the blocks it contains are updated
    """

    def __init__(self, block_names, delay_before_retry_add_monitor=DELAY_BEFORE_RETRYING_BLOCK_NAMES_PV_ON_FAIL):
        """
        Constructor.
        :param block_names: the block name instance that this manger is managing
        :param delay_before_retry_add_monitor: if the block names pv doesn't exist on start the delay before retrying
        """
        self._block_names = block_names
        self.cancel_monitor_fn = None
        self._delay_before_retry_add_monitor = delay_before_retry_add_monitor

    def update_prefix(self, pv_prefix):
        """
        Update the instrument prefix that the manager is using
        :param pv_prefix: new pv prefix
        """
        if self.cancel_monitor_fn is not None:
            self.cancel_monitor_fn()

        pv_name = "{}{}{}".format(pv_prefix, BLOCK_SERVER_PREFIX, PV_BLOCK_NAMES)
        try:
            self.cancel_monitor_fn = CaChannelWrapper.add_monitor(pv_name, self._update_block_names, to_string=True)
        except UnableToConnectToPVException:
            # reschedule add monitor
            Timer(self._delay_before_retry_add_monitor, self.update_prefix, args=[pv_prefix]).start()
        else:
            # get initial value
            try:
                self._update_block_names(CaChannelWrapper.get_pv_value(pv_name, to_string=True), None, None)
            except UnableToConnectToPVException:
                # if pv is not available then monitor will pick it up when it changes
                pass

    def _update_block_names(self, value, severity, status):
        """
        Update the block names from a pv
        Args:
            :param value: new value of block names pv
            :param severity(CaChannel._ca.AlarmSeverity): severity of any alarm
            :param alarm status(CaChannel._ca.AlarmCondition): status of the alarm
        """
        # remove old blocks
        for block_name in list(self._block_names.__dict__.keys()):
            delattr(self._block_names, block_name)

        # add new block as attributes to class
        try:
            block_names = dehex_decompress_and_dejson(value)
            for name in block_names:
                attribute_name = name
                if iskeyword(attribute_name):
                    attribute_name = f"{attribute_name}__"
                setattr(self._block_names, attribute_name, name)
        except (zlib.error, ValueError, TypeError):
            # if we can not decode the blocks then just pass
            pass


class BlockNames:
    """
    Hold names of the current blocks in config. If block is requested which does not appear in the current config
    block name returned but message printed about it.
    """

    def __getattr__(self, attr):
        """
        If an attribute is not set then return name requested
        :param attr: attribute name
        :return: block name, which is the same as the attribute
        """
        if attr.startswith("_"):  # don't mask not having dunder methods all blocks start with a letter, e.g. ipython
                                  # console calls __wrapper__ to check it is not a wrapper
            raise AttributeError()
        print("Block name {} not found, it may not exist".format(attr))
        if attr.endswith("__") and iskeyword(attr[:-2]):
            return str(attr[:-2])
        return attr
