"""
A matplotlib backend based on WebAgg, modified to:
- Be non-blocking
- Open plots in the IBEX client
"""
import os
import sys
import threading
from time import sleep
import six
import atexit
import tornado
import asyncio
import json
from tornado.websocket import WebSocketClosedError
from tornado.iostream import StreamClosedError
from matplotlib._pylab_helpers import Gcf
from matplotlib.backend_bases import _Backend
from matplotlib.backends import backend_webagg
from matplotlib.backends import backend_webagg_core as core
from concurrent.futures.thread import ThreadPoolExecutor
from py4j.java_gateway import JavaGateway
from py4j.java_collections import ListConverter

DEFAULT_HOST = "127.0.0.1"

PRIMARY_WEB_PORT = 8988
SECONDARY_WEB_PORT = 8989
max_number_of_figures = 3
figure_numbers = []


ServerThread = backend_webagg.ServerThread

webagg_server_thread = ServerThread()

FigureCanvasWebAgg = backend_webagg.FigureCanvasWebAgg

_web_backend_port = PRIMARY_WEB_PORT
_is_primary = True

"""
All interactions with WebAggApplication go via this worker thread.

This allows us to keep serving the plot while we do other logic in the python script

Also register it with atexit so that it is properly shut down when the interpreter stops.
"""
EXECUTOR = ThreadPoolExecutor(1)
atexit.register(lambda: EXECUTOR.shutdown())

def _ignore_if_websocket_closed(func):
    """
    Decorator which ignores exceptions that were caused by websockets being closed.
    """
    @six.wraps(func)
    def wrapper(*a, **kw):
        try:
            return func(*a, **kw)
        except (WebSocketClosedError, BufferError, AssertionError, AttributeError):
            # Plotting multiple graphs quickly can cause an error where pyplot tries to access a plot which
            # has been removed. This error does not break anything, so it is caught with the except AttributeError.
            pass
    return wrapper
    
    
def _asyncio_ignore_if_websocket_closed(loop, context):
    exception = context.get('exception')
    if not isinstance(exception, (WebSocketClosedError, StreamClosedError)):
        loop.default_exception_handler(context)


asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
asyncio.get_event_loop().set_exception_handler(_asyncio_ignore_if_websocket_closed)


def set_up_plot_default(is_primary=True, should_open_ibex_window_on_show=True, max_figures=None):
    """
    Set the plot defaults for when show is called

    Args:
        is_primary: True display plot on primary web port; False display plot on secondary web port
        should_open_ibex_window_on_show: Does nothing; provided for backwards-compatibility with older backend
        max_figures: Maximum number of figures to plot simultaneously (int)
    """
    global _web_backend_port
    if is_primary:
        _web_backend_port = PRIMARY_WEB_PORT
    else:
        _web_backend_port = SECONDARY_WEB_PORT

    global _is_primary
    _is_primary = is_primary
    
    global max_number_of_figures
    if max_figures is not None:
        max_number_of_figures = max_figures


class WebAggApplication(backend_webagg.WebAggApplication):     
    class WebSocket(tornado.websocket.WebSocketHandler):
        supports_binary = True

        @_ignore_if_websocket_closed
        def open(self, fignum):
            self.fignum = int(fignum)
            self.manager = Gcf.figs.get(self.fignum, None)
            if self.manager is not None:
                self.manager.add_web_socket(self)
                if hasattr(self, 'set_nodelay'):
                    self.set_nodelay(True)

        @_ignore_if_websocket_closed
        def on_close(self):
            self.manager.remove_web_socket(self)

        @_ignore_if_websocket_closed
        def on_message(self, message):
            message = json.loads(message)
            # The 'supports_binary' message is on a client-by-client
            # basis.  The others affect the (shared) canvas as a
            # whole.
            if message['type'] == 'supports_binary':
                self.supports_binary = message['value']
            else:
                manager = Gcf.figs.get(self.fignum, None)
                # It is possible for a figure to be closed,
                # but a stale figure UI is still sending messages
                # from the browser.
                if manager is not None:
                    manager.handle_json(message)

        @_ignore_if_websocket_closed
        def send_json(self, content):
            self.write_message(json.dumps(content))

        @_ignore_if_websocket_closed
        def send_binary(self, blob):
            if self.supports_binary:
                self.write_message(blob, binary=True)
            else:
                data_uri = "data:image/png;base64,{0}".format(
                    blob.encode('base64').replace('\n', ''))
                self.write_message(data_uri)

    ioloop = None
    started = False

    @classmethod
    def initialize(cls, url_prefix='', port=None, address=None):
        """
        Create the class instance

        We use a constant, hard-coded port as we will only ever have one plot going at the same time.
        """
        app = cls(url_prefix=url_prefix)
        cls.url_prefix = url_prefix
        cls.port = port
        cls.address = address

        app.listen(cls.port, cls.address)

        cls.ioloop = tornado.ioloop.IOLoop.current()


    @classmethod
    def start(cls):
        """
        IOLoop.running() was removed as of Tornado 2.4; see for example
        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY
        Thus there is no correct way to check if the loop has already been
        launched. We may end up with two concurrently running loops in that
        unlucky case with all the expected consequences.
        """
        # Set the flag to True *before* blocking on ioloop.start()
        cls.started = True
        atexit.register(lambda: cls.stop())
        cls.ioloop.start()


    @classmethod
    def stop(cls):
        def _stop():
            cls.ioloop.stop()
            sys.stdout.flush()
            cls.started = False
        cls.ioloop.add_callback(_stop)


def ibex_open_plot_window(figures, is_primary=True, host=None):
    """
    Open the plot window in ibex gui through py4j. With sensible defaults
    Args:
        is_primary: True for primary plot window; False for secondary
        host: host that the plot is on; if None default to local host
    """
    port = PRIMARY_WEB_PORT if is_primary else SECONDARY_WEB_PORT
    if host is None:
        host = DEFAULT_HOST
    url = "{}:{}".format(host, port)
    try:
        gateway = JavaGateway()
        figures = ListConverter().convert(figures, gateway._gateway_client)
        gateway.entry_point.openMplRenderer(figures, url, is_primary)
    except Exception as e:
        print(f"Failed to open plot in IBEX due to: {e}")


IBEX_BACKEND_LOCK = threading.RLock()


class _FigureCanvas(FigureCanvasWebAgg):
    def set_image_mode(self, mode):
        """
        Always send full images to ibex.
        """
        self._current_image_mode = "full"

    def get_diff_image(self, *args, **kwargs):
        """
        Always send full images to ibex.
        """
        self._force_full = True
        return super(_FigureCanvas, self).get_diff_image(*args, **kwargs)


@_Backend.export
class _BackendIbexWebAgg(_Backend):
    FigureCanvas = _FigureCanvas
    FigureManager = core.FigureManagerWebAgg

    @classmethod
    def trigger_manager_draw(cls, manager):
        with IBEX_BACKEND_LOCK:
            manager.canvas.draw_idle()

    @classmethod
    def draw_if_interactive(cls):
        with IBEX_BACKEND_LOCK:
            _Backend.draw_if_interactive()

    @staticmethod
    def show(*args, **kwargs):
        """
        Show a plot.

        Args:
            args and kwargs: ignored (needed for compatibility with genie_python)
        """
        if not WebAggApplication.started:
            with IBEX_BACKEND_LOCK:
                WebAggApplication.initialize(port=_web_backend_port)
                EXECUTOR.submit(WebAggApplication.start)

                while not WebAggApplication.started:
                    # Wait for it to start
                    sleep(0.01)
        ibex_open_plot_window([x for x in Gcf.figs.keys()], is_primary=_is_primary)
        with IBEX_BACKEND_LOCK:
            try:
                Gcf.draw_all()
            except Exception as e:
                # Very occasionally draw_all() can fail, if that's the case it's better to not draw
                # (IBEX will force an update 2s later anyway) rather than crash.
                pass

    @classmethod
    def new_figure_manager(cls, num, *args, **kwargs):
        with IBEX_BACKEND_LOCK:
            for x in list(figure_numbers):
                if x not in Gcf.figs.keys():
                    figure_numbers.remove(x)
            figure_numbers.append(num)
            if len(figure_numbers) > max_number_of_figures:
                Gcf.destroy(figure_numbers[0])
                print("There are too many figures so deleted the oldest figure, which was {}.".format(
                    figure_numbers[0]))
                figure_numbers.pop(0)
            return super(_BackendIbexWebAgg, cls).new_figure_manager(num, *args, **kwargs)
