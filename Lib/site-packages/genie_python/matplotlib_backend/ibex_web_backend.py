"""
A matplotlib backend based on WebAgg, modified to:
- Be non-blocking
- Open plots in the IBEX client
"""
import os
import sys
import threading
from time import sleep
import six
import atexit
import tornado
import asyncio
from tornado.websocket import WebSocketClosedError
from matplotlib._pylab_helpers import Gcf
from matplotlib.backend_bases import _Backend
from matplotlib.backends import backend_webagg
from matplotlib.backends import backend_webagg_core as core
from concurrent.futures.thread import ThreadPoolExecutor
from py4j.java_gateway import JavaGateway

DEFAULT_HOST = "127.0.0.1"

PRIMARY_WEB_PORT = 8988
SECONDARY_WEB_PORT = 8989
MAX_NUMBER_OF_FIGURES = 6
figure_numbers = []


ServerThread = backend_webagg.ServerThread

webagg_server_thread = ServerThread()

FigureCanvasWebAgg = backend_webagg.FigureCanvasWebAgg

_web_backend_port = PRIMARY_WEB_PORT
_is_primary = True
_should_open_ibex_window_on_show = True

"""
All interactions with WebAggApplication go via this worker thread.

This allows us to keep serving the plot while we do other logic in the python script

Also register it with atexit so that it is properly shut down when the interpreter stops.
"""
EXECUTOR = ThreadPoolExecutor(1)
atexit.register(lambda: EXECUTOR.shutdown())

"""
We provide a custom templates path as we are doing some additional websocket cleanup in the javascript files
so we can't just use matplotlib's
"""
TEMPLATES_PATH = os.path.join(os.path.dirname(__file__), "templates")


asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())


def _ignore_if_websocket_closed(func):
    """
    Decorator which ignores exceptions that were caused by websockets being closed.
    """
    @six.wraps(func)
    def wrapper(*a, **kw):
        try:
            return func(*a, **kw)
        except (WebSocketClosedError, BufferError, AssertionError, AttributeError):
            # Plotting multiple graphs quickly can cause an error where pyplot tries to access a plot which
            # has been removed. This error does not brake anything, so it is caught with the except AttributeError.
            pass
    return wrapper


def set_up_plot_default(is_primary=True, should_open_ibex_window_on_show=True):
    """
    Set the plot defaults for when show is called

    Args:
        is_primary: True display plot on primary web port; False display plot on secondary web port
        should_open_ibex_window_on_show: True try to open the plot window in the ibex gui; False don't try
    """
    global _web_backend_port
    if is_primary:
        _web_backend_port = PRIMARY_WEB_PORT
    else:
        _web_backend_port = SECONDARY_WEB_PORT

    global _is_primary
    _is_primary = is_primary

    global _should_open_ibex_window_on_show
    _should_open_ibex_window_on_show = should_open_ibex_window_on_show


class WebAggApplication(backend_webagg.WebAggApplication):

    # We're not using the SingleFigurePage so no need to override functionality related to it.

    class AllFiguresPage(backend_webagg.WebAggApplication.AllFiguresPage):
        """
        Override the template path to our own area
        """
        def get_template_path(self):
            return TEMPLATES_PATH

    class WebSocket(backend_webagg.WebAggApplication.WebSocket):
        open = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.open)
        on_close = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.on_close)
        on_message = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.on_message)
        send_json = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.send_json)
        send_binary = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.send_binary)

    ioloop = None
    started = False

    @classmethod
    def initialize(cls, url_prefix='', port=None, address=None):
        """
        Create the class instance

        We use a constant, hard-coded port as we will only ever have one plot going at the same time.
        """
        app = cls(url_prefix=url_prefix)
        cls.url_prefix = url_prefix
        cls.port = port
        cls.address = address

        app.listen(cls.port, cls.address)

        cls.ioloop = tornado.ioloop.IOLoop.current()


    @classmethod
    def start(cls):
        """
        IOLoop.running() was removed as of Tornado 2.4; see for example
        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY
        Thus there is no correct way to check if the loop has already been
        launched. We may end up with two concurrently running loops in that
        unlucky case with all the expected consequences.
        """
        # Set the flag to True *before* blocking on ioloop.start()
        cls.started = True
        atexit.register(lambda: cls.stop())
        cls.ioloop.start()


    @classmethod
    def stop(cls):
        def _stop():
            cls.ioloop.stop()
            sys.stdout.flush()
            cls.started = False
        cls.ioloop.add_callback(_stop)


def ibex_open_plot(url, is_primary=True):
    """
    Requests IBEX client opens the plot window. Fall back to system web browser on failure.

    Note that currently IBEX will open the plot window in the current perspective.

    Args:
        url: The URL where the plot can be found
        is_primary: True for primary plot windows; False otherwise
    """
    try:
        JavaGateway().entry_point.openPlot(url, is_primary)
    except Exception:
        # Don't use webbrowser.open here as there is potential to call show several times during some methods.
        # In that case, we don't want to spam-open tabs on the user's machine.
        print("Couldn't open plot in IBEX. Plot can be viewed in a web browser at: {}".format(url))


def ibex_open_plot_window(is_primary=True, host=None):
    """
    Open the plot window in ibex gui through py4j. With sensible defaults
    Args:
        is_primary: True for primary plot window; False for secondary
        host: host that the plot is on; if None default to local host
    """
    port = PRIMARY_WEB_PORT if is_primary else SECONDARY_WEB_PORT
    if host is None:
        host = DEFAULT_HOST
    url = "http://{}:{}".format(host, port)
    ibex_open_plot(url, is_primary)


IBEX_BACKEND_LOCK = threading.RLock()


@_Backend.export
class _BackendIbexWebAgg(_Backend):
    FigureCanvas = FigureCanvasWebAgg
    FigureManager = core.FigureManagerWebAgg

    @staticmethod
    def trigger_manager_draw(manager):
        with IBEX_BACKEND_LOCK:
            manager.canvas.draw_idle()

    @staticmethod
    def show(*args, **kwargs):
        """
        Show a plot.

        Args:
            args and kwargs: ignored (needed for compatibility with genie_python)
        """
        if not WebAggApplication.started:
            with IBEX_BACKEND_LOCK:
                WebAggApplication.initialize(port=_web_backend_port)
                EXECUTOR.submit(WebAggApplication.start)

                while not WebAggApplication.started:
                    # Wait for it to start
                    sleep(0.01)
        if _should_open_ibex_window_on_show:
            ibex_open_plot_window(is_primary=_is_primary)
        Gcf.draw_all()

    @classmethod
    def new_figure_manager(cls, num, *args, **kwargs):
        with IBEX_BACKEND_LOCK:
            for x in list(figure_numbers):
                if x not in Gcf.figs.keys():
                    figure_numbers.remove(x)
            figure_numbers.append(num)
            if len(figure_numbers) > MAX_NUMBER_OF_FIGURES:
                Gcf.destroy(figure_numbers[0])
                print("There are too many figures so deleted the oldest figure, which was {}.".format(
                    figure_numbers[0]))
                figure_numbers.pop(0)
        return super(_BackendIbexWebAgg, cls).new_figure_manager(num, *args, **kwargs)
