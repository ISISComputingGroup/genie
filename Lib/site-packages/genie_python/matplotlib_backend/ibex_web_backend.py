"""
A matplotlib backend based on WebAgg, modified to:
- Be non-blocking
- Open plots in the IBEX client
"""
import os
import sys
import threading
from time import sleep
import six
import atexit
import tornado
import asyncio
from tornado.websocket import WebSocketClosedError
from matplotlib._pylab_helpers import Gcf
from matplotlib.backend_bases import _Backend
from matplotlib.backends import backend_webagg
from matplotlib.backends import backend_webagg_core as core
from concurrent.futures.thread import ThreadPoolExecutor
from py4j.java_gateway import JavaGateway

PORT = 8988
MAX_NUMBER_OF_FIGURES = 6
figure_numbers = []


ServerThread = backend_webagg.ServerThread

webagg_server_thread = ServerThread()

FigureCanvasWebAgg = backend_webagg.FigureCanvasWebAgg

"""
All interactions with WebAggApplication go via this worker thread.

This allows us to keep serving the plot while we do other logic in the python script

Also register it with atexit so that it is properly shut down when the interpreter stops.
"""
EXECUTOR = ThreadPoolExecutor(1)
atexit.register(lambda: EXECUTOR.shutdown())

"""
We provide a custom templates path as we are doing some additional websocket cleanup in the javascript files
so we can't just use matplotlib's
"""
TEMPLATES_PATH = os.path.join(os.path.dirname(__file__), "templates")


asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())


def _ignore_if_websocket_closed(func):
    """
    Decorator which ignores exceptions that were caused by websockets being closed.
    """
    @six.wraps(func)
    def wrapper(*a, **kw):
        try:
            return func(*a, **kw)
        except (WebSocketClosedError, BufferError, AssertionError, AttributeError):
            # Plotting multiple graphs quickly can cause an error where pyplot tries to access a plot which
            # has been removed. This error does not brake anything, so it is caught with the except AttributeError.
            pass
    return wrapper


class WebAggApplication(backend_webagg.WebAggApplication):

    # We're not using the SingleFigurePage so no need to override functionality related to it.

    class AllFiguresPage(backend_webagg.WebAggApplication.AllFiguresPage):
        """
        Override the template path to our own area
        """
        def get_template_path(self):
            return TEMPLATES_PATH

    class WebSocket(backend_webagg.WebAggApplication.WebSocket):
        open = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.open)
        on_close = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.on_close)
        on_message = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.on_message)
        send_json = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.send_json)
        send_binary = _ignore_if_websocket_closed(backend_webagg.WebAggApplication.WebSocket.send_binary)

    ioloop = None
    started = False

    @classmethod
    def initialize(cls, url_prefix='', port=PORT, address=None):
        """
        Create the class instance

        We use a constant, hard-coded port as we will only ever have one plot going at the same time.
        """
        app = cls(url_prefix=url_prefix)
        cls.url_prefix = url_prefix
        cls.port = port
        cls.address = address

        app.listen(cls.port, cls.address)

        cls.ioloop = tornado.ioloop.IOLoop.current()


    @classmethod
    def start(cls):
        """
        IOLoop.running() was removed as of Tornado 2.4; see for example
        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY
        Thus there is no correct way to check if the loop has already been
        launched. We may end up with two concurrently running loops in that
        unlucky case with all the expected consequences.
        """
        # Set the flag to True *before* blocking on ioloop.start()
        cls.started = True
        atexit.register(lambda: cls.stop())
        cls.ioloop.start()


    @classmethod
    def stop(cls):
        cls.ioloop.stop()
        sys.stdout.flush()
        cls.started = False


def ibex_open_plot(url):
    """
    Open a plot in the IBEX client. Fall back to system web browser on failure.

    Args:
        url: The URL where the plot can be found
    """
    try:
        JavaGateway().entry_point.openPlot(url)
    except Exception:
        # Don't use webbrowser.open here as there is potential to call show several times during some methods.
        # In that case, we don't want to spam-open tabs on the user's machine.
        print("Couldn't open plot in IBEX. Plot can be viewed in a web browser at: {}".format(url))


IBEX_BACKEND_LOCK = threading.RLock()


@_Backend.export
class _BackendIbexWebAgg(_Backend):
    FigureCanvas = FigureCanvasWebAgg
    FigureManager = core.FigureManagerWebAgg

    @staticmethod
    def trigger_manager_draw(manager):
        with IBEX_BACKEND_LOCK:
            manager.canvas.draw_idle()

    @staticmethod
    def show(*args, **kwargs):
        """
        Show a plot.

        Args:
            args and kwargs: ignored (needed for compatibility with genie_python)
        """
        if not WebAggApplication.started:
            with IBEX_BACKEND_LOCK:
                WebAggApplication.initialize()
                EXECUTOR.submit(WebAggApplication.start)

                while not WebAggApplication.started:
                    # Wait for it to start
                    sleep(0.01)

        ibex_open_plot("http://127.0.0.1:{}".format(PORT))
        Gcf.draw_all()

    @classmethod
    def new_figure_manager(cls, num, *args, **kwargs):
        with IBEX_BACKEND_LOCK:
            for x in list(figure_numbers):
                if x not in Gcf.figs.keys():
                    figure_numbers.remove(x)
            figure_numbers.append(num)
            if len(figure_numbers) > MAX_NUMBER_OF_FIGURES:
                Gcf.destroy(figure_numbers[0])
                print("There are too many figures so deleted the oldest figure, which was {}.".format(figure_numbers[0]))
                figure_numbers.pop(0)
        return super(_BackendIbexWebAgg, cls).new_figure_manager(num, *args, **kwargs)
