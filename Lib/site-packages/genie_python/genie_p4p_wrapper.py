"""
Wrapping of p4p in genie_python
"""

from __future__ import absolute_import, print_function

import threading
from builtins import object

from collections.abc import Callable

from p4p.client.thread import Context

from typing import Tuple
from .channel_access_exceptions import WriteAccessException
from .utilities import waveform_to_string

TIMEOUT = 15  # Default timeout for PV set/get
EXIST_TIMEOUT = 3  # Separate smaller timeout for pv_exists() and searchw() operations
CACHE = threading.local()
CACHE_LOCK = threading.local()


class P4PWrapper(object):
    context = None
    subscriptions = {}

    @staticmethod
    def set_pv_value(name: str, value: any, wait: bool, timeout: int = TIMEOUT,
                     safe_not_quick: bool = True) -> None:
        if safe_not_quick:
            P4PWrapper._check_for_disp(name)
        context = P4PWrapper.get_context()
        context.put(name, value, timeout=timeout, wait=wait)

    @staticmethod
    def clear_monitor(name: str, timeout: int) -> None:
        if name in P4PWrapper.subscriptions:
            P4PWrapper.subscriptions.pop(name).close()

    @staticmethod
    def get_pv_value(name: str, to_string: bool = False, timeout: int = TIMEOUT,
                     use_numpy: bool | None = None) -> any:
        context = P4PWrapper.get_context()
        val = context.get(name, timeout=timeout).value
        if to_string:
            val = str(val)
        return val

    @staticmethod
    def get_pv_timestamp(name: str, timeout: int) -> Tuple[int, int]:
        context = P4PWrapper.get_context()
        time = context.get(name, timeout=timeout).timeStamp
        return time.get("secondsPastEpoch"), time.get("nanoseconds")

    @staticmethod
    def pv_exists(name: str, timeout: int) -> bool:
        try:
            P4PWrapper.get_pv_value(name, timeout=timeout)
            return True
        except TimeoutError:
            return False

    @staticmethod
    def add_monitor(name: str, call_back_function: Callable[[any, any, any], None],
                    link_alarm_on_disconnect: bool,
                    to_string: bool, use_numpy: bool | None) -> Callable[[], None]:

        def _process_call_back(response: Callable[[any, any, any], None]) -> None:
            value = response.value

            if to_string:
                # Could see if the element count is > 1 instead
                if isinstance(value, list):
                    value = waveform_to_string(value)
                else:
                    value = str(value)

            call_back_function(
                value,
                value.get("alarm").get("severity"),
                value.get("alarm").get("status"),
            )

        context = P4PWrapper.get_context()
        subscription = context.monitor(name, _process_call_back,
                                       notify_disconnect=link_alarm_on_disconnect)

        # Add to a dict of subscriptions to reproduce ability to close a monitor by its name.
        P4PWrapper.subscriptions.update(name, subscription)
        return subscription

    @staticmethod
    def get_context(autowrap: bool = False) -> Context:
        if P4PWrapper.context is None:
            P4PWrapper.context = Context("pva", nt=autowrap)
        return P4PWrapper.context

    @staticmethod
    def _check_for_disp(name: str) -> None:
        """
        Check if DISP is set on a PV. If passed a field instead of a PV, do nothing.
        Only check DISP if it exists.
        """
        if (
                ".DISP" not in name
        ):  # Do not check for DISP if it's already in the name of the PV to check
            if "." in name:  # If given a field on a PV, check the PV itself if DISP is set
                name = name.split(".")[0]
            _disp_name = "{}.DISP".format(name)
            if (
                    P4PWrapper.pv_exists(_disp_name, 0)
                    and P4PWrapper.get_pv_value(_disp_name) != "0"
            ):
                raise WriteAccessException("{} (DISP is set)".format(name))

    @staticmethod
    def close_context() -> None:
        if P4PWrapper.context is not None:
            P4PWrapper.context.close()

