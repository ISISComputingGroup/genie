from __future__ import absolute_import
from __future__ import print_function
from astroid import MANAGER
from pylint.lint import Run
from pylint.reporters.text import TextReporter
import os
import re

INIT_HOOK = "init-hook"

class WriteableObject(object):

    """
    our writeable object that pylint will write to
    """
    def __init__(self):

        self.content  = []
        self.warnings = []
        self.errors   = []

    def write(self, st):
        self.content.append(st)

    def read(self):
        return self.content

    def readWarnings(self):
        warnings = [warning for warning in self.content if warning[0] == "W"]
        return warnings

    def readErrors(self):
        errors = [errors for errors in self.content if errors[0] == "E"]
        return errors


class ScriptChecker(object):
    def append_hook_to_config_file(self, file_name, instrument_name):
        with open(file_name, "r") as f:
            contents = f.read()

        file_path = os.path.join("C:\\", "Instrument", "Settings", "config", instrument_name, "Python")
        if INIT_HOOK not in contents:
            contents += "\ninit-hook= import sys; sys.path.append({})".format(file_path)
            with open(file_name, "w") as f: f.write(contents)
        else:
            contents = contents.splitlines(True)
            with open(file_name, "w") as f:
                for content in contents:
                    if INIT_HOOK in content:
                        f.write("init-hook= import sys; sys.path.append({})".format(file_path))
                    else:
                        f.write(content)


    def _find_regex(self, variable):
        """
        Sets the function to find any of the symbols listed below
        Args:
            variable: the assigned string from the search function
        Return:
            the string to be used in the regex search function
        """
        assignment_regex = "[\|\&\^\/\+\-\*\%]?=[^=]"
        regex = r'\b{0}[.][\w\s]*' + assignment_regex + r'|\b{0}[\s]*' + assignment_regex
        return regex.format(variable)


    def _check_g_inst_name(self, line, line_no):
        """
        Checks a line of a script for assignments of variables named g or inst
        Args:
            line: the line to check
            line_no: the line number
        Return:
            list of warnings: contains tuple of 2 lists, 1 which contains an empty list with no warnings,
                              the other containing the list of warnings
        """
        g_error = re.search(self._find_regex('g'), line)
        if g_error:
            return ("W:  " + str(line_no) + ": 'g' assignment in line " + str(line_no))
        inst_error = re.search(self._find_regex('inst'), line)
        if inst_error:
            return ("W:  " + str(line_no) +": 'inst' assignment in line " + str(line_no))

        return ("")


    def check_script_lines(self, lines):
        reassignment_warnings = []
        line_no = 0
        for line in lines:
                line_no += 1
                warning = self._check_g_inst_name(line, line_no)
                if len(warning) != 0: reassignment_warnings.append(warning)

        return reassignment_warnings


    """
    Check scripts for common errors
    """
    def check_script(self, name, full_name, warnings_as_error=False):
        """
        Check a script for common errors
        Args:
            name: filename of the script
            warnings_as_error: True treat warnings as errors; False otherwise

        Returns: error messages list; empty list if there are no errors
        """
        errors_output = WriteableObject()
        # Pylint internally uses astroid  to hold cache so we need to clear to read the module from disc rather
        # than from cache
        MANAGER.astroid_cache.clear()

        warnings = []
        dir_path = os.path.dirname(os.path.realpath(__file__))
        file_path = os.path.join(dir_path, ".pylintrc")

        with open(name) as f:
            reassignment_warnings = self.check_script_lines(f)
            warnings.extend(reassignment_warnings)

        self.append_hook_to_config_file(file_path, full_name)

        # C = Convention related checks, R = Refactoring Related Checks, W = various warnings, E = Errors, F = fatal 
        # --msg-template={msg_id}:{line:3d},{column}: {obj}: {msg} for more specific message
        Run(["--rcfile={}".format(file_path),"--msg-template={C}:{line:3d}: {msg} ({symbol})", "--score=n", name], reporter = TextReporter(errors_output), exit = False)
        
        warnings += errors_output.readWarnings()
        errors   = errors_output.readErrors()

        if warnings_as_error:
            errors += warnings
        else:
            for warning in warnings:
                print (warning)

        return errors

   



