from __future__ import absolute_import, print_function
from astroid import MANAGER
from pylint.lint import Run
from pylint.reporters.text import TextReporter
import os
from builtins import object
import re
import ast
from six import StringIO


class ScriptChecker(object):
    """
    Check Scripts for common errors
    """
    def _find_regex(self, variable):
        """
        Sets the function to find any of the symbols listed below
        Args:
            variable: the assigned string from the search function
        Return:
            the string to be used in the regex search function
        """
        assignment_regex = "[\|\&\^\/\+\-\*\%]?=[^=]"
        regex = r'\b{0}[.][\w\s]*' + assignment_regex + r'|\b{0}[\s]*' + assignment_regex
        return regex.format(variable)

    def _check_g_inst_name(self, line, line_no):
        """
        Checks a line of a script for assignments of variables named g or inst
        Args:
            line: the line to check
            line_no: the line number
        Return:
            If an error is found appropriate warning string else
            if no error found an empty string
        """
        g_error = re.search(self._find_regex('g'), line)
        if g_error:
            return "W:  {line_no}: 'g' assignment in line {line_no}".format(line_no=line_no)

        inst_error = re.search(self._find_regex('inst'), line)
        if inst_error:
            return "W:  {line_no}: 'inst' assignment in line {line_no}".format(line_no=line_no)

        return ""

    def check_script_lines(self, lines):
        """
        Check the lines of the script for possible errors
        Args:
            lines: iterable of lines to check
        Returns: error in the script; empty list if none
        """
        reassignment_warnings = []
        line_no = 0
        for line in lines:
            line_no += 1
            warning = self._check_g_inst_name(line, line_no)
            if len(warning) != 0:
                reassignment_warnings.append(warning)

        return reassignment_warnings

    def check_script(self, script_name, instrument_name, warnings_as_error=False):
        """
        Check a script for common errors.
        Args:
            script_name: filename of the script
            instrument_name: Full instrument name
            warnings_as_error: True treat warnings as errors; False otherwise

        Returns: error messages list; empty list if there are no errors
        """
        errors_output = StringIO()
        # Pylint internally uses astroid  to hold cache so we need to clear to read the module from disc rather
        # than from cache
        MANAGER.astroid_cache.clear()

        warnings = []

        dir_path = os.path.dirname(os.path.realpath(__file__))
        pylint_path = os.path.join(dir_path, ".pylintrc")

        with open(script_name) as f:
            reassignment_warnings = self.check_script_lines(f)
            warnings.extend(reassignment_warnings)

        inst_file_path = os.path.join("C:\\", "Instrument", "Settings", "config", instrument_name, "Python")
        init_hook = "import sys; sys.path.append(\"{}\")".format(inst_file_path)
        inst_scripts_file_path = os.path.join(inst_file_path, "inst")

        functions = self.get_inst_attributes(inst_scripts_file_path)

        # C = Convention related checks, R = Refactoring Related Checks, W = various warnings, E = Errors, F = fatal 
        # --msg-template={msg_id}:{line:3d},{column}: {obj}: {msg} for more specific message
        Run(["--rcfile={}".format(pylint_path), "--init-hook={}".format(init_hook),
            "--msg-template={C}:{line:3d}: {msg} ({symbol})", "--generated-members={}".format(functions),
             "--score=n", script_name], reporter=TextReporter(errors_output), exit=False)

        new_warnings, errors = self.split_warning_errors(errors_output)
        warnings += new_warnings

        if warnings_as_error:
            errors += warnings
        else:
            for warning in warnings:
                print(warning)
        return errors

    def split_warning_errors(self, errors_outputs):
        """
        takes in errors and warning lists and split in two separate list i.e.
        (errors and warnings)
        :param errors_outputs: list of errors and warnings
        :return: two separate lists for errors and warnings
        """
        warnings = []
        errors = []
        errors_outputs = errors_outputs.getvalue().split('\n')
        verbose_warning = ["Redefining name 'g' from outer scope", "Redefining name 'inst' from outer scope"]
        verbose_warning = [error for error in errors_outputs if any(warning in error for warning in verbose_warning)]

        for message in errors_outputs:
            if message.startswith("W") and (message not in verbose_warning):
                warnings.append(message)
            elif message.startswith("E"):
                errors.append(message)

        return warnings, errors

    def get_inst_attributes(self, instrument_scripts_paths):
        """
        gets attributes such as Global variables, Functions, Classes defined
        in instrument scripts
        :param instrument_scripts_paths: path to instrument scripts
        :return: string representation of attributes present in
        instrument scripts with comma separated
        """
        attributes = ""
        for filename in os.listdir(instrument_scripts_paths):
            if filename.endswith(".py") and not filename.startswith("__"):
                with open(os.path.join(instrument_scripts_paths, filename)) as f:
                    src = f.read()
                    tree = ast.parse(src, filename)
                attributes += self.get_all_attributes(tree)
        attributes = attributes[:-1]
        return attributes

    def get_all_attributes(self, tree):
        """
        gets all the attributes of instrument scripts
        :param tree: abstract syntax tree representation of instrument script
        :return: string of all the useful attributes
        """
        attributes = self.get_names_of_functions_classes_global_variables(tree.body)
        return attributes

    def get_names_of_functions_classes_global_variables(self, body):
        """
        gets the name of function, class and global variable names
        :param body: body to iterate through
        :return: string of function names, class, global variables (comma separated)
        """
        attributes = ""
        for item in body:
            # getting functions in global scope
            if isinstance(item, ast.FunctionDef) and not item.name.startswith('_'):
                attributes += "inst.{function_name},".format(function_name=item.name)
            # getting class and its attributes
            elif isinstance(item, ast.ClassDef):
                class_name = "inst.{class_name}".format(class_name=item.name)
                attributes += "{class_name},".format(class_name=class_name)
                attributes += self.get_class_member_names(item.body, class_name)
            elif isinstance(item, ast.Assign):
                attributes += "inst.{},".format(item.targets[0].id)
        return attributes

    def get_class_member_names(self, body, class_name):
        """
        gets the name of all the class members
        :param body: body to iterate through
        :param class_name: name of class to prepend
        :return: string of class member names (comma separated)
        """
        attributes = ""
        for function_body in body:
            if isinstance(function_body, ast.FunctionDef) and "__" not in function_body.name:
                attributes += "{class_name}.{function_name},". \
                    format(class_name=class_name, function_name=function_body.name)
            else:
                # variables defined inside __init__
                for variables in function_body.body:
                    if isinstance(variables, ast.Assign):
                        attributes += "{class_name}.{variable_name},". \
                            format(class_name=class_name, variable_name=variables.targets[0].attr)
        return attributes
