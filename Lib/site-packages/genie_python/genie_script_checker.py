from __future__ import absolute_import, print_function
from astroid import MANAGER
from pylint.lint import Run
from pylint.reporters.text import TextReporter
import os
import sys
import re
import ast
from six import StringIO
from builtins import object
from io import open


class ScriptChecker(object):
    """
    Check Scripts for common errors
    """
    def _find_regex(self, variable):
        """
        Sets the function to find any of the symbols listed below
        Args:
            variable: the assigned string from the search function
        Return:
            the string to be used in the regex search function
        """
        assignment_regex = "[\|\&\^\/\+\-\*\%]?=[^=]"
        regex = r'\b{0}[.][\w\s]*' + assignment_regex + r'|\b{0}[\s]*' + assignment_regex
        return regex.format(variable)

    def _check_g_inst_name(self, line, line_no):
        """
        Checks a line of a script for assignments of variables named g or inst
        Args:
            line: the line to check
            line_no: the line number
        Return:
            If an error is found appropriate warning string else
            if no error found an empty string
        """
        g_error = re.search(self._find_regex('g'), line)
        if g_error:
            return "W:  {line_no}: 'g' assignment in line {line_no}".format(line_no=line_no)

        inst_error = re.search(self._find_regex('inst'), line)
        if inst_error:
            return "W:  {line_no}: 'inst' assignment in line {line_no}".format(line_no=line_no)

        return ""

    def check_script_lines(self, lines):
        """
        Check the lines of the script for possible errors
        Args:
            lines: iterable of lines to check
        Returns: error in the script; empty list if none
        """
        reassignment_warnings = []
        line_no = 0
        for line in lines:
            line_no += 1
            warning = self._check_g_inst_name(line, line_no)
            if len(warning) != 0:
                reassignment_warnings.append(warning)

        return reassignment_warnings

    def check_script(self, script_name, instrument_name, warnings_as_error=False):
        """
        Check a script for common errors.
        Args:
            script_name: filename of the script
            instrument_name: Full instrument name
            warnings_as_error: True treat warnings as errors; False otherwise

        Returns: error messages list; empty list if there are no errors
        """
        errors_output = StringIO()

        # Pylint internally uses astroid  to hold cache so we need to clear to read the module from disc rather
        # than from cache.
        # Not saving builtins and reassigning it before clearing cache may lead to KeyError problem
        # when executing Run function from pylint. One of the examples is present in the following unit test case
        # test_GIVEN_g_assignment_with_2_symbols_before_number_WHEN_check_THEN_warning_message. 

        try:
            cached_builtins = MANAGER.astroid_cache["builtins"]
        except KeyError:
            cached_builtins = None

        MANAGER.astroid_cache.clear()

        # assign builtin value back to cache manager
        if cached_builtins is not None:
            MANAGER.astroid_cache["builtins"] = cached_builtins

        warnings = []

        dir_path = os.path.dirname(os.path.realpath(__file__))
        pylint_path = os.path.join(dir_path, ".pylintrc")

        with open(script_name) as f:
            reassignment_warnings = self.check_script_lines(f)
            warnings.extend(reassignment_warnings)

        inst_file_path = os.path.join("C:\\", "Instrument", "Settings", "config",instrument_name, "Python")
        init_hook = "import sys; sys.path.append(\"{}\")".format(inst_file_path)
        init_hook = init_hook.replace("\\", "\\\\")
        inst_scripts_file_path = os.path.join(inst_file_path, "inst")

        functions = self.get_inst_attributes(inst_scripts_file_path)

        if sys.version_info[0] < 3:
            # Python 2
            # C = Convention related checks, R = Refactoring Related Checks, W = various warnings, E = Errors, F = fatal
            # --msg-template={msg_id}:{line:3d},{column}: {obj}: {msg} for more specific message
            Run(["--rcfile={}".format(pylint_path), "--init-hook={}".format(init_hook),
                "--msg-template={C}:{line:3d}: {msg} ({symbol})", "--generated-members={}".format(functions),
                 "--score=n", script_name], reporter=TextReporter(errors_output), exit=False)
        else:
            #python 3
            Run(["--rcfile={}".format(pylint_path), "--init-hook={}".format(init_hook),
             "--msg-template={C}:{line:3d}: {msg} ({symbol})", "--generated-members={}".format(functions),
             "--score=n", script_name], reporter=TextReporter(errors_output), do_exit=False)
        new_warnings, errors = self.split_warning_errors(errors_output)
        warnings += new_warnings

        if warnings_as_error:
            errors += warnings
        else:
            for warning in warnings:
                print(warning)
        return errors

    def split_warning_errors(self, errors_outputs):
        """
        takes in errors and warning lists and split in two separate list i.e.
        (errors and warnings)
        :param errors_outputs: list of errors and warnings
        :return: two separate lists for errors and warnings
        """
        warnings = []
        errors = []
        errors_outputs = errors_outputs.getvalue().split('\n')
        verbose_warning = ["Redefining name 'g' from outer scope", "Redefining name 'inst' from outer scope"]
        verbose_warning = [error for error in errors_outputs if any(warning in error for warning in verbose_warning)]

        for message in errors_outputs:
            if message.startswith("W") and (message not in verbose_warning):
                warnings.append(message)
            elif message.startswith("E"):
                errors.append(message)

        return warnings, errors

    def get_inst_attributes(self, instrument_scripts_paths):
        """
        gets attributes such as Global variables, Functions, Classes defined
        in instrument scripts
        :param instrument_scripts_paths: path to instrument scripts
        :return: string representation of attributes present in
        instrument scripts with comma separated
        """
        try:
            attributes = ""
            for filename in os.listdir(instrument_scripts_paths):
                if filename.endswith(".py") and not filename.startswith("__"):
                    with open(os.path.join(instrument_scripts_paths, filename)) as f:
                        src = f.read()
                        tree = ast.parse(src, filename)
                    attributes += self.get_all_attributes(tree)
            attributes = attributes[:-1]
            return attributes
        except OSError:
            return ""

    def get_all_attributes(self, tree):
        """
        gets all the attributes of instrument scripts
        :param tree: abstract syntax tree representation of instrument script
        :return: string of all the useful attributes
        """
        attributes = self.get_names_of_functions_classes_global_variables(tree.body)
        return attributes

    def get_names_of_functions_classes_global_variables(self, body):
        """
        gets the name of function, class and global variable names
        :param body: body to iterate through
        :return: string of function names, class, global variables (comma separated)
        """
        attributes = ""
        for item in body:
            # getting functions in global scope
            if isinstance(item, ast.FunctionDef) and not item.name.startswith('_'):
                attributes += "inst.{function_name},".format(function_name=item.name)
            # getting class and its attributes
            elif isinstance(item, ast.ClassDef):
                class_name = "inst.{class_name}".format(class_name=item.name)
                attributes += "{class_name},".format(class_name=class_name)
                attributes += self.get_class_member_names(item.body, class_name)
            elif isinstance(item, ast.Assign):
                target = item.targets[0]
                if isinstance(target, ast.Name):
                    attributes += "inst.{},".format(target.id)
                elif isinstance(target, ast.List) or isinstance(target, ast.Tuple):
                    for name in target.elts:
                        attributes += "inst.{},".format(name.id)
                elif isinstance(target, ast.Attribute):
                    attributes += "inst.{}.{},".format(target.value.id, target.attr)

        return attributes

    def get_class_member_names(self, body, class_name):
        """
        gets the name of all the class members
        :param body: body to iterate through
        :param class_name: name of class to prepend
        :return: string of class member names (comma separated)
        """
        attributes = ""
        for function_body in body:
            if isinstance(function_body, ast.FunctionDef):
                if "__" not in function_body.name:
                    attributes += "{class_name}.{function_name},". \
                        format(class_name=class_name, function_name=function_body.name)
                else:
                    # variables defined inside __init__
                    for variables in function_body.body:
                        if isinstance(variables, ast.Assign):
                            attributes += "{class_name}.{variable_name},". \
                                format(class_name=class_name, variable_name=variables.targets[0].attr)
        return attributes
