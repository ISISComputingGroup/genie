from __future__ import absolute_import, print_function
from builtins import str
import os
import re
import six
import sys

from collections import OrderedDict
from time import strftime, localtime
from io import open

from genie_python.block_names import BlockNames, BlockNamesManager
from genie_python.channel_access_exceptions import UnableToConnectToPVException
from genie_python.genie_blockserver import BlockServer
from genie_python.genie_cachannel_wrapper import CaChannelWrapper as Wrapper
from genie_python.genie_dae import Dae
from genie_python.genie_database_access import DatabaseAccess
from genie_python.genie_wait_for_move import WaitForMoveController
from genie_python.genie_waitfor import WaitForController
from genie_python.utilities import crc8, EnvironmentDetails, remove_field_from_pv
from genie_python.genie_pre_post_cmd_manager import PrePostCmdManager

try:
    import smslib.sms
except ImportError:
    from mock import MagicMock
    smslib = MagicMock()
    warning_message = "Sending alerts not supported in this version of genie_python, please contact ISIS Experiment Controls"
    smslib.sms.send_alert = MagicMock(side_effect=RuntimeError(warning_message))
    smslib.sms.send_email = MagicMock(side_effect=RuntimeError(warning_message))
    smslib.sms.send_sms = MagicMock(side_effect=RuntimeError(warning_message))

from six.moves import range
from six.moves import zip
from builtins import object

RC_ENABLE = ":RC:ENABLE"
RC_LOW = ":RC:LOW"
RC_HIGH = ":RC:HIGH"


# Block names and its manager which automatically gets populated with the names of the current blocks
BLOCK_NAMES = BlockNames()
BLOCK_NAMES_MANAGER = BlockNamesManager(BLOCK_NAMES)


class API(object):
    waitfor = None  # type: WaitForController
    wait_for_move = None
    dae = None  # type: Dae
    blockserver = None  # type: BlockServer
    database_access = None # type: DatabaseAccess
    sms = smslib.sms
    __inst_prefix = ""
    __instrument_name = ""
    __machine_name = ""
    __localmod = None
    __log_dir = "C:\\Instrument\\Var\\logs\\genie_python\\"
    __block_prefix = "CS:SB:"
    __motion_suffix = "CS:MOT:MOVING"
    pre_post_cmd_manager = PrePostCmdManager()

    def __init__(self, pv_prefix, globs, environment_details=None):
        """
        Constructor for the EPICS enabled API.

        Args:
            pv_prefix: used for prefixing the PV and block names
            globs: globals
            environment_details: details of the computer environment
        """
        if environment_details is None:
            self._environment_details = EnvironmentDetails()
        else:
            self._environment_details = environment_details

        Wrapper.errorLogFunc = self.log_ca_msg

        # disable CA error messages to console from disconnected PVs
        import ctypes
        try:
            hcom = ctypes.cdll.LoadLibrary("COM.DLL")
            hcom.eltc(ctypes.c_int(0))
        except Exception as e:
            print("Unable to disable CA errors: ", e)

    def get_instrument(self):
        """
        Gets the name of the local instrument (e.g. NDW1234, DEMO, EMMA-A)

        Returns:
            the name of the local instrument
        """
        return self.__instrument_name

    def get_instrument_py_name(self):
        """
        Gets the name of the local instrument in lowercase and with "-" replaced with "_"

        Returns:
            the name of the local instrument in a python-friendly format
        """
        return self.__instrument_name.lower().replace("-", "_")

    def _get_machine_details_from_identifier(self, machine_identifier):
        instrument_pv_prefix = "IN:"
        test_machine_pv_prefix = "TE:"

        instrument_machine_prefixes = ["NDX", "NDE"]
        test_machine_prefixes = ["NDH"]

        if machine_identifier is None:
            machine_identifier = self._environment_details.get_host_name()

        # machine_identifier needs to be uppercase for both 'NDXALF' and 'ndxalf' to be valid
        machine_identifier = machine_identifier.upper()

        instrument = machine_identifier.upper()
        for p in [instrument_pv_prefix, test_machine_pv_prefix] + instrument_machine_prefixes + test_machine_prefixes:
            if machine_identifier.startswith(p):
                instrument = machine_identifier.upper()[len(p):].rstrip(":")
                break

        if machine_identifier.startswith(instrument_pv_prefix):
            machine = "NDX{0}".format(instrument)
        elif machine_identifier.startswith(test_machine_pv_prefix):
            machine = instrument
        else:
            machine = machine_identifier.upper()

        is_instrument = any(machine_identifier.startswith(p)
                            for p in instrument_machine_prefixes + [instrument_pv_prefix])
        pv_prefix = self._get_pv_prefix(instrument, is_instrument)

        return instrument, machine, pv_prefix

    def get_instrument_full_name(self):
        return self.__machine_name

    def set_instrument(self, machine_identifier, globs, import_instrument_init=True):
        """
        Set the instrument being used by setting the PV prefix or by the hostname if no prefix was passed.

        Will do some checking to allow you to pass instrument names in so.

        Args:
            machine_identifier: should be the pv prefix but also accepts instrument name; if none defaults to computer
            host name
            globs: globals
            import_instrument_init (bool): if True import the instrument init from the config area; otherwise don't
        """
        instrument, machine, pv_prefix = self._get_machine_details_from_identifier(machine_identifier)

        print("PV prefix is " + pv_prefix)
        API.__inst_prefix = pv_prefix
        API.__instrument_name = instrument
        API.__machine_name = machine
        API.dae = Dae(self, pv_prefix)
        API.database_access = DatabaseAccess(instrument)
        API.wait_for_move = WaitForMoveController(self, pv_prefix + API.__motion_suffix)
        API.waitfor = WaitForController(self)
        API.blockserver = BlockServer(self)
        BLOCK_NAMES_MANAGER.update_prefix(pv_prefix)

        # Whatever machine we're on, try to initialize and fall back if unsuccessful
        self.init_instrument(instrument, machine, globs, import_instrument_init)

    def _get_pv_prefix(self, instrument, is_instrument):
        """
        Create the pv prefix based on instrument name and whether it is an instrument or a dev machine

        Args:
            instrument: instrument name
            is_instrument: True is an instrument; False not an instrument

        Returns:
            string: the PV prefix
        """
        clean_instrument = instrument
        if clean_instrument.endswith(":"):
            clean_instrument = clean_instrument[:-1]
        if len(clean_instrument) > 8:
            clean_instrument = clean_instrument[0:6] + crc8(clean_instrument)

        self.__instrument_name = clean_instrument

        if is_instrument:
            pv_prefix_prefix = "IN"
            print("THIS IS %s!" % self.__instrument_name.upper())
        else:
            pv_prefix_prefix = "TE"
            print("THIS IS %s! (test machine)" % self.__instrument_name.upper())
        return "{prefix}:{instrument}:".format(prefix=pv_prefix_prefix, instrument=self.__instrument_name)

    def prefix_pv_name(self, name):
        """
        Adds the instrument prefix to the specified PV.
        """
        if API.__inst_prefix is not None:
            return API.__inst_prefix + name
        return name

    def init_instrument(self, instrument, machine_name, globs, import_instrument_init):
        """
        Initialise an instrument using the default init file followed by the machine specific init.
        Args:
            instrument: instrument name to load from
            machine_name: machine name
            globs: current globals
            import_instrument_init: if True import the instrument init from the config area; otherwise don't
        """
        if import_instrument_init:
            instrument = instrument.lower().replace("-", "_")
            python_config_area = os.path.join("C:\\", "Instrument", "Settings", "config", machine_name, "Python")
            print("Loading instrument scripts from: {}".format(os.path.join(python_config_area, "inst")))

            # Check instrument specific folder exists, if so add to sys path
            if os.path.isdir(python_config_area):
                sys.path.append(python_config_area)

            if six.PY2:
                # Load the instrument init file
                API.__localmod = __import__('init_' + instrument, globals(), locals(), ['init_' + instrument], -1)
            else:

                import importlib

                # Load the instrument init file
                API.__localmod = importlib.import_module('init_{}'.format(instrument))

            if API.__localmod.__file__.endswith('.pyc'):
                file_loc = API.__localmod.__file__[:-1]
            else:
                file_loc = API.__localmod.__file__
            # execfile - this puts any imports in the init file into the globals namespace
            # Note: Anything loose in the module like print statements will be run twice
            exec(compile(open(file_loc).read(), file_loc, 'exec'), globs)
            # Call the init command
            init_func = getattr(API.__localmod, "init")
            init_func(machine_name)

    def set_pv_value(self, name, value, wait=False, attempts=3, is_local=False):
        """
        Set the PV to a value.

        When setting a PV value this call should be used unless there is a special requirement.

        Args:
            name: the PV name
            value: the value to set
            wait: wait for the value to be set before returning
            is_local (bool, optional): whether to automatically prepend the local inst prefix to the PV name
            attempts: number of attempts to try to set the pv value
        """
        if is_local:
            if not name.startswith(API.__inst_prefix):
                name = self.prefix_pv_name(name)
        self.log_info_msg("set_pv_value %s %s" % (name, str(value)))

        while True:
            try:
                Wrapper.set_pv_value(name, value, wait=wait)
                return
            except Exception as e:
                attempts -= 1
                if attempts < 1:
                    self.log_info_msg("set_pv_value exception {!r}".format(e))
                    raise e

    def get_pv_value(self, name, to_string=False, attempts=3, is_local=False, use_numpy=None):
        """
        Get the current value of the PV.

        When getting a PV value this call should be used unless there is a special requirement.

        Args:
            name: the PV name
            to_string (bool, optional): whether to cast it to a string
            attempts (int, optional): the number of times it tries to read the pv before throwing an exception if it
            can not
            is_local (bool, optional): whether to automatically prepend the local inst prefix to the PV name
            use_numpy (None|boolean): True use numpy to return arrays, False return a list; None for use the default
        """
        if is_local:
            if not name.startswith(API.__inst_prefix):
                name = self.prefix_pv_name(name)

        if not self.pv_exists(name):
            raise UnableToConnectToPVException(name, 'does not exist')

        while True:
            try:
                return Wrapper.get_pv_value(name, to_string, use_numpy=use_numpy)
            except Exception as e:
                attempts -= 1
                if attempts < 1:
                    raise e

    def pv_exists(self, name, fail_fast=False):
        """
        See if the PV exists.

        Args:
            name (string): the name of the block
            fail_fast (bool): if True the function will not attempt to wait for a disconnected PV

        Returns:
            bool: True if the block exists
        """
        if fail_fast:
            return Wrapper.pv_exists(name, 0)
        else:
            return Wrapper.pv_exists(name)

    def reload_current_config(self):
        """
        Reload the current configuration.
        """
        API.blockserver.reload_current_config()

    def correct_blockname(self, name, add_prefix=True):
        """
        Corrects the casing of the block.
        """
        for true_block_name in self.get_block_names():
            if name.lower() == true_block_name.lower():
                if add_prefix:
                    return self.__inst_prefix + API.__block_prefix + true_block_name
                else:
                    return true_block_name
        # If we get here then the block does not exist
        # but this should be picked up elsewhere
        return name

    def get_block_names(self):
        """
        Gets a list of block names from the block name monitor.

        Note: does not include the prefix
        """
        return [name for name in BLOCK_NAMES.__dict__.keys()]

    def block_exists(self, name, fail_fast=False):
        """
        Checks whether the block exists.

        Args:
            name (string): the name of the block
            fail_fast (bool): if True the function will not attempt to wait for a disconnected PV

        Note: this is case insensitive
        """
        return self.pv_exists(self.get_pv_from_block(name), fail_fast)

    def set_block_value(self, name, value=None, runcontrol=None, lowlimit=None, highlimit=None, wait=False):
        """
        Sets a range of block values.
        """
        # Run pre-command
        if wait is not None and runcontrol is not None:
            # Cannot set both at the same time
            raise Exception("Cannot enable or disable runcontrol at the same time as setting a wait")

        if not self.pre_post_cmd_manager.cset_precmd(runcontrol=runcontrol, wait=wait):
            print('cset cancelled by pre-command')
            return

        full_name = self.get_pv_from_block(name)

        if lowlimit is not None and highlimit is not None:
            if lowlimit > highlimit:
                print("Low limit ({}) higher than high limit ({}), swapping them around for you".format(lowlimit, highlimit))
                lowlimit, highlimit = highlimit, lowlimit
            if wait and not lowlimit < value < highlimit:
                # Can only warn as may move through this range whilst changing
                print("Warning the range {} to {} does not cover setpoint of {}, may wait forever".format(lowlimit, highlimit, value))

        if value is not None:
            # Write to SP if it exists
            if self.pv_exists(full_name + ":SP"):
                self.set_pv_value(full_name + ":SP", value)
            else:
                self.set_pv_value(full_name, value)

        if wait:
            self.waitfor.start_waiting(name, value, lowlimit, highlimit)
            return

        if runcontrol is not None:
            enable = 1 if runcontrol else 0
            self.set_pv_value(full_name + RC_ENABLE, enable)

        # Set limits
        if lowlimit is not None:
            self.set_pv_value(full_name + RC_LOW, lowlimit)
        if highlimit is not None:
            self.set_pv_value(full_name + RC_HIGH, highlimit)

    def get_block_value(self, name, to_string=False, attempts=3):
        """
        Gets the current value for the block.
        """
        return self.get_pv_value(self.get_pv_from_block(name), to_string, attempts)

    def set_multiple_blocks(self, names, values):
        """
        Sets values for multiple blocks.
        """
        # With LabVIEW we could set values then press go after all values are set
        # Not sure we are going to do something similar for EPICS
        temp = list(zip(names, values))
        # Set the values
        for name, value in temp:
            self.set_block_value(name, value)

    def get_block_units(self, block_name):
        """
        Get the physical measurement units associated with a block name.

        Parameters
        ----------
        block_name: name of the block

        Returns
        -------
        units of the block
        """
        pv_name = self.get_pv_from_block(block_name)
        if "." in pv_name:
            # Remove any headers
            pv_name = pv_name.split(".")[0]
        unit_name = pv_name + ".EGU"
        # pylint: disable=protected-access
        if not self.block_exists(block_name) and \
                block_name.upper() not in (existing_block.upper() for existing_block in self.get_block_names()):
            # If block doesn't exist, not found even in some form on the block server
            raise Exception("No block with the name '{}' exists\nCurrent blocks are {}"
                            .format(block_name, self.get_block_names()))

        return Wrapper.get_pv_value(unit_name)

    def log_info_msg(self, message):
        self.write_to_log(message, 'CMD')

    def log_command(self, function_name, arguments):
        self.write_to_log("%s %s" % (function_name, arguments), 'CMD')

    def log_error_msg(self, error_msg):
        """Log the error to the log file"""
        self.write_to_log("ERROR: " + error_msg, 'CMD')

    def log_ca_msg(self, error_msg):
        """Log the CA error (from CaChannel) to the log file"""
        self.write_to_log("ERROR: " + error_msg, 'CA')

    def write_to_log(self, message, source):
        """
        Writes a message to the default log file.

        Can be used for error logging and logging commands sent.

        Args:
            message: the message to log
            source: the source of the message
        """
        try:
            curr_time = localtime()
            if not os.path.exists(API.__log_dir):
                os.makedirs(API.__log_dir)
            f_name = API.__log_dir + 'genie-' + strftime("%Y-%m-%d-%a", curr_time) + '.log'
            t_stamp = strftime("%Y-%m-%dT%H:%M:%S", curr_time)
            f = open(f_name, 'a')
            message = "%s\t(%s)\t(%s)\t%s\n" % (t_stamp, source, os.getpid(), message)
            f.write(message)
            f.close()
        except Exception:
            pass

    def _get_pars(self, pv_prefix_identifier, get_names_from_blockserver):
        """
        Get the current parameter values for a given pv subset as a dictionary.
        """
        names = get_names_from_blockserver()
        ans = {}
        if names is not None:
            for n in names:
                val = self.get_pv_value(self.prefix_pv_name(n))
                m = re.match(".+:" + pv_prefix_identifier + ":(.+)", n)
                if m is not None:
                    ans[m.groups()[0]] = val
                else:
                    self.log_error_msg("Unexpected PV found whilst retrieving parameters: {0}".format(n))
        return ans

    def get_sample_pars(self):
        """
        Get the current sample parameter values as a dictionary.
        """
        return self._get_pars("SAMPLE", API.blockserver.get_sample_par_names)

    def set_sample_par(self, name, value):
        """
        Set a new value for a sample parameter.

        Args:
            name: the name of the parameter to change
            value: the new value
        """
        names = API.blockserver.get_sample_par_names()
        if names is not None:
            for n in names:
                m = re.match(".+:SAMPLE:%s" % name.upper(), n)
                if m is not None:
                    # Found it!
                    self.set_pv_value(self.prefix_pv_name(n), value)
                    return
        raise Exception("Sample parameter %s does not exist" % name)

    def get_beamline_pars(self):
        """
        Get the current beamline parameter values as a dictionary.
        """
        return self._get_pars("BL", API.blockserver.get_beamline_par_names)

    def set_beamline_par(self, name, value):
        """
        Set a new value for a beamline parameter.

        Args:
            name: the name of the parameter to change
            value: the new value
        """
        names = API.blockserver.get_beamline_par_names()
        if names is not None:
            for n in names:
                m = re.match(".+:BL:%s" % name.upper(), n)
                if m is not None:
                    self.set_pv_value(self.prefix_pv_name(n), value)
                    return
        raise Exception("Beamline parameter %s does not exist" % name)

    def get_runcontrol_settings(self, block_name):
        """
        Gets the current run-control settings for a block.

        Args:
            block_name: the full pv of the block

        Returns:
            tuple: (enabled, low_limit, high_limit)
        """
        try:
            block_pv = self.get_pv_from_block(block_name)
            enabled = self.get_pv_value(block_pv + RC_ENABLE) == "YES"
            low_limit = self.get_pv_value(block_pv + RC_LOW)
            high_limit = self.get_pv_value(block_pv + RC_HIGH)
            return enabled, low_limit, high_limit
        except UnableToConnectToPVException:
            return "UNKNOWN", "UNKNOWN", "UNKNOWN"

    def check_alarms(self, blocks):
        """
        Checks whether the specified blocks are in alarm.

        Args:
            blocks (list): the blocks to check

        Returns:
            list, list, list: the blocks in minor, major and invalid alarm
        """
        alarm_states = self._get_fields_from_blocks(blocks, "SEVR", "alarm state")
        minor = [t[0] for t in alarm_states if t[1] == "MINOR"]
        major = [t[0] for t in alarm_states if t[1] == "MAJOR"]
        invalid = [t[0] for t in alarm_states if t[1] == "INVALID"]
        return minor, major, invalid

    def check_limit_violations(self, blocks):
        """
        Checks whether the specified blocks have soft limit violations.

        Args:
            blocks (list): the blocks to check

        Returns:
            list: the blocks which have soft limit violations
            """
        violation_states = self._get_fields_from_blocks(blocks, "LVIO", "limit violation")
        return [t[0] for t in violation_states if t[1] == 1]

    def _get_fields_from_blocks(self, blocks, field_name, field_description):
        field_values = list()
        for block in blocks:
            if self.block_exists(block):

                block_name = self.correct_blockname(block, False)
                full_block_pv = self.get_pv_from_block(block)
                try:
                    field_value = self.get_pv_value(full_block_pv + "." + field_name, attempts=1)
                    field_values.append([block_name, field_value])
                except IOError:
                    # Could not get value
                    print("Could not get {} for block: {}".format(field_description, block))
            else:
                print("Block {} does not exist, so ignoring it".format(block))

        return field_values

    def get_pv_from_block(self, block_name):
        """
        Get the full gateway level PV name for a given block.

        Args:
        block_name (str): The name of a block

        Returns:
            pv_name (str): The pv name as a string

        """
        return self.__inst_prefix + API.__block_prefix + block_name.upper()

    def send_sms(self, phone_num, message):
        """
        Sends an SMS message to a phone number.

        Args:
            phone_num (string): The phone number to send the SMS to.
            message (string): The message to send.
        """
        try:
            self.log_info_msg("send_sms returned {}".format(API.sms.send_sms(phone_num, message)))
        except Exception as e:
            raise Exception("Could not send SMS: {}".format(e))

    def send_email(self, address, message):
        """
        Sends an email to a given address.

        Args:
            address (string): The email address to use.
            message (string): The message to send.
        """
        try:
            self.log_info_msg("send_email returned {}".format(API.sms.send_email(address, message)))
        except Exception as e:
            raise Exception("Could not send email: {}".format(e))

    def send_alert(self, message, inst):
        """
        Sends an alert message for a specified instrument.

        Args:
            message (string): The message to send.
            inst (string): The instrument to generate an alert for.
        """
        if inst is None:
            inst = self.__instrument_name
        try:
            self.log_info_msg("send_alert returned {}".format(API.sms.send_alert(inst, message)))
        except Exception as e:
            raise Exception("Could not send alert: {}".format(e))

    def get_alarm_from_block(self, block):
        """
        Gets the alarm status from a single block

        args:
            block (str): the name of the block to get the alarm status of

        returns:
            (str) the alarm status as a string. One of "NO_ALARM", "MINOR", "MAJOR", "INVALID", or "UNKNOWN" if the
            alarm status could not be determined
        """

        return self.get_pv_alarm(self.get_pv_from_block(block))

    def get_pv_alarm(self, pv_name):
        """
        Gets the alarm status of a pv.

        args:
            pv_name (str): the name of the pv to get the alarm status of

        returns:
            (str) the alarm status as a string. One of "NO_ALARM", "MINOR", "MAJOR", "INVALID", or "UNKNOWN" if the
            alarm status could not be determined
        """
        try:
            return self.get_pv_value("{}.SEVR".format(remove_field_from_pv(pv_name)), to_string=True)
        except Exception:
            return "UNKNOWN"

    def get_block_data(self, block, fail_fast=False):
        """
        Gets the useful values associated with a block.

        The value will be None if the block is not "connected".

        Args:
            block (string): the name of the block
            fail_fast (bool): if True the function will not attempt to wait for a disconnected PV

        Returns
            dict: details about about the block. Contains:
                name - name of the block
                value - value of the block
                unit - physical units of the block
                connected - True if connected; False otherwise
                runcontrol - NO not in runcontrol, YES otherwise
                lowlimit - run control low limit set
                highlimit - run control high limit set
                alarm - the alarm status of the block
        """
        ans = OrderedDict()
        ans['connected'] = True

        if not self.block_exists(block, fail_fast):
            # Check if block exists in some form in the block server
            if block.upper() in (existing_block.upper() for existing_block in self.get_block_names()):
                ans['connected'] = False
            else:
                # Can't find block at all
                raise Exception("No block with the name '{}' exists\nCurrent blocks are {}"
                                .format(block, self.get_block_names()))

        ans['name'] = block
        ans['value'] = self.get_block_value(block) if ans['connected'] else None

        try:
            ans['unit'] = self.get_block_units(block) if ans['connected'] else None
        except UnableToConnectToPVException:
            ans['unit'] = "Unable to connect to .EGU PV"

        ans['runcontrol'], ans['lowlimit'], ans['highlimit'] = self.get_runcontrol_settings(block)

        fail_fast_and_disconnected = fail_fast and not ans['connected']
        ans['alarm'] = "UNKNOWN" if fail_fast_and_disconnected else self.get_alarm_from_block(block)

        return ans
