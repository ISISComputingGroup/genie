import ctypes
import os
import glob

# Windows specific stuff
import sys
import traceback

from utilities import get_correct_directory_path_existing

if os.name == 'nt':
    # Needed for correcting file paths
    import win32api


# Determine whether to start in simulation mode
if 'GENIE_SIMULATE' in os.environ and os.environ['GENIE_SIMULATE'] == '1':
    print("\n=========== RUNNING IN SIMULATION MODE ===========\n")
    from genie_python.genie_simulate import API

else:
    from genie_python.genie_epics_api import API


# INITIALISATION CODE - DO NOT DELETE
try:
    # If __api does not exist or is None then we need to create it.
    if __api is None:
        raise Exception("API does not exist")
except Exception:
    # This should only get called the first time genie is imported
    my_pv_prefix = None
    if 'MYPVPREFIX' in os.environ:
        my_pv_prefix = os.environ['MYPVPREFIX']
        __api = API(my_pv_prefix, globals())
    else:
        print("No instrument specified - loading local instrument")
        __api = API(None, globals())


try:
    SCRIPT_DIR = get_correct_directory_path_existing("C:/scripts/")
except Exception:
    SCRIPT_DIR = ""

_exceptions_raised = False


def handler(sig):
    try:
        import _thread
    except ImportError:
        import thread as _thread
    _thread.interrupt_main()
    return 1


routine = ctypes.WINFUNCTYPE(ctypes.c_int, ctypes.c_uint)(handler)
ctypes.windll.kernel32.SetConsoleCtrlHandler(routine, 1)
# END INITIALISATION CODE

# TAB COMPLETE FOR LOAD_SCRIPT
try:
    import readline

    def complete(text, state):
        """
        Read line completion for load script so it gives nice paths
        Args:
            text: text to auto complete
            state: state it was in

        Returns: completed line

        """
        if text.startswith('load_script("') or text.startswith("load_script('"):
            temp = text[13:]
            ans = (glob.glob(temp + '*') + [None])[state]
            if ans is not None:
                # return / to avoid a quoting issue with \ in paths
                return (text[:13] + ans).replace('\\', '/')
        else:
            return __ipy_complete(text, state)

    __ipy_complete = readline.get_completer()
    readline.set_completer_delims(' \t\n;')
    readline.parse_and_bind("tab: complete")
    readline.set_completer(complete)
except Exception:
    # if we can not do tab completion it doesn't matter
    pass
# END TAB COMPLETE

def usercommand(func):
    """
    Decorator that marks a function as a user command (e.g. for NICOS).
    """
    func.is_usercommand = True
    func.is_hidden = False
    return func


def helparglist(args):
    """
    Decorator that supplies a custom argument list to be displayed by
    a help (e.g. for NICOS).
    """

    def deco(func):
        func.help_arglist = args
        return func

    return deco


if os.name == 'nt':
    class CONSOLE_SCREEN_BUFFER_INFO(ctypes.Structure):
        _fields_ = [
            ('dwSize', ctypes.wintypes._COORD),
            ('dwCursorPosition', ctypes.wintypes._COORD),
            ('wAttributes', ctypes.c_ushort),
            ('srWindow', ctypes.wintypes._SMALL_RECT),
            ('dwMaximumWindowSize', ctypes.wintypes._COORD)
        ]


def _print_error_message(message):
    """
    Print the error message to screen.
    """
    if os.name == 'nt':
        # Is windows
        std_output_handle = -11
        stdout_handle = ctypes.windll.kernel32.GetStdHandle(std_output_handle)
        csbi = CONSOLE_SCREEN_BUFFER_INFO()
        ctypes.windll.kernel32.GetConsoleScreenBufferInfo(stdout_handle, ctypes.byref(csbi))
        old_attrs = csbi.wAttributes
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, 12)
        print("ERROR: " + message)
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, old_attrs)
    else:
        # Non-windows
        print('\033[91m' + "ERROR: " + message + '\033[0m')
    # Log it
    __api.log_error_msg(message)


def _handle_exception(exception=None, message=None):
    """
    Handles any exception in the way we want.
    """
    if exception is not None:
        if message is not None:
            _print_error_message(message)
        else:
            traceback.print_exc(file=sys.stdout)
        if _exceptions_raised:
            raise exception
    elif message is not None:
        _print_error_message(message)
        if _exceptions_raised:
            raise Exception(message)
    else:
        _print_error_message("UNSPECIFIED")
