import ctypes
import os
import re

import sys
import traceback
import glob

# Determine whether to start in simulation mode
import IPython
from IPython.core.completer import IPCompleter
from genie_python.utilities import get_correct_filepath_existing

if 'GENIE_SIMULATE' in os.environ and os.environ['GENIE_SIMULATE'] == '1':
    print("\n=========== RUNNING IN SIMULATION MODE ===========\n")
    from genie_python.genie_simulate import API

else:
    from genie_python.genie_epics_api import API

# Windows specific stuff
if os.name == 'nt':
    # Needed for correcting file paths
    import win32api

# INITIALISATION CODE - DO NOT DELETE
try:
    # If __api does not exist or is None then we need to create it.
    if __api is None:
        raise Exception("API does not exist")
except Exception:
    # This should only get called the first time genie is imported
    my_pv_prefix = None
    if 'MYPVPREFIX' in os.environ:
        my_pv_prefix = os.environ['MYPVPREFIX']
        __api = API(my_pv_prefix, globals())
    else:
        print("No instrument specified - loading local instrument")
        __api = API(None, globals())

_exceptions_raised = False


# END INITIALISATION CODE

try:
    USER_SCRIPT_DIR = get_correct_filepath_existing("C:/scripts/")
except Exception:
    USER_SCRIPT_DIR = ""


# TAB COMPLETE CODE

class LoadScriptCompleter(IPCompleter):
    """
    A custom function which replaces the normal completion function of the ipython completer.
    This allows us to return just paths after load_script and no other completions from the IPython backend, in all
    other cases it returns what the original one did.
    """
    def __init__(self, original_complete_fn):
        self._original_complete = original_complete_fn
        self.is_pydev = False

    def complete(self, text=None, line_buffer=None, cursor_pos=None):
        load_script_command = u'load_script('
        if load_script_command not in line_buffer:
            text, completion = self._original_complete(text, line_buffer, cursor_pos)
        else:
            path = line_buffer.split(load_script_command)[-1]

            if path == "":
                # empty path user has typed load_script(<TAB>
                text = ""
                path = USER_SCRIPT_DIR
                user_script = True
                quote = '"'
            elif path == "'" or path == '"':
                # just a quote empty path user has typed load_script(<TAB>
                text = ""
                quote = ""
                path = USER_SCRIPT_DIR
                user_script = True
            else:
                # full path
                path = path[1:]
                quote = ""
                text = path
                user_script = False
            if text is None:
                text = ""

            paths = glob.glob("{}*".format(path))
            if len(paths) != 0:
                if self.is_pydev:
                    # PyDev expects just the end part of the expression back broken at the last punctuation
                    if user_script:
                        # if we added user scripts in all of that need to be in
                        completion = ['{}{}'.format(quote, ans) for ans in paths]
                    else:
                        completion = []
                        for ans in paths:
                            # find the overlap between the search path and the possible paths back to the last
                            # splitting character, e.g. script/pl overlap is pl return this to be substituted
                            # then add the rest of the path back on. Ensure that both / and \ work
                            len_of_overlap = len(path.replace('\\', '/'))
                            overlap = re.split(r'[/:\\ .-]', ans[0:len_of_overlap])[-1]
                            ans_completion = overlap + ans[len_of_overlap:]
                            completion.append('{}{}'.format(quote, ans_completion))
                else:
                    # Console expects the whole path
                    # return / to avoid a quoting issue with \ in paths
                    completion = [unicode("{}{}".format(quote, ans).replace('\\', '/')) for ans in paths]
            else:
                text, completion = self._original_complete(text, line_buffer, cursor_pos)
            print("   -: {}  =  {}".format(text, completion))
        return text, completion


ipy_completer = IPython.get_ipython().Completer.complete
_load_script_completer = LoadScriptCompleter(ipy_completer)
IPython.get_ipython().Completer.complete = _load_script_completer.complete

try:
    class PyDevComplete():
        def __init__(self, original_function):
            self.original_function = original_function
        def just_path_on_load(self, text, act_tok):
            ans = self.original_function(text, act_tok)
            if "load_script" in text:
                return [an for an in ans if an[3] == '11']
            else:
                return ans

    from _pydev_bundle.pydev_ipython_console_011 import _PyDevFrontEndContainer
    _PyDevFrontEndContainer._instance.getCompletions = PyDevComplete(_PyDevFrontEndContainer._instance.getCompletions).just_path_on_load
    _load_script_completer.is_pydev = True
except ImportError:
    pass

# END TAB COMPLETE

def usercommand(func):
    """
    Decorator that marks a function as a user command (e.g. for NICOS).
    """
    func.is_usercommand = True
    func.is_hidden = False
    return func


def helparglist(args):
    """
    Decorator that supplies a custom argument list to be displayed by
    a help (e.g. for NICOS).
    """

    def deco(func):
        func.help_arglist = args
        return func

    return deco


if os.name == 'nt':
    class CONSOLE_SCREEN_BUFFER_INFO(ctypes.Structure):
        _fields_ = [
            ('dwSize', ctypes.wintypes._COORD),
            ('dwCursorPosition', ctypes.wintypes._COORD),
            ('wAttributes', ctypes.c_ushort),
            ('srWindow', ctypes.wintypes._SMALL_RECT),
            ('dwMaximumWindowSize', ctypes.wintypes._COORD)
        ]


def _print_error_message(message):
    """
    Print the error message to screen.
    """
    if os.name == 'nt':
        # Is windows
        std_output_handle = -11
        stdout_handle = ctypes.windll.kernel32.GetStdHandle(std_output_handle)
        csbi = CONSOLE_SCREEN_BUFFER_INFO()
        ctypes.windll.kernel32.GetConsoleScreenBufferInfo(stdout_handle, ctypes.byref(csbi))
        old_attrs = csbi.wAttributes
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, 12)
        print("ERROR: " + message)
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, old_attrs)
    else:
        # Non-windows
        print('\033[91m' + "ERROR: " + message + '\033[0m')
    # Log it
    __api.log_error_msg(message)


def _handle_exception(exception=None, message=None):
    """
    Handles any exception in the way we want.
    """
    if exception is not None:
        if message is not None:
            _print_error_message(message)
        else:
            traceback.print_exc(file=sys.stdout)
        if _exceptions_raised:
            raise exception
    elif message is not None:
        _print_error_message(message)
        if _exceptions_raised:
            raise Exception(message)
    else:
        _print_error_message("UNSPECIFIED")
