import ctypes
import os
import re

import sys
import traceback
import glob

# Determine whether to start in simulation mode
import IPython
import six
from IPython.core.completer import IPCompleter
from genie_python.utilities import get_correct_filepath_existing

if 'GENIE_SIMULATE' in os.environ and os.environ['GENIE_SIMULATE'] == '1':
    print("\n=========== RUNNING IN SIMULATION MODE ===========\n")
    from genie_python.genie_simulate import API

else:
    from genie_python.genie_epics_api import API

# Windows specific stuff
if os.name == 'nt':
    # Needed for correcting file paths
    import win32api

# INITIALISATION CODE - DO NOT DELETE
try:
    # If __api does not exist or is None then we need to create it.
    if __api is None:
        raise Exception("API does not exist")
except Exception:
    # This should only get called the first time genie is imported
    my_pv_prefix = None
    if 'MYPVPREFIX' in os.environ:
        my_pv_prefix = os.environ['MYPVPREFIX']
        __api = API(my_pv_prefix, globals())
    else:
        print("No instrument specified - loading local instrument")
        __api = API(None, globals())

_exceptions_raised = False


# END INITIALISATION CODE

try:
    USER_SCRIPT_DIR = get_correct_filepath_existing("C:/scripts/")
except Exception:
    USER_SCRIPT_DIR = ""


# TAB COMPLETE CODE

LOAD_SCRIPT_COMMAND = u'load_script('


class LoadScriptCompleter:
    """
    A class holding a custom complete function which replaces the normal completion function of the ipython completer.
    We are replacing it and not just adding it as a custom completer because it allows us to return just paths after
    load_script and no other completions from the IPython backend. If this does not have load script in it will return
    what the original one did.
    """

    def __init__(self, original_complete_fn):
        """
        Initialise.
        Args:
            original_complete_fn: function which was originally used to complete
        """
        self._original_complete = original_complete_fn
        self.is_pydev = False

    def complete(self, text=None, line_buffer=None, cursor_pos=None):
        """
        Find completions for the given text and line context.

        Note that both the text and the line_buffer are optional, but at least
        one of them must be given.

        Parameters
        ----------
          text : string, optional
            Text to perform the completion on.  Line buffer
            is always used except when using the default completer.

          line_buffer : string, optional
            line to match

          cursor_pos : int, optional
            Index of the cursor in the full line buffer.  Should be provided by
            remote frontends where kernel has no access to frontend state.

        Returns
        -------
        text : str
          Text that was actually used in the completion.

        matches : list
          A list of completion matches.
        """

        if LOAD_SCRIPT_COMMAND not in line_buffer:
            match, completion = self._original_complete(text, line_buffer, cursor_pos)
        else:
            match, quote, search_path, user_script = self._get_search_path_and_parameters_from_line_buffer(line_buffer)

            paths = glob.glob("{}*".format(search_path))
            if len(paths) != 0:
                if self.is_pydev:
                    # PyDev expects just the end part of the expression back broken at the last punctuation
                    if user_script:
                        # if we added user scripts in all of that need to be in
                        completion = ['{}{}'.format(quote, ans.replace('\\', '/')) for ans in paths]
                    else:
                        completion = []
                        for ans in paths:
                            # find the overlap between the search path and the possible paths back to the last
                            # splitting character, e.g. script/pl overlap is pl return this to be substituted
                            # then add the rest of the path back on. Ensure that both / and \ work
                            len_of_overlap = len(search_path.replace('\\', '/'))
                            overlap = re.split(r'[/:\\ .-]', ans[0:len_of_overlap])[-1]
                            ans_completion = overlap + ans[len_of_overlap:].replace('\\', '/')
                            completion.append('{}{}'.format(quote, ans_completion))
                else:
                    # Console expects the whole path
                    # return / to avoid a quoting issue with \ in paths
                    completion = [six.u("{}{}".format(quote, ans).replace('\\', '/')) for ans in paths]
            else:
                match, completion = self._original_complete(text, line_buffer, cursor_pos)
        return match, completion

    def _get_search_path_and_parameters_from_line_buffer(self, line_buffer):
        """
        Parse the line and get out the search path needed along with the match whether it is the user script dir and
        whether a quote is needed
        Args:
            line_buffer: line buffer to parse

        Returns:
            match: text to match to
            quote: the initial quote (can be blank)
            search_path: the search path
            user_script: True if this is user script dir
        """
        search_path = line_buffer.split(LOAD_SCRIPT_COMMAND)[-1]
        if search_path is None or search_path == "":
            # empty path user has typed load_script(<TAB>
            match = ""
            search_path = USER_SCRIPT_DIR
            user_script = True
            quote = '"'
        elif search_path == "'" or search_path == '"':
            # just a quote empty path user has typed load_script(<TAB>
            match = ""
            quote = ""
            search_path = USER_SCRIPT_DIR
            user_script = True
        else:
            # full path
            search_path = search_path[1:]
            quote = ""
            match = search_path
            user_script = False
        return match, quote, search_path, user_script


# replace the original completer in ipython with the one above
ipy_completer = IPython.get_ipython().Completer.complete
_load_script_completer = LoadScriptCompleter(ipy_completer)
IPython.get_ipython().Completer.complete = _load_script_completer.complete

try:
    class PyDevComplete:
        """
        In PyDev the completer is at a higher level, it uses the ipython completer above and adds extra completion
        we need to overide this to return just the paths and not the other possible completions.
        This is not nice code because I am manipulating private methods but there is no other way to do this.
        """
        def __init__(self, original_function):
            """
            Initialise
            Args:
                original_function: the original completion function that we will call
            """
            self.original_function = original_function

        def just_path_on_load(self, text, act_tok):
            """
            Returns completions for load on a path if load_script in path otherwise returns as before.
            Will replace .metadata\.plugins\org.eclipse.pde.core\.bundle_pool\plugins\
            org.python.pydev_5.9.2.201708151115\pysrc\_pydev_bundle\pydev_ipython_console_011.py

            This functions will filter out the pydev completions if the line contains load_script. It know which
            are the pydev ones because they are marked with the type '11'.

            Args:
                text: text to complete
                act_tok: token, used only in original completion

            Returns:
                pydev completions

            """
            # This is the completion type assigned to all ipython completions in pydev
            ipython_completer_completion_type = '11'
            ans = self.original_function(text, act_tok)
            # returns list of tuples (completion, py doc, ?, type)
            if LOAD_SCRIPT_COMMAND in text:
                ans = [an for an in ans if an[3] == ipython_completer_completion_type]
            return ans

    # Replace the old completer in ipython with the new completer above and turns on pydev
    from _pydev_bundle.pydev_ipython_console_011 import _PyDevFrontEndContainer
    _PyDevFrontEndContainer._instance.getCompletions = \
        PyDevComplete(_PyDevFrontEndContainer._instance.getCompletions).just_path_on_load
    _load_script_completer.is_pydev = True
except ImportError:
    pass
    # this means we are not in pydev

# END TAB COMPLETE


def usercommand(func):
    """
    Decorator that marks a function as a user command (e.g. for NICOS).
    """
    func.is_usercommand = True
    func.is_hidden = False
    return func


def helparglist(args):
    """
    Decorator that supplies a custom argument list to be displayed by
    a help (e.g. for NICOS).
    """

    def deco(func):
        func.help_arglist = args
        return func

    return deco


if os.name == 'nt':
    class CONSOLE_SCREEN_BUFFER_INFO(ctypes.Structure):
        _fields_ = [
            ('dwSize', ctypes.wintypes._COORD),
            ('dwCursorPosition', ctypes.wintypes._COORD),
            ('wAttributes', ctypes.c_ushort),
            ('srWindow', ctypes.wintypes._SMALL_RECT),
            ('dwMaximumWindowSize', ctypes.wintypes._COORD)
        ]


def _print_error_message(message):
    """
    Print the error message to screen.
    """
    if os.name == 'nt':
        # Is windows
        std_output_handle = -11
        stdout_handle = ctypes.windll.kernel32.GetStdHandle(std_output_handle)
        csbi = CONSOLE_SCREEN_BUFFER_INFO()
        ctypes.windll.kernel32.GetConsoleScreenBufferInfo(stdout_handle, ctypes.byref(csbi))
        old_attrs = csbi.wAttributes
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, 12)
        print("ERROR: " + message)
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, old_attrs)
    else:
        # Non-windows
        print('\033[91m' + "ERROR: " + message + '\033[0m')
    # Log it
    __api.log_error_msg(message)


def _handle_exception(exception=None, message=None):
    """
    Handles any exception in the way we want.
    """
    if exception is not None:
        if message is not None:
            _print_error_message(message)
        else:
            traceback.print_exc(file=sys.stdout)
        if _exceptions_raised:
            raise exception
    elif message is not None:
        _print_error_message(message)
        if _exceptions_raised:
            raise Exception(message)
    else:
        _print_error_message("UNSPECIFIED")
