import ctypes
import os
import re

import sys
import traceback
import glob

# Determine whether to start in simulation mode
import IPython
import six
from IPython.core.completer import IPCompleter
from genie_python.utilities import get_correct_filepath_existing


if 'GENIE_SIMULATE' not in os.environ or os.environ['GENIE_SIMULATE'] != '1':
    from genie_python.genie_epics_api import API
else:
    print("\n=========== RUNNING IN SIMULATION MODE ===========\n")
    from genie_python.genie_simulate import API


# Windows specific stuff
if os.name == 'nt':
    # Needed for correcting file paths
    import win32api

# INITIALISATION CODE - DO NOT DELETE
try:
    # If __api does not exist or is None then we need to create it.
    if __api is None:
        raise Exception("API does not exist")
except Exception:
    # This should only get called the first time genie is imported
    my_pv_prefix = None
    if 'MYPVPREFIX' in os.environ:
        my_pv_prefix = os.environ['MYPVPREFIX']
        __api = API(my_pv_prefix, globals())
    else:
        print("No instrument specified - loading local instrument")
        __api = API(None, globals())

_exceptions_raised = False


# END INITIALISATION CODE

def set_user_script_dir(directory):
    """
    Set the user script directory, ensuring it ends in a slash
    Args:
        directory: directory to set it to

    """
    global USER_SCRIPT_DIR
    directory = get_correct_filepath_existing(directory)
    if len(directory) > 1 and directory[-1] != "/":
        directory += "/"
    USER_SCRIPT_DIR = directory


def get_user_script_dir():
    """
    Returns: the user script directory
    """
    global USER_SCRIPT_DIR
    return USER_SCRIPT_DIR


try:
    set_user_script_dir("C:/scripts/")
except Exception:
    USER_SCRIPT_DIR = ""


# TAB COMPLETE CODE

LOAD_SCRIPT_COMMAND = u'load_script('


class LoadScriptCompleter:
    """
    A class holding a custom complete function which replaces the normal completion function of the ipython completer.
    We are replacing it and not just adding it as a custom completer because it allows us to return just paths after
    load_script and no other completions from the IPython backend. If this does not have load script in it will return
    what the original one did.
    """

    def __init__(self, original_complete_fn):
        """
        Initialise.
        Args:
            original_complete_fn: function which was originally used to complete
        """
        self._original_complete = original_complete_fn
        self.is_pydev = False

    def complete(self, text=None, line_buffer=None, cursor_pos=None):
        """
        Find completions for the given text and line context.

        Note that both the text and the line_buffer are optional, but at least
        one of them must be given.

        Parameters
        ----------
          text : string, optional
            Text to perform the completion on.  Line buffer
            is always used except when using the default completer.

          line_buffer : string, optional
            line to match

          cursor_pos : int, optional
            Index of the cursor in the full line buffer.  Should be provided by
            remote frontends where kernel has no access to frontend state.

        Returns
        -------
        text : str
          Text that was actually used in the completion.

        matches : list
          A list of completion matches.
        """

        if LOAD_SCRIPT_COMMAND not in line_buffer:
            match, completion = self._original_complete(text, line_buffer, cursor_pos)
        else:
            # cope with None as search path
            if line_buffer is None:
                line_buffer = ''

            # get file path
            search_path = line_buffer.split(LOAD_SCRIPT_COMMAND)[-1]

            # add quote if it is missing
            if search_path.startswith("'") or search_path.startswith('"'):
                search_path = search_path[1:]
                quote = ''
            else:
                quote = '"'

            # set the match (i.e. what we are replacing in the line)
            match = search_path

            # if the path isn't absolute it should refer to script dir
            if os.path.isabs(search_path):
                len_added_user_script = 0
            else:
                user_script_dir = get_user_script_dir()
                search_path = "{}{}".format(user_script_dir, search_path)
                len_added_user_script = len(user_script_dir)

            # search and return results
            paths = glob.glob("{}*".format(search_path))
            if self.is_pydev:
                # PyDev expects just the end part of the expression back broken at the last punctuation
                completion = []
                for path in paths:
                    # py dev replaces back to the last splitting character. Find that in the line buffer. E.g.
                    # I have a script called play.py
                    # I type C:/script/pl
                    # This function will add only play.py to the list (back to the last splitting character, i.e. /)
                    # There is a special case when it is just load_script(
                    if line_buffer.endswith("load_script("):
                        line_buffer_back_to_last_splitting_character = '"'
                    else:
                        line_buffer_back_to_last_splitting_character = re.split(r'[/:\\ .-]', line_buffer)[-1]

                    # find extra path to add
                    len_of_overlap = len(search_path)
                    completion_path = path[len_of_overlap:].replace('\\', '/')

                    # assemble the auto replace
                    completion.append("{}{}".format(line_buffer_back_to_last_splitting_character, completion_path))

            else:
                # Console expects the whole path
                # return / to avoid a quoting issue with \ in paths and do not include the script dir
                completion = [six.u("{}{}".format(quote, path.replace('\\', '/')[len_added_user_script:]))
                              for path in paths]

        return match, completion


class PyDevComplete:
    """
    In PyDev the completer is at a higher level, it uses the ipython completer above and adds extra completion
    we need to overide this to return just the paths and not the other possible completions.
    This is not nice code because I am manipulating private methods but there is no other way to do this.
    """
    def __init__(self, original_function):
        """
        Initialise
        Args:
            original_function: the original completion function that we will call
        """
        self.original_function = original_function

    def just_path_on_load(self, text, act_tok):
        """
        Returns completions for load on a path if load_script in path otherwise returns as before.
        Will replace .metadata\.plugins\org.eclipse.pde.core\.bundle_pool\plugins\
        org.python.pydev_5.9.2.201708151115\pysrc\_pydev_bundle\pydev_ipython_console_011.py

        This functions will filter out the pydev completions if the line contains load_script. It know which
        are the pydev ones because they are marked with the type '11'.

        Args:
            text: text to complete
            act_tok: token, used only in original completion

        Returns:
            pydev completions

        """
        # This is the completion type assigned to all ipython completions in pydev
        ipython_completer_completion_type = '11'
        ans = self.original_function(text, act_tok)
        # returns list of tuples (completion, py doc, ?, type)
        if LOAD_SCRIPT_COMMAND in text:
            ans = [an for an in ans if an[3] == ipython_completer_completion_type]
        return ans


try:
    # replace the original completer in ipython with the one above
    ipy_completer = IPython.get_ipython().Completer.complete
    _load_script_completer = LoadScriptCompleter(ipy_completer)
    IPython.get_ipython().Completer.complete = _load_script_completer.complete

    try:
        # Replace the old completer in pydev with the new completer above and turns on pydev
        from _pydev_bundle.pydev_ipython_console_011 import _PyDevFrontEndContainer
        _PyDevFrontEndContainer._instance.getCompletions = \
            PyDevComplete(_PyDevFrontEndContainer._instance.getCompletions).just_path_on_load
        _load_script_completer.is_pydev = True
    except ImportError:
        pass
        # this means we are not in pydev
except AttributeError:
    print("ERROR: IPython does not exist, auto complete not installed")

# END TAB COMPLETE


def usercommand(func):
    """
    Decorator that marks a function as a user command (e.g. for NICOS).
    """
    func.is_usercommand = True
    func.is_hidden = False
    return func


def helparglist(args):
    """
    Decorator that supplies a custom argument list to be displayed by
    a help (e.g. for NICOS).
    """

    def deco(func):
        func.help_arglist = args
        return func

    return deco


if os.name == 'nt':
    class CONSOLE_SCREEN_BUFFER_INFO(ctypes.Structure):
        _fields_ = [
            ('dwSize', ctypes.wintypes._COORD),
            ('dwCursorPosition', ctypes.wintypes._COORD),
            ('wAttributes', ctypes.c_ushort),
            ('srWindow', ctypes.wintypes._SMALL_RECT),
            ('dwMaximumWindowSize', ctypes.wintypes._COORD)
        ]


def _print_error_message(message):
    """
    Print the error message to screen.
    """
    if os.name == 'nt':
        # Is windows
        std_output_handle = -11
        stdout_handle = ctypes.windll.kernel32.GetStdHandle(std_output_handle)
        csbi = CONSOLE_SCREEN_BUFFER_INFO()
        ctypes.windll.kernel32.GetConsoleScreenBufferInfo(stdout_handle, ctypes.byref(csbi))
        old_attrs = csbi.wAttributes
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, 12)
        print("ERROR: " + message)
        ctypes.windll.kernel32.SetConsoleTextAttribute(stdout_handle, old_attrs)
    else:
        # Non-windows
        print('\033[91m' + "ERROR: " + message + '\033[0m')
    # Log it
    __api.log_error_msg(message)


def _handle_exception(exception=None, message=None):
    """
    Handles any exception in the way we want.
    """
    if exception is not None:
        if message is not None:
            _print_error_message(message)
        else:
            traceback.print_exc(file=sys.stderr)
        if _exceptions_raised:
            raise exception
    elif message is not None:
        _print_error_message(message)
        if _exceptions_raised:
            raise Exception(message)
    else:
        _print_error_message("UNSPECIFIED")
