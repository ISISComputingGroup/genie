"""
Displays Agg images in the browser, with interactivity
"""

# The WebAgg backend is divided into two modules:
#
# - `backend_webagg_core.py` contains code necessary to embed a WebAgg
#   plot inside of a web application, and communicate in an abstract
#   way over a web socket.
#
# - `backend_webagg.py` contains a concrete implementation of a basic
#   application, implemented with tornado.
import sys

import time

try:
    import tornado
except ImportError:
    raise RuntimeError("The WebAgg backend requires Tornado.")

from matplotlib.backend_bases import _Backend
from matplotlib.backends import backend_webagg
from matplotlib.backends import backend_webagg_core as core
from concurrent.futures.thread import ThreadPoolExecutor


ServerThread = backend_webagg.ServerThread

webagg_server_thread = ServerThread()

FigureCanvasWebAgg = backend_webagg.FigureCanvasWebAgg

"""
All interactions with WebAggApplication go via this worker thread.

This allows us to keep serving the plot while we do other logic in the python script
"""
EXECUTOR = ThreadPoolExecutor(5)


def run_async(f, *args, **kwargs):
    return EXECUTOR.submit(f, *args, **kwargs)


def run_async_result(f, *args, **kwargs):
    return run_async(f, *args, **kwargs).result()


class WebAggApplication(backend_webagg.WebAggApplication):

    ioloop = None

    @classmethod
    def start(cls):

        """
        IOLoop.running() was removed as of Tornado 2.4; see for example
        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY
        Thus there is no correct way to check if the loop has already been
        launched. We may end up with two concurrently running loops in that
        unlucky case with all the expected consequences.
        """
        cls.ioloop = tornado.ioloop.IOLoop.instance()

        if cls.started:
            cls.stop()

        # Set the flag to True *before* blocking on ioloop.start()
        cls.started = True
        cls.ioloop.start()

    @classmethod
    def stop(cls):
        cls.ioloop.stop()
        sys.stdout.flush()
        cls.started = False
        time.sleep(1)  # TODO: think about a better solution here.


@_Backend.export
class _BackendIbexWebAgg(_Backend):
    FigureCanvas = FigureCanvasWebAgg
    FigureManager = core.FigureManagerWebAgg

    @staticmethod
    def trigger_manager_draw(manager):
        manager.canvas.draw_idle()

    @staticmethod
    def show():
        if run_async_result(lambda: WebAggApplication.started):
            run_async_result(WebAggApplication.stop)

        if not run_async_result(lambda: WebAggApplication.initialized):
            run_async_result(WebAggApplication.initialize)

        url = "http://127.0.0.1:{port}{prefix}".format(
            port=run_async_result(lambda: WebAggApplication.port),
            prefix=run_async_result(lambda: WebAggApplication.url_prefix)
        )

        print("Matplotlib server running at {}".format(url))

        # TODO: logic to tell IBEX to open plot should go here

        run_async(WebAggApplication.start)
