"""
Displays Agg images in the browser, with interactivity
"""

# The WebAgg backend is divided into two modules:
#
# - `backend_webagg_core.py` contains code necessary to embed a WebAgg
#   plot inside of a web application, and communicate in an abstract
#   way over a web socket.
#
# - `backend_webagg.py` contains a concrete implementation of a basic
#   application, implemented with tornado.
import random
import socket
import sys
import threading

import time

import errno

try:
    import tornado
except ImportError:
    raise RuntimeError("The WebAgg backend requires Tornado.")

from matplotlib.backend_bases import _Backend
from matplotlib import rcParams
from matplotlib.backends import backend_webagg
from matplotlib.backends import backend_webagg_core as core
from concurrent.futures.thread import ThreadPoolExecutor
from py4j.java_gateway import JavaGateway

try:
    IBEX = JavaGateway().entry_point
except Exception as e:
    IBEX = None


ServerThread = backend_webagg.ServerThread

webagg_server_thread = ServerThread()

FigureCanvasWebAgg = backend_webagg.FigureCanvasWebAgg

"""
All interactions with WebAggApplication go via this worker thread.

This allows us to keep serving the plot while we do other logic in the python script
"""
EXECUTOR = ThreadPoolExecutor(1)


def run_async(f, *args, **kwargs):
    return EXECUTOR.submit(f, *args, **kwargs)


def run_async_result(f, *args, **kwargs):
    return run_async(f, *args, **kwargs).result()


class WebAggApplication(backend_webagg.WebAggApplication):

    ioloop = None
    started = False

    @classmethod
    def initialize(cls, url_prefix='', port=8988, address=None):
        # Create the class instance
        app = cls(url_prefix=url_prefix)
        cls.url_prefix = url_prefix
        cls.port = port
        cls.address = address
        app.listen(cls.port, cls.address)

    @classmethod
    def start(cls):

        """
        IOLoop.running() was removed as of Tornado 2.4; see for example
        https://groups.google.com/forum/#!topic/python-tornado/QLMzkpQBGOY
        Thus there is no correct way to check if the loop has already been
        launched. We may end up with two concurrently running loops in that
        unlucky case with all the expected consequences.
        """
        print("Starting...")
        cls.ioloop = tornado.ioloop.IOLoop.instance()

        # Set the flag to True *before* blocking on ioloop.start()
        cls.started = True
        cls.ioloop.start()
        print("Started")

    @classmethod
    def stop(cls):
        print("Stopping...")
        cls.ioloop.stop()
        sys.stdout.flush()
        cls.started = False
        print("Stopped")


def ibex_open_plot(url):
    """
    Open a plot in the IBEX client.

    Args:
        url: The URL where the plot can be found
    """
    try:
        IBEX.openPlot()
        print("Plot open in IBEX.")
    except Exception:
        import webbrowser
        webbrowser.open(url)
        print("Couldn't open plot in IBEX - opened web browser instead. URL is {}".format(url))


IBEX_BACKEND_LOCK = threading.RLock()


@_Backend.export
class _BackendIbexWebAgg(_Backend):
    FigureCanvas = FigureCanvasWebAgg
    FigureManager = core.FigureManagerWebAgg

    @staticmethod
    def trigger_manager_draw(manager):
        with IBEX_BACKEND_LOCK:
            manager.canvas.draw_idle()

    @staticmethod
    def show():
        """
        Show a plot.
        """
        if not WebAggApplication.started:
            with IBEX_BACKEND_LOCK:
                run_async(WebAggApplication.initialize)
                run_async(WebAggApplication.start)

        # url = "http://127.0.0.1:{port}{prefix}".format(
        #     port=WebAggApplication.port,
        #     prefix=WebAggApplication.url_prefix
        # )
        #
        # print("Starting matplotlib webserver running at: {}".format(url))

        ibex_open_plot("http://127.0.0.1:8988")
