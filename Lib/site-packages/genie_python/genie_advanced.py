"""
Genie Advance module:

This module is used for advanced commands that are for expert users.
"""
import os
from datetime import datetime, timedelta

from time import sleep

from genie_python.genie_api_setup import __api, helparglist, usercommand, set_user_script_dir
from genie_python.utilities import check_break
from genie_python.genie_waitfor import DELAY_IN_WAIT_FOR_SLEEP_LOOP
from genie_python.genie_api_setup import log_command_and_handle_exception
from genie_python.mysql_abstraction_layer import SQLAbstraction


@usercommand
@helparglist('block str')
@log_command_and_handle_exception
def get_pv_from_block(block):
    """
    Get the full PV name for a given block.
    This is an advanced function because of the need to use the pv name correctly.

    Args:
        block (str): A block object

    Returns:
        pv_name (Str): The pv name as a string

    """
    return __api.get_pv_from_block(block)


@usercommand
@helparglist('pv str, value[, maxwait]')
@log_command_and_handle_exception
def wait_for_pv(pv, value, maxwait=None):
    """
    Wait until a PV has reached a given value.

    Params:
        pv (str): The address of the PV
        value: The value to wait for
        maxwait (int, optional): The maximum time to wait for in seconds
    """
    start_time = datetime.utcnow()
    while True:
        curr_value = __api.get_pv_value(pv)
        if curr_value == value:
            break
        if maxwait is not None:
            if timedelta(seconds=maxwait) < datetime.utcnow() - start_time:
                break
        sleep(DELAY_IN_WAIT_FOR_SLEEP_LOOP)
        check_break(2)


@usercommand
@helparglist('')
def set_begin_precmd(begin_precmd):
    """
    Set the function to call before the begin command.

    Args:
        begin_precmd (function): The function to call (which should return None if it wants the run to start,
          or a string with the reason why not to start run).
    """
    __api.pre_post_cmd_manager.begin_precmd = begin_precmd


@usercommand
@helparglist('')
def set_begin_postcmd(begin_postcmd):
    """
    Set the function to call after the begin command.

    Args:
        begin_postcmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.begin_postcmd = begin_postcmd


@usercommand
@helparglist('')
def set_abort_precmd(abort_precmd):
    """
    Set the function to call before the abort command.

    Args:
        abort_precmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.abort_precmd = abort_precmd


@usercommand
@helparglist('')
def set_abort_postcmd(abort_postcmd):
    """
    Set the function to call after the abort command.

    Args:
        abort_postcmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.abort_postcmd = abort_postcmd


@usercommand
@helparglist('')
def set_end_precmd(end_precmd):
    """
    Set the function to call before the end command.

    Args:
        end_precmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.end_precmd = end_precmd


@usercommand
@helparglist('')
def set_end_postcmd(end_postcmd):
    """
    Set the function to call after the end command.

    Args:
        end_postcmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.end_postcmd = end_postcmd


@usercommand
@helparglist('')
def set_pause_precmd(pause_precmd):
    """
    Set the function to call before the pause command.

    Args:
        pause_precmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.pause_precmd = pause_precmd


@usercommand
@helparglist('')
def set_pause_postcmd(pause_postcmd):
    """
    Set the function to call after the pause command.

    Args:
        pause_postcmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.pause_postcmd = pause_postcmd


@usercommand
@helparglist('')
def set_resume_precmd(resume_precmd):
    """
    Set the function to call before the resume command.

    Args:
        resume_precmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.resume_precmd = resume_precmd


@usercommand
@helparglist('')
def set_resume_postcmd(resume_postcmd):
    """
    Set the function to call after the resume command.

    Args:
        resume_postcmd (function): The function to call.
    """
    __api.pre_post_cmd_manager.resume_postcmd = resume_postcmd


@usercommand
@helparglist('')
def open_plot_window(is_primary=True, host=None):
    """
    Open the plot window in the client
    Args:
        is_primary: True to open primary plotting window; False open secondaty window
        host: host to open plot from; Default None is localhost
    """
    from genie_python.matplotlib_backend.ibex_web_backend import ibex_open_plot_window
    ibex_open_plot_window(is_primary, host=host)


@usercommand
@helparglist('')
@log_command_and_handle_exception
def get_instrument():
    """
    Gets the name of the local instrument (e.g. NDW1234, DEMO, EMMA-A)

    Returns:
        the name of the local instrument
    """
    return __api.get_instrument()


@usercommand
@helparglist('verbose')
@log_command_and_handle_exception
def set_dae_message_verbosity(verbose):
    """
    Set the verbosity of messages coming from the DAE.

    Args:
        verbose (bool): set the verbosity, True to be more verbose
    """
    __api.dae.set_verbose(verbose)


@usercommand
@helparglist('verbose')
@log_command_and_handle_exception
def prompt_to_set_script_dir(base_script_dir):
    """
    Prompt to set the genie_python script directory, make the directory if it doesn't exist

    Notes:
      This can not be placed in the init for an instrument because inputs are ignored during startup. Instead it
      is recommended to add to the init file:
        def set_dir():
            g.adv.prompt_to_set_script_dir(g.get_script_dir())

        def init(inst):
            g.change_script_dir(r"<preferred root dir>")
            print("To set where scripts and data are save used set_dir(). Currently in {}".format(g.get_script_dir()))

    Args:
        base_script_dir (str): directory in which user requested directory should exist

    """
    script_dir_not_set = True
    while script_dir_not_set:
        final_path = "no dir entered"
        try:
            script_dir = input("Please set the script directory relative to {}\n".format(base_script_dir))

            final_path = os.path.join(base_script_dir, script_dir)
            os.makedirs(final_path, exist_ok=True)
            set_user_script_dir(final_path)
            print("Scripts will be run from and scans data is saved to {}".format(final_path))
            script_dir_not_set = False
        except OSError as err:
            print("Directory does not exist and could not be created. {}. Error: {}".format(final_path, err))


@usercommand
@helparglist('')
@log_command_and_handle_exception
def get_exp_data(rb: int = None, user: str = None, role: str = None):
    """
    Prints the data of experiments that match the given criteria, or all if none is given, from the exp_data database.

    Args:
        rb (int, optional): The RB number of the experiment to look for, Defaults to None (any).
        user (str, optional): The name of the user who is running/has run the experiment, Defaults to None (any).
        role (str, optional): The user role, Defaults to None (any).

    """
    # Type checking
    if not (rb is None or isinstance(rb, int)):
        raise TypeError('Experiment RB number must be an integer.')
    if not (user is None or isinstance(user, str)):
        raise TypeError('User name must be a string.')
    if not (role is None or isinstance(role, str)):
        raise TypeError('Role name must be a string.')

    # noinspection PyPep8Naming
    # Initialize the DB connection
    SQL = SQLAbstraction(dbname='exp_data', user='report', password='$report')

    # Prepare the statement and bound variables
    sql = "SELECT * FROM `experimentteams`"
    args = []
    if any(x is not None for x in [rb, user, role]):
        sql += f' WHERE '

        # If experiment RB number was provided
        if rb is not None:
            args.append(rb)
            sql += f"experimentID LIKE '%%s%'"
            sql += ' AND ' if any(x is not None for x in [user, role]) else ''

        # If filtering by experiment user
        if user is not None:
            user_id = SQL.execute_command(command="SELECT userID FROM `user` WHERE name = %s", is_query=True,
                                          bound_variables=(user,))
            if not user_id:
                print(f'User with name "{user}" was not found. Please make sure the title and name are correct'
                      f' (e.g. "Dr John Smith").')
                return

            user_id = user_id[0] if isinstance(user_id, list) else user_id
            user_id = user_id[0] if isinstance(user_id, tuple) else user_id
            args.append(user_id)

            sql += "userID = %s"
            sql += ' AND ' if role is not None else ''

        # If filtering by exp. user roles
        if role is not None:
            role_id = SQL.execute_command(command="SELECT roleID FROM `role` WHERE name = %s", is_query=True,
                                          bound_variables=(role,))

            if not role_id:
                roles = SQL.execute_command(command="SELECT name FROM `role`", is_query=True, bound_variables=())
                roles = ', '.join([x[0] for x in roles])
                print(f'Role "{role}" was not found. Existing roles: [{roles}]')
                return

            role_id = role_id[0] if isinstance(role_id, list) else role_id
            role_id = role_id[0] if isinstance(role_id, tuple) else role_id
            args.append(role_id)

            sql += "roleID = %s"

    sql += ' ORDER BY experimentID DESC'
    params = tuple(args)

    # Fetch the records
    records = SQL.execute_command(command=sql, is_query=True, bound_variables=params)

    if not records:
        print(f'Found no experiments that match the given criteria '
              f'(RB: {rb if rb is not None else "Any"}, '
              f'User: {user if user is not None else "Any"}, '
              f'Role: {role if role is not None else "Any"}).')
        return

    print('Experiment Data Search Results:')

    # Get the exp. no. + user and role names from their respective tables using the IDs
    exp_data = []
    for exp in records:
        exp_rb_no = exp[0]
        user_name = SQL.execute_command(command="SELECT name FROM `user` WHERE userID = %s", is_query=True,
                                        bound_variables=(exp[1],))
        user_name = user_name[0] if isinstance(user_name, list) else user_name
        user_name = user_name[0] if isinstance(user_name, tuple) else user_name

        role_name = SQL.execute_command(command="SELECT name FROM `role` WHERE roleID = %s", is_query=True,
                                        bound_variables=(exp[2],))
        role_name = role_name[0] if isinstance(role_name, list) else role_name
        role_name = role_name[0] if isinstance(role_name, tuple) else role_name

        start_date = exp[3].strftime('%Y-%m-%d %H:%M:%S')

        duration = SQL.execute_command(command="SELECT duration FROM `experiment` WHERE experimentID = %s",
                                       is_query=True, bound_variables=(exp_rb_no,))
        duration = duration[0] if isinstance(duration, list) else duration
        duration = duration[0] if isinstance(duration, tuple) else duration

        exp_data.append([exp_rb_no, user_name, role_name, start_date, duration])

    # For pretty printing
    rb_padding = max(len(x) for x in [y[0] for y in exp_data])
    user_padding = max(len(x) for x in [y[1] for y in exp_data])
    role_padding = max(len(x) for x in [y[2] for y in exp_data])

    for exp in exp_data:
        print(f'Experiment RB number: {exp[0]:{rb_padding}} | '
              f'User: {exp[1]:{user_padding}} | '
              f'Role: {exp[2]:{role_padding}} | '
              f'Start date: {exp[3]} | '
              f'Duration: {exp[4]}')
