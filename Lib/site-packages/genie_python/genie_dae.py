from __future__ import absolute_import, print_function

import datetime

import numpy as np

from builtins import str
import xml.etree.ElementTree as ET
import os
import zlib
import json
import re
from contextlib import contextmanager
from stat import S_IWUSR, S_IREAD
from time import strftime, sleep, localtime
from collections import namedtuple
import psutil
from io import open
from binascii import hexlify

from genie_python.genie_cachannel_wrapper import CaChannelWrapper
from genie_python.genie_change_cache import ChangeCache
from genie_python.utilities import dehex_and_decompress, compress_and_hex, convert_string_to_ascii, get_correct_path, \
    waveform_to_string
import six
from six.moves import range
from genie_python.utilities import require_runstate

DAE_PVS_LOOKUP = {
    "runstate": "DAE:RUNSTATE",
    "runstate_str": "DAE:RUNSTATE_STR",
    "beginrun": "DAE:BEGINRUNEX",
    "abortrun": "DAE:ABORTRUN",
    "pauserun": "DAE:PAUSERUN",
    "resumerun": "DAE:RESUMERUN",
    "endrun": "DAE:ENDRUN",
    "recoverrun": "DAE:RECOVERRUN",
    "saverun": "DAE:SAVERUN",
    "updaterun": "DAE:UPDATERUN",
    "storerun": "DAE:STORERUN",
    "snapshot": "DAE:SNAPSHOTCRPT",
    "period_rbv": "DAE:PERIOD:RBV",
    "period": "DAE:PERIOD",
    "runnumber": "DAE:RUNNUMBER",
    "numperiods": "DAE:NUMPERIODS",
    "events": "DAE:EVENTS",
    "mevents": "DAE:MEVENTS",
    "totalcounts": "DAE:TOTALCOUNTS",
    "goodframes": "DAE:GOODFRAMES",
    "goodframesperiod": "DAE:GOODFRAMES_PD",
    "rawframes": "DAE:RAWFRAMES",
    "uamps": "DAE:GOODUAH",
    "histmemory": "DAE:HISTMEMORY",
    "spectrasum": "DAE:SPECTRASUM",
    "uampsperiod": "DAE:GOODUAH_PD",
    "title": "DAE:TITLE",
    "title_sp": "DAE:TITLE:SP",
    "rbnum": "ED:RBNUMBER",
    "rbnum_sp": "ED:RBNUMBER:SP",
    "period_sp": "DAE:PERIOD:SP",
    "users": "ED:SURNAME",
    "users_table_sp": "ED:USERNAME:SP",
    "users_dae_sp": "ED:USERNAME:DAE:SP",
    "users_surname_sp": "ED:SURNAME",
    "starttime": "DAE:STARTTIME",
    "npratio": "DAE:NPRATIO",
    "timingsource": "DAE:DAETIMINGSOURCE",
    "periodtype": "DAE:PERIODTYPE",
    "isiscycle": "DAE:ISISCYCLE",
    "rawframesperiod": "DAE:RAWFRAMES_PD",
    "runduration": "DAE:RUNDURATION",
    "rundurationperiod": "DAE:RUNDURATION_PD",
    "numtimechannels": "DAE:NUMTIMECHANNELS",
    "memoryused": "DAE:DAEMEMORYUSED",
    "numspectra": "DAE:NUMSPECTRA",
    "monitorcounts": "DAE:MONITORCOUNTS",
    "monitorspectrum": "DAE:MONITORSPECTRUM",
    "periodseq": "DAE:PERIODSEQ",
    "beamcurrent": "DAE:BEAMCURRENT",
    "totaluamps": "DAE:TOTALUAMPS",
    "totaldaecounts": "DAE:TOTALDAECOUNTS",
    "monitorto": "DAE:MONITORTO",
    "monitorfrom": "DAE:MONITORFROM",
    "countrate": "DAE:COUNTRATE",
    "eventmodefraction": "DAE:EVENTMODEFRACTION",
    "daesettings": "DAE:DAESETTINGS",
    "daesettings_sp": "DAE:DAESETTINGS:SP",
    "tcbsettings": "DAE:TCBSETTINGS",
    "tcbsettings_sp": "DAE:TCBSETTINGS:SP",
    "periodsettings": "DAE:HARDWAREPERIODS",
    "periodsettings_sp": "DAE:HARDWAREPERIODS:SP",
    "getspectrum_x": "DAE:SPEC:{:d}:{:d}:X",
    "getspectrum_x_size": "DAE:SPEC:{:d}:{:d}:X.NORD",
    "getspectrum_y": "DAE:SPEC:{:d}:{:d}:Y",
    "getspectrum_y_size": "DAE:SPEC:{:d}:{:d}:Y.NORD",
    "getspectrum_yc": "DAE:SPEC:{:d}:{:d}:YC",
    "getspectrum_yc_size": "DAE:SPEC:{:d}:{:d}:YC.NORD",
    "errormessage": "DAE:ERRMSGS",
    "allmessages": "DAE:ALLMSGS",
    "statetrans": "DAE:STATETRANS",
    "wiringtables": "DAE:WIRINGTABLES",
    "spectratables": "DAE:SPECTRATABLES",
    "detectortables": "DAE:DETECTORTABLES",
    "periodfiles": "DAE:PERIODFILES",
    "set_veto_true": "DAE:VETO:ENABLE:SP",
    "set_veto_false": "DAE:VETO:DISABLE:SP",
    "simulation_mode": "DAE:SIM_MODE",
    "state_changing": "DAE:STATE:CHANGING"
}

DAE_CONFIG_FILE_PATHS = [
    r"C:\Labview modules\dae\icp_config.xml",
    r"C:\Instrument\Apps\EPICS\ICP_Binaries\icp_config.xml",
]

END_NOW_FILE_PATH = "C:\\data\\end_now.dae"

CLEAR_VETO = 'clearall'
SMP_VETO = 'smp'
TS2_VETO = 'ts2'
HZ50_VETO = 'hz50'
EXT0_VETO = 'ext0'
EXT1_VETO = 'ext1'
EXT2_VETO = 'ext2'
EXT3_VETO = 'ext3'
FIFO_VETO = 'fifo'

from datetime import datetime


class Dae(object):
    """
    Communications with the DAE pvs.
    """

    def __init__(self, api, prefix=""):
        """
        The constructor.

        Args:
            api(genie_python.genie_epics_api.API): the API used for communication
            prefix: the PV prefix
        """
        self.api = api
        self.inst_prefix = prefix
        self.in_change = False
        self.change_cache = ChangeCache()
        self.verbose = False

        # this is the default value to ensure dae settings are written before returning, only changed for testing
        self.wait_for_completion_callback_dae_settings = True

    def _prefix_pv_name(self, name):
        """
        Adds the prefix to the PV name.

        Args:
            name: the name to be prefixed

        Returns:
            string: the full PV name
        """
        if self.inst_prefix is not None:
            name = self.inst_prefix + name
        return name

    def _get_dae_pv_name(self, name):
        """
        Retrieves the full pv name of a DAE variable.

        Args:
            name: the short name for the DAE variable

        Returns:
            string: the full PV name
        """
        return self._prefix_pv_name(DAE_PVS_LOOKUP[name.lower()])

    def _get_pv_value(self, name, to_string=False, use_numpy=None):
        """
        Gets a PV's value.

        Args:
            name: the PV name
            to_string: whether to convert the value to a string
            use_numpy (None|boolean): True use numpy to return arrays, False return a list; None for use the default

        Returns:
            object: the PV's value
        """
        return self.api.get_pv_value(name, to_string, use_numpy=use_numpy)

    def _set_pv_value(self, name, value, wait=False):
        """
        Sets a PV value via the API.

        Args:
            name: the PV name
            value: the value to set
            wait: whether to wait for it to be set before returning
        """
        self.api.set_pv_value(name, value, wait)

    def _check_for_runstate_error(self, pv, header=""):
        """
        Check for errors on the run state PV.

        Args:
            pv: the PV name
            header: information to include in the exception raised.

        Raises:
            Exception: if there is an error on the specified PV

        """
        status = self._get_pv_value(pv + ".STAT", to_string=True)
        if status != "NO_ALARM":
            raise Exception("{} {}".format(
                header.strip(),
                self._get_pv_value(self._get_dae_pv_name("errormessage"), to_string=True)))

    def _print_verbose_messages(self):
        """
        Prints all the messages.
        """
        msgs = self._get_pv_value(self._get_dae_pv_name("allmessages"), to_string=True)
        print(msgs)

    def _write_to_end_now_file(self, file_content):
        """
        Creates the end_now file if it doesn't exist and writes text to it, overwriting any existing content

        Args:
            file_content: the new file content
        """
        with open(END_NOW_FILE_PATH, "w+") as f:
            f.write(file_content)

    def set_verbose(self, verbose):
        """
        Sets the verbosity of the DAE messages printed

        Args:
            verbose: bool setting

        Raise:
            Exception: if the supplied value is not a bool
        """
        if isinstance(verbose, bool):
            self.verbose = verbose
            if verbose:
                print("Setting DAE messages to verbose mode")
            else:
                print("Setting DAE messages to non-verbose mode")
        else:
            raise Exception("Value must be boolean")

    @require_runstate(['SETUP'])
    def begin_run(self, period=None, meas_id=None, meas_type=None, meas_subid=None,
                  sample_id=None, delayed=False, quiet=False, paused=False):
        """Starts a data collection run.

        Args:
            period - the period to begin data collection in [optional]
            meas_id - the measurement id [optional]
            meas_type - the type of measurement [optional]
            meas_subid - the measurement sub-id[optional]
            sample_id - the sample id [optional]
            delayed - puts the period card to into delayed start mode [optional]
            quiet - suppress the output to the screen [optional]
            paused - begin in the paused state [optional]
        """
        if self.in_change:
            raise Exception("Cannot start in CHANGE mode, type change_finish()")

        # Set sample parameters
        sample_pars = {"MEAS:ID": meas_id, "MEAS:TYPE": meas_type, "MEAS:SUBID": meas_subid, "ID": sample_id}
        for pv, value in sample_pars.items():
            if value is not None:
                self.api.set_sample_par(pv, str(value))

        # Check PV exists
        val = self._get_pv_value(self._get_dae_pv_name("beginrun"))
        if val is None:
            raise Exception("begin_run: could not connect to DAE")

        if period is not None:
            # Set the period before starting the run
            self.set_period(period)

        if not quiet:
            if self.get_simulation_mode():
                self.simulation_mode_warning()
            print(("** Beginning Run {} at {}".format(self.get_run_number(), strftime("%H:%M:%S %d/%m/%y "))))
            print(("*  Proposal Number: {}".format(self.get_rb_number())))
            print(("*  Experiment Team: {}".format(self.get_users())))

        # By choosing the value sent to the begin PV it can set pause and/or delayed
        options = 0
        if paused:
            options += 1
        if delayed:
            options += 2

        _cancel_monitor_fn = None
        try:
            def callback_function(message, severity, status):
                """
                Args:
                    message: the error message from the DAE as character waveform
                    severity: required by the CaChannelWrapper.add_monitor
                    status: required by the CaChannelWrapper.add_monitor
                """
                message = waveform_to_string(message)
                if message:
                    print("ISISICP error: {}".format(message))

            _cancel_monitor_fn = CaChannelWrapper.add_monitor(self._get_dae_pv_name("errormessage"),
                                                              callback_function)
            # actually do begin
            self._set_pv_value(self._get_dae_pv_name("beginrun"), options, wait=True)
        finally:
            if _cancel_monitor_fn is not None:
                _cancel_monitor_fn()

    def simulation_mode_warning(self):
        """
        Warn user they are in simulation mode.
        """
        print("\n=========== RUNNING IN SIMULATION MODE ===========\n")
        print("Simulation mode can be stopped using:               \n")
        print("         >>>set_dae_simulation_mode(False)          \n")
        print("==================================================\n")

    def post_begin_check(self, verbose=False):
        """
        Checks the BEGIN PV for errors after beginning a run.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("beginrun"), "BEGIN")
        if verbose or self.verbose:
            self._print_verbose_messages()

    @require_runstate(['RUNNING', 'VETOING', 'WAITING', 'PAUSED'])
    def abort_run(self):
        """
        Abort the current run.
        """
        print(("** Aborting Run {} at {} (the run will not be saved, call g.recover() to undo this)"
               .format(self.get_run_number(), strftime("%H:%M:%S %d/%m/%y "))))
        self._set_pv_value(self._get_dae_pv_name("abortrun"), 1, wait=True)

    def post_abort_check(self, verbose=False):
        """
        Checks the ABORT PV for errors after aborting a run.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("abortrun"), "ABORT")
        if verbose or self.verbose:
            self._print_verbose_messages()

    @require_runstate(['RUNNING', 'VETOING', 'WAITING', 'PAUSED', 'ENDING'])
    def end_run(self, verbose=False, quiet=False, immediate=False):
        """
        End the current run.

        Args:
            verbose: whether to print verbosely
            quiet: suppress the output to the screen [optional]
            immediate: end immediately, without waiting for a period sequence to complete
        """
        if self.get_run_state() == "ENDING" and not immediate:
            print("Please specify the 'immediate=True' flag to end a run while in the ENDING state")
            return

        if not quiet:
            print(("** Ending Run {} at {}".format(self.get_run_number(), strftime("%H:%M:%S %d/%m/%y "))))

        if immediate:
            self._write_to_end_now_file(u"1")

        self._set_pv_value(self._get_dae_pv_name("endrun"), 1, wait=True)
        if verbose or self.verbose:
            self._print_verbose_messages()

    def post_end_check(self, verbose=False):
        """
        Checks the END PV for errors after ending a run.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("endrun"), "END")
        if verbose or self.verbose:
            self._print_verbose_messages()

    def recover_run(self):
        """
        Recovers the run if it has been aborted.

        The command should be run before the next run is started.
        Note: the run will be recovered in the paused state.
        """
        self._set_pv_value(self._get_dae_pv_name("recoverrun"), 1, wait=True)

    def post_recover_check(self, verbose=False):
        """
        Checks the RECOVER PV for errors after recovering a run.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("recoverrun"), "RECOVER")
        if verbose or self.verbose:
            self._print_verbose_messages()

    def update_store_run(self):
        """
        Performs an update and a store operation in a combined operation.

        This is more efficient than doing the commands separately.
        """
        print(("** Saving Run {} at {}".format(self.get_run_number(), strftime("%H:%M:%S %d/%m/%y "))))
        self._set_pv_value(self._get_dae_pv_name("saverun"), 1, wait=True)

    def post_update_store_check(self, verbose=False):
        """
        Checks the associated PV for errors after an update store.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("saverun"), "SAVE")
        if verbose or self.verbose:
            self._print_verbose_messages()

    def update_run(self):
        """
        Data is loaded from the DAE into the computer memory, but is not written to disk.
        """
        self._set_pv_value(self._get_dae_pv_name("updaterun"), 1, wait=True)

    def post_update_check(self, verbose=False):
        """
        Checks the associated PV for errors after an update.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("updaterun"), "UPDATE")
        if verbose or self.verbose:
            self._print_verbose_messages()

    @require_runstate(['RUNNING', 'VETOING', 'WAITING', 'PAUSED'])
    def store_run(self):
        """
        Data loaded into memory by a previous update_run command is now written to disk.
        """
        self._set_pv_value(self._get_dae_pv_name("storerun"), 1, wait=True)

    def post_store_check(self, verbose=False):
        """
        Checks the associated PV for errors after a store.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("storerun"), "STORE")
        if verbose or self.verbose:
            self._print_verbose_messages()

    def snapshot_crpt(self, filename):
        """
        Save a snapshot of the CRPT.

        Args:
            filename - the name and location to save the file(s) to
        """
        self._set_pv_value(self._get_dae_pv_name("snapshot"), filename, wait=True)

    def post_snapshot_check(self, verbose=False):
        """
        Checks the associated PV for errors after a snapshot.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("snapshot"), "SNAPSHOTCRPT")
        if verbose or self.verbose:
            self._print_verbose_messages()

    @require_runstate(['RUNNING', 'VETOING', 'WAITING', 'PAUSING'])
    def pause_run(self, immediate=False):
        """
        Pause the current run.

        Args:
            immediate: pause immediately, without waiting for a period sequence to complete
        """
        if self.get_run_state() == "PAUSING" and not immediate:
            print("Please specify the 'immediate=True' flag to pause a run while in the PAUSING state")
            return

        print(("** Pausing Run {} at {}".format(self.get_run_number(), strftime("%H:%M:%S %d/%m/%y "))))

        if immediate:
            self._write_to_end_now_file(u"1")

        self._set_pv_value(self._get_dae_pv_name("pauserun"), 1, wait=True)

    def post_pause_check(self, verbose=False):
        """
        Checks the PAUSE PV for errors after pausing.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("pauserun"), "PAUSE")
        if verbose or self.verbose:
            self._print_verbose_messages()

    @require_runstate(['PAUSED'])
    def resume_run(self):
        """
        Resume the current run after it has been paused.
        """
        print(("** Resuming Run {} at {}".format(self.get_run_number(), strftime("%H:%M:%S %d/%m/%y "))))
        self._set_pv_value(self._get_dae_pv_name("resumerun"), 1, wait=True)

    def post_resume_check(self, verbose=False):
        """
        Checks the RESUME PV for errors after resuming.

        Args:
            verbose: whether to print verbosely
        """
        self._check_for_runstate_error(self._get_dae_pv_name("resumerun"), "RESUME")
        if verbose or self.verbose:
            self._print_verbose_messages()

    def get_run_state(self):
        """
        Gets the current state of the DAE.

        Note: this value can take a few seconds to update after a change of state.

        Returns:
            string: the current run state

        Raises:
            Exception: if cannot retrieve value
        """
        try:
            return self._get_pv_value(self._get_dae_pv_name("runstate"), to_string=True)
        except IOError:
            raise IOError("get_run_state: could not get run state")

    def get_run_number(self):
        """
        Gets the current run number.

        Returns:
            string: the current run number
        """
        return self._get_pv_value(self._get_dae_pv_name("runnumber"))

    def get_period_type(self):
        """
        Gets the period type.

        Returns:
            string: the period type
        """
        return self._get_pv_value(self._get_dae_pv_name("periodtype"))

    def get_period_seq(self):
        """
        Gets the period sequence.

        Returns:
            object: the period sequence
        """
        return self._get_pv_value(self._get_dae_pv_name("periodseq"))

    def get_period(self):
        """
        Gets  the current period number.

        Returns:
            int: the current period
        """
        return self._get_pv_value(self._get_dae_pv_name("period"))

    def get_num_periods(self):
        """
        Gets the number of periods.

        Returns:
            int: the number of periods
        """
        return self._get_pv_value(self._get_dae_pv_name("numperiods"))

    def set_period(self, period):
        """
        Change to the specified period.

        Args:
            period: the number of the period to change to

        Raises:
            IOError: if the DAE can not set the period to the given number.
        """
        run_state = self.get_run_state()
        if run_state == 'SETUP' or run_state == 'PAUSED':
            self._set_pv_value(self._get_dae_pv_name("period_sp"), period, wait=True)

            if self.api.get_pv_alarm(self._get_dae_pv_name("period_sp")) == "INVALID":
                raise IOError("You are trying to set an invalid period number! The number must be between 1 and "
                              "{}.".format(self.get_num_periods()))
        else:
            raise ValueError('Cannot change period whilst running')

    def get_uamps(self, period=False):
        """
        Returns the current number of micro-amp hours.

        Args:
            period: whether to return the micro-amp hours for the current period [optional]
        """
        if period:
            return self._get_pv_value(self._get_dae_pv_name("uampsperiod"))
        else:
            return self._get_pv_value(self._get_dae_pv_name("uamps"))

    def get_events(self):
        """
        Gets the total number of events for all the detectors.

        Returns:
            int: the total number of events
        """
        return self._get_pv_value(self._get_dae_pv_name("events"))

    def get_mevents(self):
        """
        Gets the total number of millions of events for all the detectors.

        Returns:
            float: the total number of millions of events
        """
        return self._get_pv_value(self._get_dae_pv_name("mevents"))

    def get_total_counts(self):
        """
        Gets the total counts for the current run.

        Returns:
            int: the total counts
        """
        return self._get_pv_value(self._get_dae_pv_name("totalcounts"))

    def get_good_frames(self, period=False):
        """
        Gets the current number of good frames.

        Args:
            period: whether to get for the current period only [optional]

        Returns:
            int: the number of good frames
        """
        if period:
            return self._get_pv_value(self._get_dae_pv_name("goodframesperiod"))
        else:
            return self._get_pv_value(self._get_dae_pv_name("goodframes"))

    def get_raw_frames(self, period=False):
        """
        Gets the current number of raw frames.

        Args:
            period: whether to get for the current period only [optional]

        Returns:
            int: the number of raw frames
        """
        if period:
            return self._get_pv_value(self._get_dae_pv_name("rawframesperiod"))
        else:
            return self._get_pv_value(self._get_dae_pv_name("rawframes"))

    def sum_all_dae_memory(self):
        """
        Gets the sum of the counts in the DAE.

        Returns:
            int: the sum
        """
        return self._get_pv_value(self._get_dae_pv_name("histmemory"))

    def get_memory_used(self):
        """
        Gets the DAE memory used.

        Returns:
            int: the memory used
        """
        return self._get_pv_value(self._get_dae_pv_name("memoryused"))

    def sum_all_spectra(self):
        """
        Returns the sum of all the spectra in the DAE.

        Returns:
            int: the sum of spectra
        """
        return self._get_pv_value(self._get_dae_pv_name("spectrasum"))

    def get_num_spectra(self):
        """
        Gets the number of spectra.

        Returns:
            int: the number of spectra
        """
        return self._get_pv_value(self._get_dae_pv_name("numspectra"))

    def get_rb_number(self):
        """
        Gets the RB number for the current run.

        Returns:
            string: the current RB number
        """
        return self._get_pv_value(self._get_dae_pv_name("rbnum"))

    def set_rb_number(self, rbno):
        """
        Set the RB number for the current run.

        Args:
            rbno (str): the new RB number
        """
        self._set_pv_value(self._get_dae_pv_name("rbnum_sp"), rbno)

    def get_title(self):
        """
        Gets the title for the current run.

        Returns
            string: the current title
        """
        return self._get_pv_value(self._get_dae_pv_name("title"), to_string=True)

    def set_title(self, title):
        """
        Set the title for the current/next run.

        Args:
            title: the title to set
        """
        self._set_pv_value(self._get_dae_pv_name("title_sp"), title, wait=True)

    def get_users(self):
        """
        Gets the users for the current run.

        Returns:
            string: the names
        """
        try:
            # Data comes as comma separated list
            raw = str(self._get_pv_value(self._get_dae_pv_name("users_dae_sp"), to_string=True))
            names_list = [x.strip() for x in raw.split(',')]
            if len(names_list) > 1:
                last = names_list.pop(-1)
                names = ", ".join(names_list)
                names += " and " + last
                return names
            else:
                # Will throw if empty - that is okay
                return names_list[0]
        except Exception:
            return ""

    def set_users(self, users):
        """
        Set the users for the current run.

        Args:
            users: the users as a comma-separated string
        """
        users = users.split(",") if users else []
        table_data = json.dumps([{"name": user.strip()} for user in users])
        # Send just the username and database server will clear the table if only user is set
        self._set_pv_value(self._get_dae_pv_name("users_table_sp"), compress_and_hex(table_data), True)

    def get_starttime(self):
        """
        Gets the start time for the current run.

        Returns
            string: the start time
        """
        return self._get_pv_value(self._get_dae_pv_name("starttime"))
    #@require_runstate([SETUP])
    def get_time_since_start(self, get_datetime):
        """
        Gets the time since start of the current run in seconds or in datetime

        Args:
            get_datetime (bool): If true return the value as a datetime object, otherwise return seconds (defaults to false)

        Returns
            integer: the time since start in seconds if get_daaetime is False
            datetime: the time since start in (Year-Month-Day  Hour:Minute:Second) format if get_datetime is True
        """

        current_time = datetime.now()

        datetime_object = datetime.strptime(self.get_starttime(), '%a %d-%b-%Y %H:%M:%S')
        time_since_start = current_time - datetime_object

        if get_datetime:
            print('\nTime since start in datetime:')
            return time_since_start
        else:
            print('\nTime since start in seconds:')
            return time_since_start.total_seconds()




