"""
Wrapping of channel access in genie_python
"""
from __future__ import absolute_import, print_function

from builtins import object
import threading

import six
from CaChannel import ca, CaChannel, CaChannelException
from threading import Event

from CaChannel._ca import AlarmSeverity, AlarmCondition, dbf_type_to_DBR_STS

from .utilities import waveform_to_string
from .channel_access_exceptions import UnableToConnectToPVException, InvalidEnumStringException, ReadAccessException, \
    WriteAccessException

# Monkey patch CaChannel with some additional functions until merged upstream
from genie_python.CaChannelPatch import replace_printf_handler, add_exception_event, _printf_callback,\
    _exception_callback
CaChannel.replace_printf_handler = replace_printf_handler
CaChannel.add_exception_event = add_exception_event
CaChannel._printf_callback = _printf_callback
CaChannel._exception_callback = _exception_callback

TIMEOUT = 15         # Default timeout for PV set/get
EXIST_TIMEOUT = 3    # Separate smaller timeout for pv_exists() and searchw() operations
CACHE = threading.local()
CACHE_LOCK = threading.RLock()


class CaChannelWrapper(object):
    """
    Wrap CA Channel access to give utilities methods for access in one place
    """
    errorLogFunc = None

    # noinspection PyPep8Naming
    @staticmethod
    def logError(message):
        """
        Log an error
        Args:
            message: message to log
        """
        if CaChannelWrapper.errorLogFunc is not None:
            try:
                CaChannelWrapper.errorLogFunc(message)
            except Exception:
                pass
        else:
            print("CAERROR: {}".format(message))

    # noinspection PyPep8Naming
    @staticmethod
    def printfHandler(message, user_args):
        """
        Callback used for CA printing messages.

        Args:
            message (string): Contains the results of the action.
            user_args (tuple): Contains any extra arguments supplied to the call.

        Returns:
            None.
        """
        CaChannelWrapper.logError("CAMessage: {}".format(message))

    # noinspection PyPep8Naming
    @staticmethod
    def CAExceptionHandler(epics_args, user_args):
        """
        Callback used for CA exception messages.

        Args:
            epics_args (dict): Contains the results of the action - see CA "struct exception_handler_args"
                                Available ones are: chid, type, count, state, op, ctx, file, lineNo
            user_args (dict): Contains any extra arguments supplied to the call.

        Returns:
            None.
        """
        CaChannelWrapper.logError("CAException: type={} state={} op={} file={} lineNo={}".format(
            epics_args['type'], epics_args['state'], epics_args['op'], epics_args['file'], epics_args['lineNo']))

    # noinspection PyPep8Naming
    @staticmethod
    def installHandlers(chan):
        """
        Installs callbacks for printf and exceptions.

        Args:
            chan: CaChannel instance

        Returns:
            None.
        """
        # We do a poll() so ca_context_create() gets called with arguments to enable preemptive callbacks
        # CaChannel itself delays creation of the context, so if we just installed the handlers now
        # we would get a default non-preemptive CA context created.
        chan.poll()
        chan.replace_printf_handler(CaChannelWrapper.printfHandler)
        chan.add_exception_event(CaChannelWrapper.CAExceptionHandler)

    # noinspection PyPep8Naming
    @staticmethod
    def putCB(epics_args, user_args):
        """
        Callback used for setting PV values.

        Args:
            epics_args (tuple): Contains the results of the action.
            user_args (tuple): Contains any extra arguments supplied to the call.

        Returns:
            None.
        """
        user_args[0].set()

    @staticmethod
    def set_pv_value(name, value, wait=False, timeout=TIMEOUT):
        """
        Set the PV to a value.

        When getting a PV value this call should be used, unless there is a special requirement.

        Args:
            name (string): The PV name.
            value: The value to set.
            wait (bool, optional): Wait for the value to be set before returning.
            timeout (optional): How long to wait for the PV to connect etc.

        Returns:
            None.

        Raises:
            UnableToConnectToPVException: If cannot connect to PV.
            WriteAccessException: If write access is denied.
            InvalidEnumStringException: If the PV is an enum and the string value supplied is not a valid enum value.
        """
        chan = CaChannelWrapper.get_chan(name)
        chan.setTimeout(timeout)

        # Validate user input and format accordingly for mbbi/bi records
        value = CaChannelWrapper.check_for_enum_value(value, chan, name)

        if not chan.write_access():
            raise WriteAccessException(name)
        if wait:
            ftype = chan.field_type()
            ecount = chan.element_count()
            event = Event()
            chan.array_put_callback(value, ftype, ecount, CaChannelWrapper.putCB, event)
            CaChannelWrapper._wait_for_pend_io_event(chan, event, timeout=None)
        else:
            # putw() flushes send buffer, but doesn't wait for a CA completion callback
            # Write value to PV, or produce error
            chan.putw(value)

    @staticmethod
    def get_chan(name, timeout=EXIST_TIMEOUT):
        """
        Gets a channel based on a channel name, from the cache if it exists.

        Args:
            name: the name of the channel to get
            timeout: timeout to set on channel

        Returns:
            CaChannel object representing the channel

        Raises:
            UnableToConnectToPVException if it was unable to connect to the channel
        """
        with CACHE_LOCK:
            try:
                pv_map = CACHE.map
            except AttributeError:
                pv_map = CACHE.map = {}

            if name in list(pv_map.keys()) and pv_map[name].state() == ca.cs_conn:
                chan = pv_map[name]
            else:
                chan = CaChannel(name)
                # noinspection PyTypeChecker
                CaChannelWrapper.installHandlers(chan)
                chan.setTimeout(timeout)
                # Try to connect - throws if cannot
                CaChannelWrapper.connect_to_pv(chan)
                pv_map[name] = chan
        return chan

    @staticmethod
    def get_pv_value(name, to_string=False, timeout=TIMEOUT):
        """
        Get the current value of the PV.

        Args:
            name (name): The PV.
            to_string (bool, optional): Whether to convert the value to a string.
            timeout (optional): How long to wait for the PV to connect etc.

        Returns:
            The PV value.

        Raises:
            UnableToConnectToPVException: If cannot connect to PV.
            ReadAccessException: If read access is denied.
        """
        chan = CaChannelWrapper.get_chan(name)
        chan.setTimeout(timeout)
        if not chan.read_access():
            raise ReadAccessException(name)
        ftype = chan.field_type()
        if ca.dbr_type_is_ENUM(ftype) or ca.dbr_type_is_CHAR(ftype) or ca.dbr_type_is_STRING(ftype):
            to_string = True
        if to_string:
            if ca.dbr_type_is_ENUM(ftype) or ca.dbr_type_is_STRING(ftype):
                value = chan.getw(ca.DBR_STRING)
            else:
                # If we get a numeric using ca.DBR_CHAR the value still comes back as a numeric
                # In other words, it does not get cast to char
                value = chan.getw(ca.DBR_CHAR)
            # Could see if the element count is > 1 instead
            if isinstance(value, list):
                return waveform_to_string(value)
            else:
                return str(value)
        else:
            return chan.getw()

    @staticmethod
    def pv_exists(name, timeout=EXIST_TIMEOUT):
        """
        See if the PV exists.

        Args:
            name (string): The PV name.
            timeout(optional): How long to wait for the PV to "appear".

        Returns:
            True if exists, otherwise False.
        """
        try:
            chan = CaChannelWrapper.get_chan(name, timeout)
            CaChannelWrapper.connect_to_pv(chan)
            return True
        except UnableToConnectToPVException:
            return False

    @staticmethod
    def connect_to_pv(ca_channel):
        """
        Connects to the PV.

        Args:
            ca_channel (CaChannel): The channel to connect to.

        Returns:
            None.

        Raises:
            UnableToConnectToPVException: If cannot connect to PV.
        """
        event = Event()
        try:
            ca_channel.search_and_connect(None, CaChannelWrapper.putCB, event)
        except CaChannelException as e:
            raise UnableToConnectToPVException(ca_channel.name(), e)

        CaChannelWrapper._wait_for_pend_io_event(ca_channel, event, timeout=ca_channel.getTimeout())

        if not event.is_set():
            raise UnableToConnectToPVException(ca_channel.name(), "Connection timeout")

    @staticmethod
    def check_for_enum_value(value, chan, name):
        """
        Check for string input for MBBI/BI records and replace with the equivalent index value.

        Args:
            value: The PV value.
            chan (CaChannel): The channel access channel.
            name (string): The name of the channel.

        Returns:
            Index value of enum, if the record is mbbi/bi. Otherwise, returns unmodified value.

        Raises:
            InvalidEnumStringException: If the string supplied is not a valid enum value.
        """
        # If PV is MBBI/BI type, search list of enum values and iterate to find a match
        # Use six to check string type as it works for Python 2 and 3.
        if ca.dbr_type_is_ENUM(chan.field_type()) and isinstance(value, six.string_types):
            chan.array_get(ca.DBR_CTRL_ENUM)
            chan.pend_io()
            channel_properties = chan.getValue()
            for index, enum_value in enumerate(channel_properties["pv_statestrings"]):
                if enum_value.lower() == value.lower():
                    # Replace user input with enum index value
                    return index
            # If the string entered isn't valid then throw
            raise InvalidEnumStringException(name, channel_properties["pv_statestrings"])

        return value

    @staticmethod
    def add_monitor(name, call_back_function, link_alarm_on_disconnect=True):
        """
        Add a callback to a pv which responds on a monitor (i.e. value change). This currently only tested for numbers.
        Args:
            name: name of the pv
            call_back_function: the callback function, arguments are value,
                alarm severity (CaChannel._ca.AlarmSeverity), alarm status (CaChannel._ca.AlarmCondition)
            link_alarm_on_disconnect: if set to True, a link alarm is sent with the last value when the pv disconnects
        """
        chan = CaChannelWrapper.get_chan(name)
        if not chan.read_access():
            raise ReadAccessException(name)
        field_type = chan.field_type()
        # if this is an enum field return the monitor as a string (not an int)
        if ca.dbr_type_is_ENUM(field_type):
            field_type = ca.DBR_STRING
        # Modify the field type from monitor the value to includes the alarm severity and status
        field_type_with_status = dbf_type_to_DBR_STS(field_type)

        def _process_call_back(epics_args, _):
            value = epics_args.get('pv_value', None)
            chan.last_value = value
            call_back_function(value,
                               epics_args.get('pv_severity', AlarmSeverity.No),
                               epics_args.get('pv_status', AlarmCondition.No))

        def _connection_callback(epics_args, _):
            if epics_args[1] == ca.CA_OP_CONN_DOWN:
                call_back_function(chan.last_value,
                                   AlarmSeverity.Invalid,
                                   AlarmCondition.Link)

        chan.add_masked_array_event(field_type_with_status, count=None, mask=None, callback=_process_call_back)
        if link_alarm_on_disconnect:
            chan.change_connection_event(_connection_callback)

    @staticmethod
    def poll():
        """
        Flush the send buffer and execute any outstanding background activity for all connected pvs.
        NB Connected pv is one which is in the cache
        """
        # pick first channel and perform flush on it.
        try:
            for key, value in CACHE.map.items():
                value.poll()
                break
        except AttributeError:
            # There are no channels so we do not need to poll them
            pass

    @staticmethod
    def _wait_for_pend_io_event(chan, event, timeout=None, interval=0.1):
        """
        Wait for a pending even to occur in short intervals to allow for keyboard interrupt; has possible timeout for
        maximum time to wait

        Args:
            chan: channel to use
            event: the event posted by the callback to wait for
            timeout: maximum time to wait for the event, None means wait forever.
            interval: time to poll channel access
        """

        time_elapsed = 0

        while True:
            try:
                # Should use overall timeout somehow? need to make sure it is long enough for all requests to complete
                # though did try flush_io() followed by event.wait(1.0) inside the loop for set pv, but a send got
                # missed. Looks like pend_event() / pend_io() / poll() is needed
                chan.pend_io(interval)
            except CaChannelException as e:
                if e.status != ca.ECA_TIMEOUT:
                    raise

            time_elapsed += interval
            if event.wait(interval) or (timeout is not None and time_elapsed >= timeout):
                break
