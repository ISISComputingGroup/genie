# This file is part of the ISIS IBEX application.
# Copyright (C) 2012-2016 Science & Technology Facilities Council.
# All rights reserved.
#
# This program is distributed in the hope that it will be useful.
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v1.0 which accompanies this distribution.
# EXCEPT AS EXPRESSLY SET FORTH IN THE ECLIPSE PUBLIC LICENSE V1.0, THE PROGRAM
# AND ACCOMPANYING MATERIALS ARE PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND.  See the Eclipse Public License v1.0 for more details.
#
# You should have received a copy of the Eclipse Public License v1.0
# along with this program; if not, you can obtain a copy from
# https://www.eclipse.org/org/documents/epl-v10.php or
# http://opensource.org/licenses/eclipse-1.0.php

from __future__ import absolute_import
import unittest
from mock import MagicMock, patch
from genie_python.genie_dae import Dae
from genie_python.genie_change_cache import ChangeCache
from genie_python.utilities import compress_and_hex
import six

DAE_SETTINGS_XML = """<Cluster>
    <Name>Data Acquisition</Name>
    <NumElts>4</NumElts>
    <I32>
        <Name>Monitor Spectrum</Name>
        <Val>5</Val>
    </I32>
    <DBL>
        <Name>from</Name>
        <Val>12000</Val>
    </DBL>
    <String>
        <Name>Wiring Table</Name>
        <Val>C:/Instrument/Settings/config/NDW1801/configurations/tables/wiring128.dat</Val>
    </String>
    <EW>
        <Name>DAETimingSource</Name>
        <Choice>ISIS</Choice>
        <Choice>Internal Test Clock</Choice>
        <Choice>SMP</Choice>
        <Choice>Muon Cerenkov</Choice>
        <Choice>Muon MS</Choice>
        <Choice>ISIS (first TS1)</Choice>
        <Choice>TS1 Only</Choice>
        <Val>2</Val>
    </EW>
</Cluster>"""

TCB_SETTINGS_XML = """<Cluster>
        <Name>Time Channels</Name>
        <NumElts>3</NumElts>
        <DBL>
                <Name>TR1 From 1</Name>
                <Val>0</Val>
        </DBL>
        <U16>
                <Name>TR1 In Mode 2</Name>
                <Val>0</Val>
        </U16>
        <String>
                <Name>Time Channel File</Name>
                <Val>C:/Instrument/Settings/config/NDW1801/configurations/tcb/RCPTT_TCB_1.dat</Val>
        </String>
</Cluster>"""

PERIOD_SETTINGS_XML = """<Cluster>
    <Name>Hardware Periods</Name>
    <NumElts>38</NumElts>
    <EW>
        <Name>Period Setup Source</Name>
        <Choice>Use Parameters Below</Choice>
        <Choice>Read from file</Choice>
        <Val>0</Val>
    </EW>
    <String>
        <Name>Period File</Name>
        <Val></Val>
    </String>
    <I32>
        <Name>Number Of Software Periods</Name>
        <Val>1000</Val>
    </I32>
    <DBL>
        <Name>Hardware Period Sequences</Name>
        <Val>0</Val>
    </DBL>
</Cluster>"""

YC_RETURN = [0, 1, 2, 3]
Y_RETURN = [1, 2, 3, 4]
YC_NORD_RETURN = 2
Y_NORD_RETURN = 3
X_RETURN = [2, 3, 4, 5]


class TestGenieDAE(unittest.TestCase):
    def setUp(self):
        self.api = MagicMock()
        self.dae = Dae(self.api, "")

        self.change_cache = ChangeCache()
        self.dae.change_cache = self.change_cache

    @patch.dict("genie_python.genie_dae.DAE_PVS_LOOKUP", {"period_rbv": "DAE:PERIOD:RBV"})
    def test_GIVEN_lower_case_DAE_name_WHEN_get_dae_pv_name_THEN_get_correct_pv_name(self):
        self.assertEqual(self.dae._get_dae_pv_name("period_rbv"), "DAE:PERIOD:RBV")

    @patch.dict("genie_python.genie_dae.DAE_PVS_LOOKUP", {"period_rbv": "DAE:PERIOD:RBV"})
    def test_GIVEN_sentence_case_DAE_name_WHEN_get_dae_pv_name_THEN_get_correct_pv_name(self):
        self.assertEqual(self.dae._get_dae_pv_name("Period_Rbv"), "DAE:PERIOD:RBV")

    def test_GIVEN_pv_name_WHEN_no_inst_prefix_THEN_get_get_unchanged_pv_name(self):
        self.dae.inst_prefix = None
        self.assertEqual(self.dae._prefix_pv_name("DAE:PERIOD:SP"), "DAE:PERIOD:SP")

    def test_GIVEN_pv_name_WHEN_has_inst_prefix_THEN_get_get_full_pv_name(self):
        self.dae.inst_prefix = "TE:NDW1801:"
        self.assertEqual(self.dae._prefix_pv_name("DAE:PERIOD:SP"), "TE:NDW1801:DAE:PERIOD:SP")

    def test_WHEN_create_tcb_string_with_no_changes_and_log_binning_THEN_bin_setting_string_returned(self):
        self.dae.in_change = True
        ans = self.dae._create_tcb_return_string(None, None, None, True)

        self.assertEqual(ans, "Setting TCB to LOG binning")

    def test_WHEN_create_tcb_string_with_no_changes_and_not_log_binning_THEN_bin_setting_string_returned(self):
        self.dae.in_change = True
        ans = self.dae._create_tcb_return_string(None, None, None, False)

        self.assertEqual(ans, "Setting TCB to LINEAR binning")

    def test_WHEN_create_tcb_string_with_low_and_high_changed_THEN_range_changed_string_returned(self):
        self.dae.in_change = True
        new_low = 0
        new_high = 10
        ans = self.dae._create_tcb_return_string(new_low, new_high, None, True)

        self.assertEqual(ans, "Setting TCB range {} to {} (LOG binning)".format(new_low, new_high))

    def test_WHEN_create_tcb_string_with_only_low_changed_THEN_low_limit_changed_string_returned(self):
        self.dae.in_change = True
        new_low = 0
        ans = self.dae._create_tcb_return_string(new_low, None, None, True)

        self.assertEqual(ans, "Setting TCB low limit to {} (LOG binning)".format(new_low))

    def test_WHEN_create_tcb_string_with_only_high_changed_THEN_high_limit_changed_string_returned(self):
        self.dae.in_change = True
        new_high = 10
        ans = self.dae._create_tcb_return_string(None, new_high, None, True)

        self.assertEqual(ans, "Setting TCB high limit to {} (LOG binning)".format(new_high))

    def test_WHEN_create_tcb_string_with_only_step_changed_THEN_step_changed_string_returned(self):
        self.dae.in_change = True
        new_step = 10
        ans = self.dae._create_tcb_return_string(None, None, new_step, False)

        self.assertEqual(ans, "Setting TCB step {} (LINEAR binning)".format(new_step))

    def test_WHEN_create_tcb_string_with_all_changed_THEN_all_changed_string_returned(self):
        self.dae.in_change = True
        new_low = 0
        new_high = 10
        new_step = 2
        ans = self.dae._create_tcb_return_string(new_low, new_high, new_step, True)

        self.assertEqual(ans, "Setting TCB range {} to {} step {} (LOG binning)".format(new_low, new_high, new_step))

    def test_WHEN_create_tcb_string_with_low_and_step_changed_THEN_low_limit_and_step_string_returned(self):
        self.dae.in_change = True
        new_low = 0
        new_step = 2
        ans = self.dae._create_tcb_return_string(new_low, None, new_step, True)

        self.assertEqual(ans, "Setting TCB low limit to {} step {} (LOG binning)".format(new_low, new_step))

    def test_WHEN_create_tcb_string_with_high_and_step_changed_THEN_high_limit_and_step_string_returned(self):
        self.dae.in_change = True
        new_high = 10
        new_step = 2
        ans = self.dae._create_tcb_return_string(None, new_high, new_step, True)

        self.assertEqual(ans, "Setting TCB high limit to {} step {} (LOG binning)".format(new_high, new_step))

    def test_GIVEN_change_not_started_WHEN_change_finished_called_THEN_exception_thrown(self):
        self.assertRaises(Exception, self.dae.change_finish)

    def test_GIVEN_in_running_state_and_period_pv_no_alarm_WHEN_set_period_called_THEN_value_error_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="RUNNING")
        self.dae.api.get_alarm_of_pv = MagicMock(return_value="NO_ALARM")

        self.assertRaises(ValueError, self.dae.set_period, 1)

    def test_GIVEN_in_paused_state_and_period_pv_no_alarm_WHEN_set_period_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="PAUSED")
        self.dae.api.get_alarm_of_pv = MagicMock(return_value="NO_ALARM")

        self.dae.set_period(1)

    def test_GIVEN_in_setup_state_and_period_pv_invalid_alarm_WHEN_set_period_called_THEN_io_error_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")
        self.dae.api.get_alarm_of_pv = MagicMock(return_value="INVALID")

        self.assertRaises(IOError, self.dae.set_period, -1)

    def test_GIVEN_in_setup_state_and_number_of_periods_pv_in_invalid_alarm_WHEN_change_finish_called_THEN_exception_thrown(self):

        def get_mock_data(pv_name, to_string):
            mock_data = {
                "DAE:DAESETTINGS": DAE_SETTINGS_XML,
                "DAE:TCBSETTINGS": compress_and_hex(TCB_SETTINGS_XML),
                "DAE:HARDWAREPERIODS": PERIOD_SETTINGS_XML
            }
            return mock_data[pv_name]

        self.dae.api.get_pv_value = get_mock_data
        self.dae.api.set_pv_value = MagicMock(return_value=None)
        self.dae.change_cache.change_period_settings = MagicMock(return_value=True)
        self.dae.api.get_alarm_of_pv = MagicMock(return_value="INVALID")
        self.dae.in_change = True
        self.dae.in_transition = MagicMock(return_value=False)
        self.dae.get_run_state = MagicMock(return_value="SETUP")

        self.assertRaises(IOError, self.dae.change_finish)

    def test_GIVEN_in_setup_state_and_number_of_periods_pv_no_alarm_WHEN_change_finish_called_THEN_exception_thrown(self):

        def get_mock_data(pv_name, to_string):
            mock_data = {
                "DAE:DAESETTINGS": DAE_SETTINGS_XML,
                "DAE:TCBSETTINGS": compress_and_hex(TCB_SETTINGS_XML),
                "DAE:HARDWAREPERIODS": PERIOD_SETTINGS_XML
            }
            return mock_data[pv_name]

        self.dae.api.get_pv_value = get_mock_data
        self.dae.api.set_pv_value = MagicMock(return_value=None)
        self.dae.change_cache.change_period_settings = MagicMock(return_value=True)
        self.dae.api.get_alarm_of_pv = MagicMock(return_value="NO_ALARM")
        self.dae.in_change = True
        self.dae.in_transition = MagicMock(return_value=False)
        self.dae.get_run_state = MagicMock(return_value="SETUP")

        self.dae.change_finish()

    def check_all_vetos(self, set):
        """
        Helper function to check that all vetos are set or not.
        """
        for k, d in six.iteritems(self.change_cache.__dict__):
            if k.endswith('veto') and 'fermi' not in k:
                self.assertEqual(set, d, "{} incorrect".format(k))

    def set_all_vetos(self, set):
        """
        Helper function to set all vetos to a value by the 'backdoor'.
        """
        for k in self.change_cache.__dict__.keys():
            if k.endswith('veto') and 'fermi' not in k:
                self.change_cache.__dict__[k] = set

    def test_WHEN_change_vetos_called_with_no_arguments_THEN_nothing_happens(self):
        self.dae.change_vetos()

        self.check_all_vetos(None)

    def test_WHEN_change_vetos_called_with_smp_true_THEN_smp_veto_set_to_1(self):
        self.dae.in_change = True
        self.dae.change_vetos(smp=True)
        self.assertEqual(1, self.change_cache.smp_veto)

    def test_WHEN_change_vetos_called_with_smp_true_incorrect_case_THEN_smp_veto_set_to_1(self):
        self.dae.in_change = True
        self.dae.change_vetos(sMP=True)
        self.assertEqual(1, self.change_cache.smp_veto)

    def test_WHEN_change_vetos_called_with_smp_false_THEN_smp_veto_set_to_0(self):
        self.dae.in_change = True
        self.dae.change_vetos(smp=False)
        self.assertEqual(0, self.change_cache.smp_veto)

    def test_WHEN_change_vetos_called_with_smp_false_THEN_smp_veto_set_to_0(self):
        self.dae.in_change = True
        self.dae.change_vetos(smp=False)
        self.assertEqual(0, self.change_cache.smp_veto)

    def test_WHEN_change_vetos_called_with_non_boolean_value_THEN_exception_raised_and_veto_not_set(self):
        self.assertRaises(Exception, self.dae.change_vetos, smp="test")
        self.assertEqual(None, self.change_cache.smp_veto)

        self.assertRaises(Exception, self.dae.change_vetos, hz50="test")
        self.assertEqual(None, self.change_cache.hz50_veto)

    def test_WHEN_change_vetos_called_with_clearall_true_THEN_all_vetos_cleared(self):
        self.dae.in_change = True
        self.set_all_vetos(1)
        self.check_all_vetos(1)

        self.dae.change_vetos(clearall=True)
        self.check_all_vetos(0)

    def test_WHEN_change_vetos_called_with_clearall_false_THEN_nothing_happens(self):
        self.dae.in_change = True
        self.set_all_vetos(1)
        self.check_all_vetos(1)

        self.dae.change_vetos(clearall=False)
        self.check_all_vetos(1)

    def test_WHEN_change_vetos_called_with_unknown_veto_THEN_exception_thrown(self):
        self.assertRaises(Exception, self.dae.change_vetos, bad_veto=True)

    def test_WHEN_fifo_veto_enabled_at_runtime_THEN_correct_PV_set_with_correct_value(self):
        self.dae.change_vetos(fifo=True)

        func = self.api.set_pv_value
        self.assertTrue(func.called)
        func.assert_called_with("DAE:VETO:ENABLE:SP", "FIFO", False)

    def test_WHEN_fifo_veto_disabled_at_runtime_THEN_correct_PV_set_with_correct_value(self):
        self.dae.change_vetos(fifo=False)

        func = self.api.set_pv_value
        self.assertTrue(func.called)
        func.assert_called_with("DAE:VETO:DISABLE:SP", "FIFO", False)

    def test_WHEN_clearing_all_vetoes_THEN_fifo_is_unaffected(self):
        self.dae.in_change = True
        self.dae.change_vetos(clearall=True)

        func = self.api.set_pv_value
        # clearall should not affect FIFO so none of the PVs should be set.
        func.assert_not_called()

    def test_GIVEN_in_setup_state_WHEN_begin_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")

        self.dae.begin_run()

    def test_GIVEN_in_setup_state_WHEN_abort_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")

        with self.assertRaises(Exception):
            self.dae.abort_run()

    def test_GIVEN_in_setup_state_WHEN_end_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")

        with self.assertRaises(Exception):
            self.dae.end_run()

    def test_GIVEN_in_setup_state_WHEN_store_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")

        with self.assertRaises(Exception):
            self.dae.store_run()

    def test_GIVEN_in_setup_state_WHEN_pause_run_called_THEN__exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")

        with self.assertRaises(Exception):
            self.dae.pause_run()

    def test_GIVEN_in_setup_state_WHEN_resume_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")

        with self.assertRaises(Exception):
            self.dae.resume_run()

    def test_GIVEN_in_running_state_WHEN_begin_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="RUNNING")

        with self.assertRaises(Exception):
            self.dae.begin_run()

    def test_GIVEN_in_running_state_WHEN_abort_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="RUNNING")

        self.dae.abort_run()

    def test_GIVEN_in_running_state_WHEN_end_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="RUNNING")

        self.dae.end_run()

    def test_GIVEN_in_running_state_WHEN_store_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="RUNNING")

        self.dae.store_run()

    def test_GIVEN_in_running_state_WHEN_pause_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="RUNNING")

        self.dae.pause_run()

    def test_GIVEN_in_running_state_WHEN_resume_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="RUNNING")

        with self.assertRaises(Exception):
            self.dae.resume_run()

    def test_GIVEN_in_paused_state_WHEN_begin_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="PAUSED")

        with self.assertRaises(Exception):
            self.dae.begin_run()

    def test_GIVEN_in_paused_state_WHEN_abort_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="PAUSED")

        self.dae.abort_run()

    def test_GIVEN_in_paused_state_WHEN_end_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="PAUSED")

        self.dae.end_run()

    def test_GIVEN_in_paused_state_WHEN_store_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="PAUSED")

        self.dae.store_run()

    def test_GIVEN_in_paused_state_WHEN_pause_run_called_THEN_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="PAUSED")

        with self.assertRaises(Exception):
            self.dae.pause_run()

    def test_GIVEN_in_paused_state_WHEN_resume_run_called_THEN_no_exception_thrown(self):
        self.dae.api.get_pv_value = MagicMock(return_value="PAUSED")

        self.dae.resume_run()

    def test_GIVEN_simulation_mode_WHEN_begin_run_THEN_user_is_warned(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")
        self.dae.get_simulation_mode = MagicMock(return_value=True)
        mock_warning = MagicMock()
        self.dae.simulation_mode_warning = mock_warning
        self.dae.begin_run()

        mock_warning.assert_called_once()

    def test_GIVEN_not_in_simulation_mode_WHEN_begin_run_THEN_user_is_warned(self):
        self.dae.api.get_pv_value = MagicMock(return_value="SETUP")
        self.dae.get_simulation_mode = MagicMock(return_value=False)
        mock_warning = MagicMock()
        self.dae.simulation_mode_warning = mock_warning
        self.dae.begin_run()

        mock_warning.assert_not_called()

    def get_y_or_yc_pv_value(self, pv, _):
        if "X" in pv:
            return X_RETURN
        elif "YC.NORD" in pv:
            return YC_NORD_RETURN
        elif "Y.NORD" in pv:
            return Y_NORD_RETURN
        elif "YC" in pv:
            return YC_RETURN
        else:
            return Y_RETURN

    def test_WHEN_get_spectrum_dist_true_THEN_default_returns_regular_counts(self):
        self.api.get_pv_value = MagicMock(side_effect=self.get_y_or_yc_pv_value)
        spectrum = self.dae.get_spectrum(1, 1, True)
        self.assertEquals(spectrum["signal"], Y_RETURN[:Y_NORD_RETURN], "Should return value of get_spectrum_y")
        self.assertEquals(len(spectrum["signal"]), len(spectrum["time"]), "Should be the same length")
        self.assertEquals(spectrum["mode"], "distribution", "Should return 'distribution'")

    def test_WHEN_get_spectrum_dist_false_THEN_default_returns_pure_counts(self):
        self.api.get_pv_value = MagicMock(side_effect=self.get_y_or_yc_pv_value)
        spectrum = self.dae.get_spectrum(1, 1, False)
        self.assertEquals(spectrum["signal"], YC_RETURN[:YC_NORD_RETURN], "Should return value of get_spectrum_yc")
        self.assertEquals(len(spectrum["signal"])+1, len(spectrum["time"]), "x_size should be one larger than y_size")
        self.assertEquals(spectrum["mode"], "non-distribution", "should return 'non-distribution'")
        
