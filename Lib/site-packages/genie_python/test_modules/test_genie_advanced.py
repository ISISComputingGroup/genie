# This file is part of the ISIS IBEX application.
# Copyright (C) 2012-2016 Science & Technology Facilities Council.
# All rights reserved.
#
# This program is distributed in the hope that it will be useful.
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v1.0 which accompanies this distribution.
# EXCEPT AS EXPRESSLY SET FORTH IN THE ECLIPSE PUBLIC LICENSE V1.0, THE PROGRAM
# AND ACCOMPANYING MATERIALS ARE PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND.  See the Eclipse Public License v1.0 for more details.
#
# You should have received a copy of the Eclipse Public License v1.0
# along with this program; if not, you can obtain a copy from
# https://www.eclipse.org/org/documents/epl-v10.php or
# http://opensource.org/licenses/eclipse-1.0.php
from __future__ import absolute_import

import datetime
import unittest

from hamcrest import assert_that, raises, calling
from mock import patch, call, DEFAULT

from genie_python.genie_advanced import get_exp_data
from parameterized import parameterized


class TestGetExperimentData(unittest.TestCase):

    def setUp(self):
        patcher = patch('genie_python.genie_advanced.SQLAbstraction')
        self.addCleanup(patcher.stop)
        self.mock_sql = patcher.start()

        # Get the core function (without decorators)
        self.get_exp_data = get_exp_data.__wrapped__

    def tearDown(self):
        pass

    @parameterized.expand([
        (None, None, None, "SELECT * FROM `experimentteams` ORDER BY experimentID DESC"),
        (123, None, None, "SELECT * FROM `experimentteams` WHERE experimentID LIKE '%%s%' ORDER BY experimentID DESC"),
        (
            None, "name", None,
            "SELECT * FROM `experimentteams` WHERE userID = %s ORDER BY experimentID DESC"
        ),
        (
            None, None, "role",
            "SELECT * FROM `experimentteams` WHERE roleID = %s ORDER BY experimentID DESC"
        ),
        (
            123, "user", None,
            "SELECT * FROM `experimentteams` WHERE experimentID LIKE '%%s%' AND userID = %s ORDER BY experimentID DESC"
        ),
        (
            123, None, "role",
            "SELECT * FROM `experimentteams` WHERE experimentID LIKE '%%s%' AND roleID = %s ORDER BY experimentID DESC"
        ),
        (
            None, "name", "role",
            "SELECT * FROM `experimentteams` WHERE userID = %s AND roleID = %s ORDER BY experimentID DESC"
        ),
        (
            123, "name", "role",
            "SELECT * FROM `experimentteams` WHERE experimentID LIKE '%%s%' AND userID = %s AND roleID = %s "
            "ORDER BY experimentID DESC"
        )
    ])
    def test_GIVEN_args_WHEN_preparing_statement_THEN_correct_sql_statement(self, rb_no, user, role, sql):
        # Arrange
        args, calls, return_values = ([] for i in range(3))

        if rb_no is not None:
            args.append(rb_no)

        # If user and/or role provided, add calls for ID lookup and the returned values
        if user is not None:
            calls.append(call(command='SELECT userID FROM `user` WHERE name = %s', is_query=True,
                              bound_variables=(user,)))
            return_values.append(1)
            args.append(1)
        if role is not None:
            calls.append(call(command='SELECT roleID FROM `role` WHERE name = %s', is_query=True,
                              bound_variables=(role,)))
            return_values.append(2)
            args.append(2)

        # Prepare the list of expected calls
        params = tuple(args)
        calls.append(call(command=sql, is_query=True, bound_variables=params))

        # To avoid StopIteration errors, tests will still work without this but exceptions will be printed
        return_values.extend(
            [[('111', 1, 3, datetime.datetime(2020, 9, 15, 8, 30))], "user_name", "role_name", "duration"]
        )

        self.mock_sql().execute_command.side_effect = iter(return_values)

        # Act
        self.get_exp_data(rb=rb_no, user=user, role=role)

        # Assert
        self.mock_sql().execute_command.assert_has_calls(calls, any_order=False)

    @parameterized.expand([
        (None, None, None, False),
        (1, 'a', 'b', False),
        ('a', None, None, True),
        (None, 1, None, True),
        (None, None, 1, True),
        ('a', 1, 1, True)
    ])
    def test_GIVEN_wrong_type_WHEN_checking_args_THEN_error_raised(self, rb_no, user, role, err_expected):
        # Arrange
        self.mock_sql().execute_command.return_value = None

        # Act & Assert
        if err_expected is True:
            assert_that(calling(self.get_exp_data).with_args(rb_no, user, role), raises(TypeError))

    @parameterized.expand([
        (
            [
                ('111', 1, 3, datetime.datetime(2020, 9, 15, 8, 30)),
                ('212', 2, 3, datetime.datetime(2020, 9, 8, 8, 30)),
                ('765', 3, 1, datetime.datetime(2020, 10, 8, 8, 30)),
                ('765', 4, 3, datetime.datetime(2020, 10, 8, 8, 30)),
                ('887', 5, 1, datetime.datetime(2020, 9, 18, 8, 30)),
                ('887', 6, 3, datetime.datetime(2020, 9, 18, 8, 30)),
                ('912', 7, 1, datetime.datetime(2020, 9, 11, 8, 30)),
                ('912', 8, 3, datetime.datetime(2020, 9, 11, 8, 30))
            ],
            [
                'Experiment Data Search Results:',
                'Experiment RB number: 111 | User: user_1_name | Role: role_3_name | Start date: 2020-09-15 08:30:00'
                ' | Duration: duration_111',
                'Experiment RB number: 212 | User: user_2_name | Role: role_3_name | Start date: 2020-09-08 08:30:00'
                ' | Duration: duration_212',
                'Experiment RB number: 765 | User: user_3_name | Role: role_1_name | Start date: 2020-10-08 08:30:00'
                ' | Duration: duration_765',
                'Experiment RB number: 765 | User: user_4_name | Role: role_3_name | Start date: 2020-10-08 08:30:00'
                ' | Duration: duration_765',
                'Experiment RB number: 887 | User: user_5_name | Role: role_1_name | Start date: 2020-09-18 08:30:00'
                ' | Duration: duration_887',
                'Experiment RB number: 887 | User: user_6_name | Role: role_3_name | Start date: 2020-09-18 08:30:00'
                ' | Duration: duration_887',
                'Experiment RB number: 912 | User: user_7_name | Role: role_1_name | Start date: 2020-09-11 08:30:00'
                ' | Duration: duration_912',
                'Experiment RB number: 912 | User: user_8_name | Role: role_3_name | Start date: 2020-09-11 08:30:00'
                ' | Duration: duration_912'
            ]
        ),
        (
            [('111', 1, 3, datetime.datetime(2020, 9, 15, 8, 30))],
            [
                'Experiment Data Search Results:',
                'Experiment RB number: 111 | User: user_1_name | Role: role_3_name | Start date: 2020-09-15 08:30:00'
                ' | Duration: duration_111'
            ]
        ),
        (
            None, ['Found no experiments that match the given criteria (RB: Any, User: Any, Role: Any).\n']
        )
    ])
    @patch('sys.stderr')
    @patch('builtins.print')
    def test_GIVEN_records_WHEN_get_exp_data_THEN_correct_exp_data_printed(self, records, result, m_print, m_err):
        # Arrange
        def sql_return_values(*args, **kwargs):
            if kwargs['command'] == "SELECT name FROM `user` WHERE userID = %s":
                return f'user_{kwargs["bound_variables"][0]}_name'
            elif kwargs['command'] == "SELECT name FROM `role` WHERE roleID = %s":
                return f'role_{kwargs["bound_variables"][0]}_name'
            elif kwargs['command'] == "SELECT duration FROM `experiment` WHERE experimentID = %s":
                return f'duration_{kwargs["bound_variables"][0]}'
            elif "SELECT * FROM `experimentteams`" in kwargs['command']:
                return records
            else:
                return DEFAULT

        self.mock_sql().execute_command.side_effect = sql_return_values

        calls = [call(x) for x in result]

        # Act
        self.get_exp_data()

        # Assert
        if records is not None:
            m_print.assert_has_calls(calls, any_order=False)
        else:
            m_err.assert_has_calls([call.write(x) for x in result], any_order=False)

    @parameterized.expand([
        (
            [
                ('1', 1, 1, datetime.datetime(2020, 9, 15, 8, 30)),
                ('22', 2, 2, datetime.datetime(2020, 9, 15, 8, 30)),
                ('332', 3, 2, datetime.datetime(2020, 9, 15, 8, 30)),
                ('4413', 1, 3, datetime.datetime(2020, 9, 15, 8, 30)),
                ('167', 6, 7, datetime.datetime(2020, 9, 15, 8, 30)),
                ('1', 1, 1, datetime.datetime(2020, 9, 15, 8, 30))
            ],
            [
                'Experiment RB number: 1    | User: user_name_-      | Role: role_name_-       | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_1',
                'Experiment RB number: 22   | User: user_name_--     | Role: role_name_--      | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_22',
                'Experiment RB number: 332  | User: user_name_---    | Role: role_name_--      | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_332',
                'Experiment RB number: 4413 | User: user_name_-      | Role: role_name_---     | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_4413',
                'Experiment RB number: 167  | User: user_name_------ | Role: role_name_------- | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_167',
                'Experiment RB number: 1    | User: user_name_-      | Role: role_name_-       | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_1'
            ]
        ),
        (
            [
                ('1', 1, 1, datetime.datetime(2020, 9, 15, 8, 30))
            ],
            [
                'Experiment RB number: 1 | User: user_name_- | Role: role_name_- | Start date: 2020-09-15 08:30:00'
                ' | Duration: duration_1'
            ]
        ),
        (
            [
                ('167', 6, 7, datetime.datetime(2020, 9, 15, 8, 30)),
                ('1', 1, 1, datetime.datetime(2020, 9, 15, 8, 30))
            ],
            [
                'Experiment RB number: 167 | User: user_name_------ | Role: role_name_------- | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_167',
                'Experiment RB number: 1   | User: user_name_-      | Role: role_name_-       | Start date: 2020-09-15'
                ' 08:30:00 | Duration: duration_1'
            ]
        ),
        (
            [
                ('1', 1, 1, datetime.datetime(2020, 9, 15, 8, 30)),
                ('22', 2, 2, datetime.datetime(2020, 9, 15, 8, 30))
            ],
            [
                'Experiment RB number: 1  | User: user_name_-  | Role: role_name_-  | Start date: 2020-09-15 08:30:00'
                ' | Duration: duration_1',
                'Experiment RB number: 22 | User: user_name_-- | Role: role_name_-- | Start date: 2020-09-15 08:30:00'
                ' | Duration: duration_22'
            ]
        )
    ])
    @patch('builtins.print')
    def test_GIVEN_different_length_WHEN_printing_data_THEN_correct_padding(self, records, result, m_print):
        # Arrange
        def sql_return_values(*args, **kwargs):
            if kwargs['command'] == "SELECT name FROM `user` WHERE userID = %s":
                return f'user_name_{"-" * kwargs["bound_variables"][0]}'
            elif kwargs['command'] == "SELECT name FROM `role` WHERE roleID = %s":
                return f'role_name_{"-" * kwargs["bound_variables"][0]}'
            elif kwargs['command'] == "SELECT duration FROM `experiment` WHERE experimentID = %s":
                return f'duration_{kwargs["bound_variables"][0]}'
            elif "SELECT * FROM `experimentteams`" in kwargs['command']:
                return records
            else:
                return DEFAULT

        self.mock_sql().execute_command.side_effect = sql_return_values

        calls = [call(x) for x in result]

        # Act
        self.get_exp_data()

        # Assert
        m_print.assert_has_calls(calls, any_order=False)
