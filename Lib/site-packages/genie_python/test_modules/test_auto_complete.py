"""
# This file is part of the ISIS IBEX application.
# Copyright (C) 2012-2016 Science & Technology Facilities Council.
# All rights reserved.
#
# This program is distributed in the hope that it will be useful.
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v1.0 which accompanies this distribution.
# EXCEPT AS EXPRESSLY SET FORTH IN THE ECLIPSE PUBLIC LICENSE V1.0, THE PROGRAM
# AND ACCOMPANYING MATERIALS ARE PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND.  See the Eclipse Public License v1.0 for more details.
#
# You should have received a copy of the Eclipse Public License v1.0
# along with this program; if not, you can obtain a copy from
# https://www.eclipse.org/org/documents/epl-v10.php or
# http://opensource.org/licenses/eclipse-1.0.php
"""
from __future__ import absolute_import

import os
import unittest
from unittest import skipIf

import six
from genie_python.genie import get_script_dir
from genie_python import genie
from genie_python.genie_api_setup import LoadScriptCompleter
import genie_python.genie_api_setup
from contextlib import contextmanager
from genie_python.utilities import get_correct_path

from hamcrest import assert_that, is_
from mock import MagicMock, call, patch
from parameterized import parameterized



class TestGenieAutoCompletePyConsole(unittest.TestCase):
    RETURN_FROM_COMPLETER = ("", ["result"])

    def setUp(self):
        self.load_script = LoadScriptCompleter(self._completer_stub)
        genie_python.genie_api_setup._exceptions_raised = True
        # You can not use set script dir because it relies on the path existing
        genie_python.genie_api_setup.USER_SCRIPT_DIR = get_correct_path("c:/scripts/")

    def tearDown(self):
        pass

    def _completer_stub(self, text=None, line_buffer=None, cursor_pos=None):
        return self.RETURN_FROM_COMPLETER

    def test_GIVEN_no_text_WHEN_auto_complete_THEN_return_contents_of_given_completer(self):
        # Arrange

        # Act
        result = self.load_script.complete(line_buffer="")

        # Assert

        assert_that(result, is_(self.RETURN_FROM_COMPLETER))

    def test_GIVEN_text_no_load_script_WHEN_auto_complete_THEN_return_contents_of_given_completer(self):
        # Arrange

        # Act
        result = self.load_script.complete(line_buffer="stuff is here")

        # Assert

        assert_that(result, is_(self.RETURN_FROM_COMPLETER))

    @parameterized.expand([
        (u'c:\scri', r"c:/scripts", u"c:/scripts"),
        (u'c:\scripts', r"c:/scripts", u"c:/scripts"),
        (u'c:\scripts', r"c:/scripts/play.com", u"c:/scripts/play.com"),
        (u'c:\scripts\play.', r"c:/scripts/play.py", u"c:/scripts/play.py"),
        (u'c:\scripts\play.p', r"c:/scripts/play.py", u"c:/scripts/play.py"),
        (u'c:\scripts\play ', r"c:/scripts/play - a.py", u"c:/scripts/play - a.py"),
        (u'c:\scripts\play -', r"c:/scripts/play - a.py", u"c:/scripts/play - a.py"),
        (u'c: -', r"c:/scripts/c: - other", u"c: - other"),
        ])
    @patch('glob.glob')
    def test_GIVEN_line_starts_load_script_with_various_partial_paths_WHEN_auto_complete_THEN_return_contents_of_path_from_dot(self, search_path, filename_from_glob, expected_result, mock_glob):
        # Arrange
        mock_glob.return_value = [filename_from_glob]
        expected_completer = (search_path, [expected_result])

        # Act
        result = self.load_script.complete(line_buffer=r'load_script("{}'.format(search_path))

        # Assert
        assert_that(result, is_(expected_completer))


    @patch('glob.glob')
    def test_GIVEN_line_with_g_dot_load_script_with_partial_path_WHEN_auto_complete_THEN_return_contents_of_path(self, mock_glob):
        # Arrange
        search_path = u'c:\scri'
        filenames = [r"c:/scripts"]
        mock_glob.return_value=filenames
        expected_completer = (search_path, [unicode(filename) for filename in filenames])

        # Act
        result = self.load_script.complete(line_buffer=r'g.load_script("{}'.format(search_path))

        # Assert
        assert_that(result, is_(expected_completer))

    @patch('glob.glob')
    def test_GIVEN_line_with_load_script_with_no_matching_paths_WHEN_auto_complete_THEN_no_matches(self, mock_glob):
        # Arrange
        search_path = u'c:\scri'
        mock_glob.return_value = []
        expected_completer = (search_path, [])

        # Act
        result = self.load_script.complete(line_buffer=r'g.load_script("{}'.format(search_path))

        # Assert
        assert_that(result, is_(expected_completer))

    @parameterized.expand([
        (u'', os.path.join(get_script_dir(), "c:/scripts/scripts.py"), u"scripts.py"),
        (u'sc', os.path.join(get_script_dir(), "c:/scripts/scripts.py"), u"scripts.py"),
        (u'scripts.py', os.path.join(get_script_dir(), "c:/scripts/scripts.py"), u"scripts.py"),
        ])
    @patch('glob.glob')
    def test_GIVEN_line_starts_load_script_with_non_absolute_path_THEN_return_contents_of_scripting_dir(self, search_path, filename_from_glob, expected_result, mock_glob):
        # Arrange
        mock_glob.return_value = [filename_from_glob]
        expected_completer = (search_path, [expected_result])

        # Act
        result = self.load_script.complete(line_buffer=r'load_script("{}'.format(search_path))

        # Assert
        mock_glob.assert_called_with("{}{}*".format(get_script_dir(),search_path))
        assert_that(result, is_(expected_completer))

    @patch('glob.glob')
    def test_GIVEN_line_with_load_script_with_quote_WHEN_auto_complete_THEN_show_matches_with_quote(self, mock_glob):
        # Arrange
        search_path = u''
        mock_glob.return_value = ["{}filename.py".format(get_script_dir())]
        expected_completer = (search_path, [u'"filename.py'])

        # Act
        result = self.load_script.complete(line_buffer=r'g.load_script({}'.format(search_path))

        # Assert
        assert_that(result, is_(expected_completer))


class TestGenieAutoCompletePyDev(unittest.TestCase):
    RETURN_FROM_COMPLETER = ("", ["result"])

    def setUp(self):
        self.load_script = LoadScriptCompleter(self._completer_stub)
        self.load_script.is_pydev = True
        genie_python.genie_api_setup._exceptions_raised = True

    def tearDown(self):
        pass

    def _completer_stub(self, text=None, line_buffer=None, cursor_pos=None):
        return self.RETURN_FROM_COMPLETER

    def test_GIVEN_no_text_WHEN_auto_complete_THEN_return_contents_of_given_completer(self):
        # Arrange

        # Act
        result = self.load_script.complete(line_buffer="")

        # Assert

        assert_that(result, is_(self.RETURN_FROM_COMPLETER))

    def test_GIVEN_text_no_load_script_WHEN_auto_complete_THEN_return_contents_of_given_completer(self):
        # Arrange

        # Act
        result = self.load_script.complete(line_buffer="stuff is here")

        # Assert

        assert_that(result, is_(self.RETURN_FROM_COMPLETER))

    @patch('glob.glob')
    def test_GIVEN_line_with_load_script_with_no_matching_paths_WHEN_auto_complete_THEN_no_matches(self, mock_glob):
        # Arrange
        search_path = u'c:\scri'
        mock_glob.return_value = []
        expected_completer = (search_path, [])

        # Act
        result = self.load_script.complete(line_buffer=r'g.load_script("{}'.format(search_path))

        # Assert
        assert_that(result, is_(expected_completer))

    @parameterized.expand([
        (u'c:\scripts\play.', r"c:/scripts/play.py", "py"),
        (u'c:\scripts\play.p', r"c:/scripts/play.py", "py"),
        (u'c:\scri', r"c:/scripts", "scripts"),
        (u'c:\scripts', r"c:/scripts", "scripts"),
        (u'c:\scri', r"c:/scripts","scripts"),
        (u'c:\scripts\play ', r"c:/scripts/play - a.py", "- a.py"),
        (u'c:\scripts\play -', r"c:/scripts/play - a.py", " a.py"),
        ])
    @patch('glob.glob')
    def test_GIVEN_line_starts_load_script_with_various_partial_paths_WHEN_auto_complete_THEN_return_contents_of_path_from_dot(self, search_path, filename_from_glob, expected_result, mock_glob):
        # Arrange
        mock_glob.return_value = [filename_from_glob]
        expected_completer = (search_path, [expected_result])

        # Act
        result = self.load_script.complete(line_buffer=r'load_script("{}'.format(search_path))

        # Assert
        assert_that(result, is_(expected_completer))

    @parameterized.expand([
        (u'', os.path.join(get_script_dir(), "c:/scripts/scripts.py"), u"load_script(\"scripts.py"),
        (u'sc', os.path.join(get_script_dir(), "c:/scripts/scripts.py"), u"load_script(\"scripts.py"),
        (u'scripts.py', os.path.join(get_script_dir(), "c:/scripts/scripts.py"), u"py"),
        ])
    @patch('glob.glob')
    def test_GIVEN_line_starts_load_script_with_non_absolute_path_THEN_return_contents_of_scripting_dir(self, search_path, filename_from_glob, expected_result, mock_glob):
        # Arrange
        mock_glob.return_value = [filename_from_glob]
        expected_completer = (search_path, [expected_result])

        # Act
        result = self.load_script.complete(line_buffer=r'load_script("{}'.format(search_path))

        # Assert
        mock_glob.assert_called_with("{}{}*".format(get_script_dir(),search_path))
        assert_that(result, is_(expected_completer))

    @patch('glob.glob')
    def test_GIVEN_line_starts_load_script_with_nothing_else_THEN_return_contents_of_scripting_dir_with_load_script(self, mock_glob):
        # Arrange
        expected_result = '"play.py'
        mock_glob.return_value = ["{}play.py".format(get_script_dir())]
        expected_completer = ("", [expected_result])

        # Act
        result = self.load_script.complete(line_buffer=r'load_script(')

        # Assert
        mock_glob.assert_called_with("{}*".format(get_script_dir()))
        assert_that(result, is_(expected_completer))
