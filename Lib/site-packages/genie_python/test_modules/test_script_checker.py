# This file is part of the ISIS IBEX application.
# Copyright (C) 2012-2016 Science & Technology Facilities Council.
# All rights reserved.
#
# This program is distributed in the hope that it will be useful.
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v1.0 which accompanies this distribution.
# EXCEPT AS EXPRESSLY SET FORTH IN THE ECLIPSE PUBLIC LICENSE V1.0, THE PROGRAM
# AND ACCOMPANYING MATERIALS ARE PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND.  See the Eclipse Public License v1.0 for more details.
#
# You should have received a copy of the Eclipse Public License v1.0
# along with this program; if not, you can obtain a copy from
# https://www.eclipse.org/org/documents/epl-v10.php or
# http://opensource.org/licenses/eclipse-1.0.php
from __future__ import absolute_import

import builtins
import os
import shutil
import sys
import tempfile
import unittest

import astroid

from genie_python.genie_epics_api import API
from genie_python.genie_script_checker import ScriptChecker


def write_to_file(message, suffix="", dir=""):
    """
    write to temporary file for test check_script
    :param message: message to write to file
    :return: returns temporary file
    """
    temp_file = tempfile.NamedTemporaryFile(delete=False, suffix=suffix, dir=dir)
    for line in message:
        temp_file.write(line.encode("utf-8"))
    temp_file.close()
    return temp_file


class TestScriptChecker(unittest.TestCase):
    def setUp(self):
        self.checker = ScriptChecker()
        self.api = API("", None)
        self.instrument, self.machine, self.pv_prefix = (
            self.api._get_machine_details_from_identifier(None)
        )
        file_path = os.path.join("C:\\", "Instrument", "Settings", "config", self.machine, "Python")
        sys.path.append(file_path)

    def tearDown(self):
        pass

    def assertSymbolsDefined(self, script_lines, expected_symbols):
        dir_path = tempfile.mkdtemp()
        write_to_file(script_lines, suffix=".py", dir=dir_path)
        result = self.checker.get_inst_attributes(dir_path)
        shutil.rmtree(dir_path)
        self.assertEqual(result, expected_symbols)

    def test_GIVEN_end_without_brackets_WHEN_check_THEN_error_message(self):
        script_lines = [
            "from genie_python import genie as g\n" "def test():\n",
            "   g.begin()\n",
            "   g.end\n",
        ]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(
            temp_script_file.name, self.machine, warnings_as_error=True
        )
        os.unlink(temp_script_file.name)

        self.assertEqual(result, ["W:  4: Statement seems to have no effect (pointless-statement)"])

    def test_GIVEN_end_as_start_of_another_word_WHEN_check_THEN_no_error_message(self):
        script_lines = ["from genie_python import genie as g\n" "def test():\n", "    endAngle = 1"]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        temp_script_file.close()
        os.unlink(temp_script_file.name)

        self.assertEqual(result, [])

    def test_GIVEN_end_as_end_of_another_word_WHEN_check_THEN_no_error_message(self):
        script_lines = [
            "from genie_python import genie as g\n" "def test():\n",
            "    angle_end = 1",
        ]
        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        temp_script_file.close()
        os.unlink(temp_script_file.name)

        self.assertEqual(result, [])

    def test_GIVEN_end_without_brackets_at_start_of_line_WHEN_check_THEN_error_message(self):
        script_lines = ["from genie_python import genie as g\n" "def test():\n" "   g.end"]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(
            temp_script_file.name, self.machine, warnings_as_error=True
        )
        os.unlink(temp_script_file.name)

        self.assertEqual(result, ["W:  3: Statement seems to have no effect (pointless-statement)"])

    def test_GIVEN_end_without_brackets_on_line_with_fn_with_brackets_WHEN_check_THEN_error_message(
        self,
    ):
        script_lines = ["from genie_python import genie as g\n" "g.begin(); g.end "]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(
            temp_script_file.name, self.machine, warnings_as_error=True
        )
        os.unlink(temp_script_file.name)

        self.assertEqual(result, ["W:  2: Statement seems to have no effect (pointless-statement)"])

    def test_GIVEN_end_in_string_without_brackets_WHEN_check_THEN_no_message(self):
        script_lines = ["def test():\n" '   " a string containing end "']

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        temp_script_file.close()
        os.unlink(temp_script_file.name)

        self.assertEqual(result, [])

    def test_GIVEN_end_in_comment_without_brackets_WHEN_check_THEN_no_message(self):
        script_lines = ["def test():\n", '   "stuff" # end "']

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        temp_script_file.close()
        os.unlink(temp_script_file.name)

        self.assertEqual(result, [])

    def test_GIVEN_g_assignment_WHEN_check_THEN_warning_message(self):
        script_lines = ["from genie_python import genie as g", "g=1"]

        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  2: 'g' assignment in line 2"])

    def test_GIVEN_g_assignment_after_whitespace_WHEN_check_THEN_warning_message(self):
        script_lines = ["g=2"]
        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'g' assignment in line 1"])

    def test_GIVEN_g_assignment_with_space_before_number_WHEN_check_THEN_warning_message(self):
        script_lines = ["g<= 3"]
        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, [])

    def test_GIVEN_inst_assignment_with_point_WHEN_check_THEN_warning_message(self):
        script_lines = ["inst.test=>4"]

        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'inst' assignment in line 1"])

    def test_GIVEN_inst_assignment_with_space_between_assignment_and_value_WHEN_check_THEN_warning_message(
        self,
    ):
        script_lines = ["inst = 5"]

        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'inst' assignment in line 1"])

    def test_GIVEN_inst_assignment_with_2_symbols_before_number_WHEN_check_THEN_warning_message(
        self,
    ):
        script_lines = ["inst+=6"]
        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'inst' assignment in line 1"])

    def test_GIVEN_inst_assignment_WHEN_check_THEN_warning_message(self):
        script_lines = ["inst=7"]

        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'inst' assignment in line 1"])

    def test_GIVEN_inst_assignment_after_whitespace_WHEN_check_THEN_warning_message(self):
        script_lines = ["inst=8"]

        result = self.checker.check_script_lines(script_lines)
        self.assertEqual(result, ["W:  1: 'inst' assignment in line 1"])

    def test_GIVEN_inst_assignment_with_space_before_number_WHEN_check_THEN_warning_message(self):
        script_lines = ["inst= 9"]
        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'inst' assignment in line 1"])

    def test_GIVEN_g_assignment_with_point_WHEN_check_THEN_warning_message(self):
        script_lines = ["g.cset=10"]

        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'g' assignment in line 1"])

    def test_GIVEN_g_assignment_with_space_between_assignment_and_value_WHEN_check_THEN_warning_message(
        self,
    ):
        script_lines = ["g = 11"]

        result = self.checker.check_script_lines(script_lines)

        self.assertEqual(result, ["W:  1: 'g' assignment in line 1"])

    def test_GIVEN_g_assignment_with_2_symbols_before_number_WHEN_check_THEN_warning_message(self):
        script_lines = ["from genie_python import genie as g\n", "def test():\n", "   g+=12"]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(
            temp_script_file.name, self.machine, warnings_as_error=True
        )
        temp_script_file.close()
        os.unlink(temp_script_file.name)
        self.assertEqual(result, ["W:  3: 'g' assignment in line 3"])

    def test_GIVEN_variable_assignment_with_g__WHEN_check_THEN_no_message(self):
        script_lines = ["going=13"]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        temp_script_file.close()
        os.unlink(temp_script_file.name)

        self.assertEqual(result, [])

    def test_GIVEN_function_with_g_WHEN_check_THEN_warn_user(self):
        script_lines = [
            "from genie_python import genie as g\n" "def test():\n" "   g.test_function()\n"
        ]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        temp_script_file.close()
        os.unlink(temp_script_file.name)

        self.assertEqual(
            result, ["E:  3: Module 'genie_python.genie' has no 'test_function' member (no-member)"]
        )

    def test_GIVEN_2_g_assignments_WHEN_check_THEN_warning_message(self):
        script_lines = [
            "from genie_python import genie as g\n" "def test():\n" "    g=16\n",
            "    g=17",
        ]

        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(
            temp_script_file.name, self.machine, warnings_as_error=True
        )
        os.unlink(temp_script_file.name)

        self.assertEqual(
            result, ["W:  3: 'g' assignment in line 3", "W:  4: 'g' assignment in line 4"]
        )

    def test_GIVEN_g_non_existing_command_WHEN_call_THEN_error_message(self):
        script_lines = [
            "from genie_python import genie as g\n" "def test():\n" "  g.aitfor_time(10)"
        ]
        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)

        os.unlink(temp_script_file.name)
        self.assertEqual(
            result,
            [
                "E:  3: Module 'genie_python.genie' has no "
                "'aitfor_time' member; maybe 'waitfor_time'? (no-member)"
            ],
        )

    def test_GIVEN_class_definition_WHEN_get_inst_attributes_THEN_class_name_and_attributes_defined(
        self,
    ):
        script_lines = [
            "class TestClass(Object):\n",
            "    def __init__(self):\n",
            "        self.a = 10",
        ]

        self.assertSymbolsDefined(script_lines, "inst.TestClass,inst.TestClass.a")

    def test_GIVEN_method_definition_WHEN_get_inst_attributes_THEN_only_method_name_defined(self):
        script_lines = ["def testMethod():\n", "    b = 10"]

        self.assertSymbolsDefined(script_lines, "inst.testMethod")

    def test_GIVEN_variable_assignment_WHEN_get_inst_attributes_THEN_variable_defined(self):
        script_lines = ["a = 10"]

        self.assertSymbolsDefined(script_lines, "inst.a")

    def test_GIVEN_nested_variable_assignment_WHEN_get_inst_attributes_THEN_all_vars_defined(self):
        script_lines = ["a = b = 10"]

        self.assertSymbolsDefined(script_lines, "inst.a,inst.b")

    @unittest.skipIf(sys.version_info[0] < 3, "Starred assignments are not supported in Python 2")
    def test_GIVEN_starred_assignment_WHEN_get_inst_attributes_THEN_all_vars_defined(self):
        script_lines = ["a, *b, c = range(5)"]

        self.assertSymbolsDefined(script_lines, "inst.a,inst.b,inst.c")

    def test_GIVEN_unparenthesized_tuple_assignment_WHEN_get_inst_attributes_THEN_all_vars_defined(
        self,
    ):
        script_lines = ["a,b = 1,2"]

        self.assertSymbolsDefined(script_lines, "inst.a,inst.b")

    def test_GIVEN_parenthesized_tuple_assignment_WHEN_get_inst_attributes_THEN_all_vars_defined(
        self,
    ):
        script_lines = ["(a,b) = (1,2)"]

        self.assertSymbolsDefined(script_lines, "inst.a,inst.b")

    def test_GIVEN_nested_tuple_assignment_WHEN_get_inst_attributes_THEN_all_vars_defined(self):
        script_lines = ["((a,b),c) = ((1,2),3)"]

        self.assertSymbolsDefined(script_lines, "inst.a,inst.b,inst.c")

    def test_GIVEN_list_assignment_WHEN_get_inst_attributes_THEN_all_vars_defined(self):
        script_lines = ["[a,b] = [1,2]"]

        self.assertSymbolsDefined(script_lines, "inst.a,inst.b")

    def test_GIVEN_nested_list_assignment_WHEN_get_inst_attributes_THEN_all_vars_defined(self):
        script_lines = ["[[a,b],c] = [[1,2],3]"]

        self.assertSymbolsDefined(script_lines, "inst.a,inst.b,inst.c")

    def test_GIVEN_index_subscript_assignment_WHEN_get_inst_attributes_THEN_no_symbols_defined(
        self,
    ):
        script_lines = ["list[0] = 1"]

        self.assertSymbolsDefined(script_lines, "")

    def test_GIVEN_list_definition_and_index_subscript_assignment_WHEN_get_inst_attributes_THEN_only_list_defined(
        self,
    ):
        script_lines = ["list = []\n", "list[0] = 1"]

        self.assertSymbolsDefined(script_lines, "inst.list")

    def test_GIVEN_key_subscript_assignment_WHEN_get_inst_attributes_THEN_no_symbols_defined(self):
        script_lines = ["dict['a'] = 1"]

        self.assertSymbolsDefined(script_lines, "")

    def test_GIVEN_dict_definition_and_subscript_assignment_WHEN_get_inst_attributes_THEN_only_dict_defined(
        self,
    ):
        script_lines = ["dict = {}\n", "dict['a'] = 1"]

        self.assertSymbolsDefined(script_lines, "inst.dict")

    def test_GIVEN_slice_subscript_assignment_WHEN_get_inst_attributes_THEN_no_symbols_defined(
        self,
    ):
        script_lines = ["list[0:2] = [8,9]"]

        self.assertSymbolsDefined(script_lines, "")

    def test_GIVEN_list_definition_and_slice_subscript_assignment_WHEN_get_inst_attributes_THEN_only_list_defined(
        self,
    ):
        script_lines = ["list = []\n", "list[0:2] = [8,9]"]

        self.assertSymbolsDefined(script_lines, "inst.list")

    def test_GIVEN_attribute_assignment_WHEN_get_inst_attributes_THEN_attribute_defined(self):
        script_lines = ["test.a = 1"]

        self.assertSymbolsDefined(script_lines, "inst.test.a")

    def test_GIVEN_nested_attribute_assignment_WHEN_get_inst_attributes_THEN_attribute_defined(
        self,
    ):
        script_lines = ["test1.test2.a = 1"]

        self.assertSymbolsDefined(script_lines, "inst.test1.test2.a")

    def test_GIVEN_complex_assignment_WHEN_get_inst_attributes_THEN_all_symbols_defined(self):
        script_lines = ["[[dict['a'], test1.test2.b], c], test1.d = [[1,2], 3], 4"]

        self.assertSymbolsDefined(script_lines, "inst.test1.test2.b,inst.c,inst.test1.d")

    @unittest.skipIf(sys.version_info[0] < 3, "Starred assignments are not supported in Python 2")
    def test_GIVEN_starred_complex_assignment_WHEN_get_inst_attributes_THEN_all_symbols_defined(
        self,
    ):
        script_lines = ["[[dict['a'], *test1.test2.b], c], test1.d = [range(5), 6], 7"]

        self.assertSymbolsDefined(script_lines, "inst.test1.test2.b,inst.c,inst.test1.d")

    def test_GIVEN_inst_script_wrong_path_WHEN_call_THEN_give_empty_error(self):
        dir_path = os.path.join("C:\\", "this", "path", "does", "not", "exist")
        result = self.checker.get_inst_attributes(dir_path)
        self.assertEqual(result, "")

    def test_GIVEN_invalid_python_expr_WHEN_call_check_THEN_error(self):
        script_lines = ["my_expr ="]
        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        os.unlink(temp_script_file.name)
        expected = "E:  1: Parsing failed: 'invalid syntax"
        self.assertTrue(
            result[0].startswith(expected),
            f"Result was {result}, expected first line to start with {expected}",
        )

    def test_GIVEN_valid_python_expr_WHEN_call_check_THEN_no_error(self):
        script_lines = ["my_expr = {}"]
        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        os.unlink(temp_script_file.name)
        self.assertEqual(result, [])

    def test_GIVEN_valid_python_class_WHEN_call_check_THEN_no_error(self):
        script_lines = ["class MyClass():", "pass"]
        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        os.unlink(temp_script_file.name)
        self.assertEqual(result, [])

    def test_GIVEN_invalid_python_class_WHEN_call_check_THEN_error(self):
        script_lines = ["class MyClass():"]
        temp_script_file = write_to_file(script_lines)
        result = self.checker.check_script(temp_script_file.name, self.machine)
        os.unlink(temp_script_file.name)
        expected = "E:  1: Parsing failed: 'expected an indented block"
        self.assertTrue(
            result[0].startswith(expected),
            f'Result was "{result[0]}", expected first line to start with "{expected}"',
        )

    def test_GIVEN_builtin_module_THEN_it_can_safely_be_cached(self):
        # The module itself is irrelevant for this check so we can pass None as the module.
        self.assertTrue(self.checker._can_cache_module(builtins.__name__, None))

    def test_GIVEN_site_packages_module_THEN_it_can_safely_be_cached(self):
        import numpy

        mod = astroid.Module(numpy.__name__, numpy.__file__)
        self.assertTrue(self.checker._can_cache_module("numpy", mod))

    def test_GIVEN_user_script_THEN_it_should_not_be_cached(self):
        name = "my_user_script"
        mod = astroid.Module(name, os.path.join("C:\\", "scripts", "my_user_script.py"))
        self.assertFalse(self.checker._can_cache_module(name, mod))

    def test_GIVEN_instrument_script_THEN_it_should_not_be_cached(self):
        name = "my_inst_script"
        mod = astroid.Module(
            name,
            os.path.join(
                "C:\\",
                "Instrument",
                "Settings",
                "config",
                "UNITTEST",
                "Python",
                "inst",
                "my_inst_script.py",
            ),
        )
        self.assertFalse(self.checker._can_cache_module(name, mod))
