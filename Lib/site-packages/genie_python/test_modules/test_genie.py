# This file is part of the ISIS IBEX application.
# Copyright (C) 2012-2016 Science & Technology Facilities Council.
# All rights reserved.
#
# This program is distributed in the hope that it will be useful.
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v1.0 which accompanies this distribution.
# EXCEPT AS EXPRESSLY SET FORTH IN THE ECLIPSE PUBLIC LICENSE V1.0, THE PROGRAM
# AND ACCOMPANYING MATERIALS ARE PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND.  See the Eclipse Public License v1.0 for more details.
#
# You should have received a copy of the Eclipse Public License v1.0
# along with this program; if not, you can obtain a copy from
# https://www.eclipse.org/org/documents/epl-v10.php or
# http://opensource.org/licenses/eclipse-1.0.php
from __future__ import absolute_import, print_function

import os
import unittest
from unittest import skipIf

import six
from genie_python import genie
from genie_python.genie_waitfor import WaitForController, WaitForControllerExceptionContext,\
    WaitForControllerConnectedState
import genie_python.genie_api_setup
from contextlib import contextmanager
from mock import MagicMock, call, patch
from StringIO import StringIO
from datetime import datetime, timedelta

from ..channel_access_exceptions import UnableToConnectToPVException, ReadAccessException

TEST_OUTPUT_FILENAME = 'test_output.txt'


class TestGenie(unittest.TestCase):
    def setUp(self):
        genie.set_instrument(None)
        genie_python.genie_api_setup._exceptions_raised = True

    def tearDown(self):
        pass

    def test_GIVEN_no_script_WHEN_load_script_THEN_return_None(self):
        # Arrange

        # Act
        result = genie.load_script(None)

        # Assert
        self.assertIsNone(result)

    def test_GIVEN_error_script_WHEN_load_script_THEN_error(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error.py")

        # Act
        self.assertRaises(Exception, genie.load_script, script)

    def test_GIVEN_valid_script_WHEN_load_script_THEN_can_call_script(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "valid.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.valid())

    @skipIf(not six.PY2, "This test will only work on python 2")
    def test_GIVEN_valid_python_2_script_WHEN_load_script_THEN_can_call_script(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "valid_python_2.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.valid_py2())

    def test_GIVEN_valid_script_WHEN_load_script_THEN_can_import_from_script_directory(self):
        # Arrange
        script = os.path.join(os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts"), "valid.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.check_import())

    def test_GIVEN_script_checker_error_WHEN_load_script_THEN_error(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error_for_script_checker.py")

        # Act
        self.assertRaises(Exception, genie.load_script, script)

    def test_GIVEN_script_checker_error_WHEN_load_script_without_script_checker_THEN_ok(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error_for_script_checker.py")

        # Act
        genie.load_script(script, check_script=False)

    def test_WHEN_seconds_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(seconds=-1)

    def test_WHEN_minutes_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(minutes=-1)

    def test_WHEN_hours_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(hours=-1)

    def test_WHEN_time_is_0_seconds_THEN_waitfor_time_returns(self):
        genie.waitfor_time(seconds=0)

    def test_WHEN_time_is_0_minutes_THEN_waitfor_time_returns(self):
        genie.waitfor_time(minutes=0)

    def test_WHEN_time_is_0_hours_THEN_waitfor_time_returns(self):
        genie.waitfor_time(hours=0)

    def test_WHEN_time_is_0_string_THEN_waitfor_time_returns(self):
        genie.waitfor_time(time="00:00:00")

    def test_WHEN_time_is_float_THEN_waitfor_time_returns(self):
        genie.waitfor_time(minutes=0.0000001)

    def test_WHEN_time_is_float_and_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(minutes=-0.000001)

    def test_WHEN_raw_frames_negative_THEN_waitfor_raw_frames_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_raw_frames(raw_frames=-1)

    @patch('genie_python.genie.__api.get_blocks')
    @patch('genie_python.genie.__api.waitfor.api.dae.get_raw_frames')
    def test_WHEN_raw_frames_is_0_THEN_waitfor_raw_frames_returns(self, raw_frames, blocks):
        blocks.return_value = []
        raw_frames.return_value = 0.1
        genie.waitfor_raw_frames(raw_frames=0)

    def test_WHEN_frames_negative_THEN_waitfor_frames_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_frames(frames=-1)

    @patch('genie_python.genie.__api.get_blocks')
    @patch('genie_python.genie.__api.waitfor.api.dae.get_good_frames')
    def test_WHEN_frames_is_0_THEN_waitfor_frames_returns(self, good_frames, blocks):
        blocks.return_value = []
        good_frames.return_value = 0.1
        genie.waitfor_frames(frames=0)

    @patch('genie_python.genie.__api.get_blocks')
    @patch('genie_python.genie.__api.waitfor.api.dae.get_raw_frames')
    def test_WHEN_raw_frames_is_0_THEN_waitfor_returns(self, raw_frames, blocks):
        blocks.return_value = []
        raw_frames.return_value = 0.1
        genie.waitfor(raw_frames=0)

    @patch('genie_python.genie.__api.get_blocks')
    @patch('genie_python.genie.__api.waitfor.api.dae.get_good_frames')
    def test_WHEN_frames_is_0_THEN_waitfor_returns(self, good_frames, blocks):
        blocks.return_value = []
        good_frames.return_value = 0.1
        genie.waitfor(frames=0)

    def test_WHEN_input_None_THEN_waitfor_uamps_returns(self):
        genie.waitfor_uamps(None)

    def test_GIVEN_frames_less_than_2_power_31_WHEN_reported_frames_increasing_THEN_waitfor_frames_waits_until_reported_frames_equals_requested_frames(self):
        frames = 5000
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 1, frames, frames + 1])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 2)

    def test_GIVEN_frames_greater_than_2_power_31_WHEN_reported_frames_increasing_THEN_waitfor_frames_waits_until_reported_frames_equals_requested_frames(self):
        frames = 2 ** 31
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 1, frames, frames + 1])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 2)

    def test_GIVEN_frames_less_than_2_power_31_WHEN_reported_frames_increasing_skips_requested_THEN_waitfor_frames_waits_until_next_reported_frames_equals_above_requested_frames(self):
        frames = 5000
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 2, frames - 1, frames + 1, frames + 2])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 3)

    def test_GIVEN_frames_greater_than_2_power_31_WHEN_reported_frames_increasing_skips_requested_THEN_waitfor_frames_waits_until_next_reported_frames_equals_above_requested_frames(self):
        frames = 2 ** 31
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 2, frames - 1, frames + 1, frames + 2])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 3)

    @contextmanager
    def _mock_get_blocks(self, blocks):
        oldapi = getattr(genie, "__api")  # Have to use getattr and setattr because of the name mangling
        setattr(genie, "__api", MagicMock(get_blocks=lambda: blocks))
        try:
            yield
        finally:
            setattr(genie, "__api", oldapi)

    def test_WHEN_waitfor_is_given_a_valid_block_as_a_keyword_argument_THEN_no_exception_raised(self):
        with self._mock_get_blocks(["blockname"]):
            genie.waitfor(blockname=5)

    def test_WHEN_waitfor_is_given_a_non_existent_block_as_a_keyword_argument_THEN_exception_raised(self):
        with self._mock_get_blocks([]), self.assertRaises(ValueError):
            genie.waitfor(blockname=5)

    @contextmanager
    def _mock_set_block_value(self):
        oldapi = getattr(genie, "__api")  # Have to use getattr and setattr because of the name mangling

        mocked_check_alarms = MagicMock(return_value=([], [], []))
        mocked_api = MagicMock(check_alarms=mocked_check_alarms)

        setattr(genie, "__api", mocked_api)
        try:
            yield mocked_api
        finally:
            setattr(genie, "__api", oldapi)

    def test_WHEN_cset_is_called_with_string_blockname_THEN_exactly_one_call_to_set_pv_value(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(blockname, value)
            mocked_api.set_block_value.assert_called_with(blockname, value, None, None, None, None)

    def test_WHEN_cset_is_called_with_kwarg_syntax_THEN_exactly_one_call_to_set_pv_value(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(**{blockname: value})
            mocked_api.set_block_value.assert_called_with(blockname, value, None, None, None, None)

    def test_WHEN_cset_is_called_with_kwarg_syntax_with_multiple_blocks_THEN_exactly_one_call_to_set_multiple_blocks_which_contains_the_blocknames_and_values(self):
        blocks = {
            "MY_BLOCK_NAME": "abc123",
            "ANOTHER_BLOCK": 42,
            "THE_LAST_BLOCK": True,
        }

        with self._mock_set_block_value() as mocked_api:
            genie.cset(**blocks)
            mocked_api.set_multiple_blocks.assert_called_with(
                [name for name in blocks.keys()],
                [value for value in blocks.values()]
            )

    def test_WHEN_cset_is_called_with_string_blockname_THEN_exactly_one_call_to_get_alarms(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(blockname, value)
            mocked_api.check_alarms.assert_called_with((blockname, ))

    def test_WHEN_cset_is_called_with_kwarg_syntax_THEN_exactly_one_call_to_get_alarms(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(**{blockname: value})
            mocked_api.check_alarms.assert_called_with((blockname, ))

    def test_WHEN_cset_is_called_with_kwarg_syntax_with_multiple_blocks_THEN_each_block_is_sent_to_check_alarms(self):
        blocks = {
            "MY_BLOCK_NAME": "abc123",
            "ANOTHER_BLOCK": 42,
            "THE_LAST_BLOCK": True,
        }

        with self._mock_set_block_value() as mocked_api:
            genie.cset(**blocks)
            self.assertEqual(mocked_api.check_alarms.call_count, len(blocks))
            mocked_api.check_alarms.assert_has_calls([call((x, )) for x in blocks.keys()], any_order=True)
 
    def test_WHEN_change_tables_is_called_with_no_file_paths_THEN_exception_thrown(self):
        self.assertRaises(ValueError, genie.change_tables)

    @patch('sys.stdout', new_callable=StringIO)
    def test_WHEN_pv_disconnected_THEN_waitfor_prints_exception_continues(self, fake_out):
        # Mock pv as disconnected
        api = MagicMock()
        api.dae.get_good_frames.side_effect = UnableToConnectToPVException(err="mocked err", pv_name="mocked pv")
        # Set up controller
        controller = WaitForController(api)

        try:
            controller.start_waiting(frames=5000, maxwait=0.1)

            # Check output (get rid of last line as split causes empty string at end)
            output = fake_out.getvalue().split("\n")[:-1]

            # One line for waiting for frames, another for the exception and another to say the waitfor has timed out
            self.assertEquals(len(output), 3)
            self.assertEquals("Waiting for 5000 frames [timeout=0.1]", output[0])
            self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__),
                          output[1])
            self.assertIn("Waitfor timed out", output[2])
        except Exception as e:
            self.fail("start_waiting should catch the exception and continue. Exception: {}".format(e))

    @patch('sys.stdout', new_callable=StringIO)
    def test_WHEN_context_starts_THEN_state_is_connected_and_no_output(self, fake_out):
        context = WaitForControllerExceptionContext(None)

        self.assertIsInstance(context._state, WaitForControllerConnectedState)
        # When no output is made StringIO returns empty string
        self.assertEquals(fake_out.getvalue(), '')

    @patch('sys.stdout', new_callable=StringIO)
    def test_WHEN_exception_occurs_then_clears_THEN_exception_and_clearance_printed(self, fake_out):
        context = WaitForControllerExceptionContext(MagicMock())

        context.process_exception(UnableToConnectToPVException(err="mocked err", pv_name="mocked pv"))
        context.process_exception(None)

        # Check output (get rid of last line as split causes empty string at end)
        output_lines = fake_out.getvalue().split("\n")[:-1]

        # One line for exception occurring, one for clearing
        self.assertEqual(len(output_lines), 2)
        # First line should be occurrence of exception
        self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__), output_lines[0])
        self.assertNotIn("Exception cleared", output_lines[0])
        # Second line should be exception clearing
        self.assertIn("Exception cleared", output_lines[1])
        self.assertNotIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__), output_lines[1])

    @patch('sys.stdout', new_callable=StringIO)
    def test_WHEN_exception_continuously_occurs_for_more_than_10_minutes_THEN_exception_printed_three_times(self,
                                                                                                            fake_out):
        number_of_5_minutes = 3
        context = WaitForControllerExceptionContext(MagicMock())

        # Simulate first disconnection
        context.process_exception(UnableToConnectToPVException(err="mocked err", pv_name="mocked pv"))
        # Simulate 5 minutes passing 3 times
        for i in range(number_of_5_minutes):
            context._state._last_notification_time = datetime.now() - timedelta(minutes=5)
            context.process_exception(UnableToConnectToPVException(err="mocked err", pv_name="mocked pv"))

        # Check lines contain exception (get rid of last line as split causes empty string at end)
        output_lines = fake_out.getvalue().split("\n")[:-1]
        self.assertEquals(len(output_lines), number_of_5_minutes + 1)
        for i in range(len(output_lines) - 1):
            self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__),
                          output_lines[i])

    @patch('sys.stdout', new_callable=StringIO)
    def test_WHEN_exception_changes_THEN_new_exception_printed(self, fake_out):
        context = WaitForControllerExceptionContext(MagicMock())

        # Simulate first disconnection
        context.process_exception(UnableToConnectToPVException(err="mocked err", pv_name="mocked pv"))
        # Simulate change of exception
        context.process_exception(ReadAccessException(pv_name="mocked pv"))

        # Check lines contain exception (get rid of last line as split causes empty string at end)
        output_lines = fake_out.getvalue().split("\n")[:-1]
        # One line for each exception
        self.assertEquals(len(output_lines), 2)
        self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__),
                      output_lines[0])
        self.assertIn("Exception in waitfor loop: {}".format(ReadAccessException.__name__),
                      output_lines[1])
