# This file is part of the ISIS IBEX application.
# Copyright (C) 2012-2016 Science & Technology Facilities Council.
# All rights reserved.
#
# This program is distributed in the hope that it will be useful.
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v1.0 which accompanies this distribution.
# EXCEPT AS EXPRESSLY SET FORTH IN THE ECLIPSE PUBLIC LICENSE V1.0, THE PROGRAM
# AND ACCOMPANYING MATERIALS ARE PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND.  See the Eclipse Public License v1.0 for more details.
#
# You should have received a copy of the Eclipse Public License v1.0
# along with this program; if not, you can obtain a copy from
# https://www.eclipse.org/org/documents/epl-v10.php or
# http://opensource.org/licenses/eclipse-1.0.php
from __future__ import absolute_import

import os
import unittest
from unittest import skipIf

import six
from genie_python import genie
from genie_python.genie_waitfor import WaitForController
import genie_python.genie_api_setup
from contextlib import contextmanager
from mock import MagicMock, call, patch
import sys
from threading import Thread
from time import sleep

from ..channel_access_exceptions import UnableToConnectToPVException, ReadAccessException

TEST_OUTPUT_FILENAME = 'test_output.txt'


class TestGenie(unittest.TestCase):
    def setUp(self):
        genie.set_instrument(None)
        genie_python.genie_api_setup._exceptions_raised = True

    def tearDown(self):
        if os.path.exists(TEST_OUTPUT_FILENAME):
            os.remove(TEST_OUTPUT_FILENAME)

    def test_GIVEN_no_script_WHEN_load_script_THEN_return_None(self):
        # Arrange

        # Act
        result = genie.load_script(None)

        # Assert
        self.assertIsNone(result)

    def test_GIVEN_error_script_WHEN_load_script_THEN_error(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error.py")

        # Act
        self.assertRaises(Exception, genie.load_script, script)

    def test_GIVEN_valid_script_WHEN_load_script_THEN_can_call_script(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "valid.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.valid())

    @skipIf(not six.PY2, "This test will only work on python 2")
    def test_GIVEN_valid_python_2_script_WHEN_load_script_THEN_can_call_script(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "valid_python_2.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.valid_py2())

    def test_GIVEN_valid_script_WHEN_load_script_THEN_can_import_from_script_directory(self):
        # Arrange
        script = os.path.join(os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts"), "valid.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.check_import())

    def test_GIVEN_script_checker_error_WHEN_load_script_THEN_error(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error_for_script_checker.py")

        # Act
        self.assertRaises(Exception, genie.load_script, script)

    def test_GIVEN_script_checker_error_WHEN_load_script_without_script_checker_THEN_ok(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error_for_script_checker.py")

        # Act
        genie.load_script(script, check_script=False)

    def test_WHEN_seconds_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(seconds=-1)

    def test_WHEN_minutes_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(minutes=-1)

    def test_WHEN_hours_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(hours=-1)

    def test_WHEN_time_is_0_seconds_THEN_waitfor_time_returns(self):
        genie.waitfor_time(seconds=0)

    def test_WHEN_time_is_0_minutes_THEN_waitfor_time_returns(self):
        genie.waitfor_time(minutes=0)

    def test_WHEN_time_is_0_hours_THEN_waitfor_time_returns(self):
        genie.waitfor_time(hours=0)

    def test_WHEN_time_is_0_string_THEN_waitfor_time_returns(self):
        genie.waitfor_time(time="00:00:00")

    def test_WHEN_time_is_float_THEN_waitfor_time_returns(self):
        genie.waitfor_time(minutes=0.0000001)

    def test_WHEN_time_is_float_and_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(minutes=-0.000001)

    def test_WHEN_raw_frames_negative_THEN_waitfor_raw_frames_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_raw_frames(raw_frames=-1)

    @patch('genie.__api.get_blocks')
    @patch('genie.__api.waitfor.api.dae.get_raw_frames')
    def test_WHEN_raw_frames_is_0_THEN_waitfor_raw_frames_returns(self, raw_frames, blocks):
        blocks.return_value = []
        raw_frames.return_value = 0.1
        genie.waitfor_raw_frames(raw_frames=0)

    def test_WHEN_frames_negative_THEN_waitfor_frames_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_frames(frames=-1)

    @patch('genie.__api.get_blocks')
    @patch('genie.__api.waitfor.api.dae.get_good_frames')
    def test_WHEN_frames_is_0_THEN_waitfor_frames_returns(self, good_frames, blocks):
        blocks.return_value = []
        good_frames.return_value = 0.1
        genie.waitfor_frames(frames=0)

    @patch('genie.__api.get_blocks')
    @patch('genie.__api.waitfor.api.dae.get_raw_frames')
    def test_WHEN_raw_frames_is_0_THEN_waitfor_returns(self, raw_frames, blocks):
        blocks.return_value = []
        raw_frames.return_value = 0.1
        genie.waitfor(raw_frames=0)

    @patch('genie.__api.get_blocks')
    @patch('genie.__api.waitfor.api.dae.get_good_frames')
    def test_WHEN_frames_is_0_THEN_waitfor_returns(self, good_frames, blocks):
        blocks.return_value = []
        good_frames.return_value = 0.1
        genie.waitfor(frames=0)

    def test_WHEN_input_None_THEN_waitfor_uamps_returns(self):
        genie.waitfor_uamps(None)

    def test_GIVEN_frames_less_than_2_power_31_WHEN_reported_frames_increasing_THEN_waitfor_frames_waits_until_reported_frames_equals_requested_frames(self):
        frames = 5000
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 1, frames, frames + 1])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 2)

    def test_GIVEN_frames_greater_than_2_power_31_WHEN_reported_frames_increasing_THEN_waitfor_frames_waits_until_reported_frames_equals_requested_frames(self):
        frames = 2 ** 31
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 1, frames, frames + 1])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 2)

    def test_GIVEN_frames_less_than_2_power_31_WHEN_reported_frames_increasing_skips_requested_THEN_waitfor_frames_waits_until_next_reported_frames_equals_above_requested_frames(self):
        frames = 5000
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 2, frames - 1, frames + 1, frames + 2])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 3)

    def test_GIVEN_frames_greater_than_2_power_31_WHEN_reported_frames_increasing_skips_requested_THEN_waitfor_frames_waits_until_next_reported_frames_equals_above_requested_frames(self):
        frames = 2 ** 31
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 2, frames - 1, frames + 1, frames + 2])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 3)

    @contextmanager
    def _mock_get_blocks(self, blocks):
        oldapi = getattr(genie, "__api")  # Have to use getattr and setattr because of the name mangling
        setattr(genie, "__api", MagicMock(get_blocks=lambda: blocks))
        try:
            yield
        finally:
            setattr(genie, "__api", oldapi)

    def test_WHEN_waitfor_is_given_a_valid_block_as_a_keyword_argument_THEN_no_exception_raised(self):
        with self._mock_get_blocks(["blockname"]):
            genie.waitfor(blockname=5)

    def test_WHEN_waitfor_is_given_a_non_existent_block_as_a_keyword_argument_THEN_exception_raised(self):
        with self._mock_get_blocks([]), self.assertRaises(ValueError):
            genie.waitfor(blockname=5)

    @contextmanager
    def _mock_set_block_value(self):
        oldapi = getattr(genie, "__api")  # Have to use getattr and setattr because of the name mangling

        mocked_check_alarms = MagicMock(return_value=([], [], []))
        mocked_api = MagicMock(check_alarms=mocked_check_alarms)

        setattr(genie, "__api", mocked_api)
        try:
            yield mocked_api
        finally:
            setattr(genie, "__api", oldapi)

    def test_WHEN_cset_is_called_with_string_blockname_THEN_exactly_one_call_to_set_pv_value(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(blockname, value)
            mocked_api.set_block_value.assert_called_with(blockname, value, None, None, None, None)

    def test_WHEN_cset_is_called_with_kwarg_syntax_THEN_exactly_one_call_to_set_pv_value(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(**{blockname: value})
            mocked_api.set_block_value.assert_called_with(blockname, value, None, None, None, None)

    def test_WHEN_cset_is_called_with_kwarg_syntax_with_multiple_blocks_THEN_exactly_one_call_to_set_multiple_blocks_which_contains_the_blocknames_and_values(self):
        blocks = {
            "MY_BLOCK_NAME": "abc123",
            "ANOTHER_BLOCK": 42,
            "THE_LAST_BLOCK": True,
        }

        with self._mock_set_block_value() as mocked_api:
            genie.cset(**blocks)
            mocked_api.set_multiple_blocks.assert_called_with(
                [name for name in blocks.keys()],
                [value for value in blocks.values()]
            )

    def test_WHEN_cset_is_called_with_string_blockname_THEN_exactly_one_call_to_get_alarms(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(blockname, value)
            mocked_api.check_alarms.assert_called_with((blockname, ))

    def test_WHEN_cset_is_called_with_kwarg_syntax_THEN_exactly_one_call_to_get_alarms(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(**{blockname: value})
            mocked_api.check_alarms.assert_called_with((blockname, ))

    def test_WHEN_cset_is_called_with_kwarg_syntax_with_multiple_blocks_THEN_each_block_is_sent_to_check_alarms(self):
        blocks = {
            "MY_BLOCK_NAME": "abc123",
            "ANOTHER_BLOCK": 42,
            "THE_LAST_BLOCK": True,
        }

        with self._mock_set_block_value() as mocked_api:
            genie.cset(**blocks)
            self.assertEqual(mocked_api.check_alarms.call_count, len(blocks))
            mocked_api.check_alarms.assert_has_calls([call((x, )) for x in blocks.keys()], any_order=True)
 
    def test_WHEN_change_tables_is_called_with_no_file_paths_THEN_exception_thrown(self):
        self.assertRaises(ValueError, genie.change_tables)

    @contextmanager
    def custom_redirection(self, fileobj):
        old = sys.stdout
        sys.stdout = fileobj
        try:
            yield fileobj
        finally:
            sys.stdout = old

    def _api_setup(self):
        # "Connect" the pv for getting good frames
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(return_value=1)

    def _api_manipulation_disconnect(self, wait=0):
        # "Disconnect" the pv
        sleep(wait)
        self.api.dae.get_good_frames.side_effect = UnableToConnectToPVException(err="mocked err", pv_name="mocked pv")

    def _api_manipulation_reconnect(self, wait=0):
        # "Reconnect" the pv
        sleep(wait)
        self.api.dae.get_good_frames.side_effect = None

    def _api_manipulation_disconnect_then_reconnect(self, wait_before_step1=0, wait_before_step2=0):
        # "Disconnect" the pv
        self._api_manipulation_disconnect(wait=wait_before_step1)
        # "Reconnect" the pv
        self._api_manipulation_reconnect(wait=wait_before_step2)

    def _run_waitfor(self, frames, maxwait):
        # Run the waitfor controller
        with open(TEST_OUTPUT_FILENAME, 'a') as test_output, self.custom_redirection(test_output):
            controller = WaitForController(self.api)
            controller.start_waiting(frames=frames, maxwait=maxwait)

    def _strip_setup_and_closing_from_test_output(self, output_lines):
        # Remove the first and last lines
        return output_lines[1:-1]

    def _simulate_waiting_and_api_manipulation(self, frames, maxwait, api_manipulation_repeat_amount,
                                               api_manipulation_function, api_manipulation_function_kwargs):
        # Set up the mocked api
        self._api_setup()
        # In one thread wait from the frames to become frames or for maxwait to pass
        waitfor_thread = Thread(target=self._run_waitfor, args=(frames, maxwait))
        waitfor_thread.start()
        # In other threads manipulate the api a given amount of times
        for _ in range(api_manipulation_repeat_amount):
            api_manipulation_thread = Thread(target=api_manipulation_function,
                                             kwargs=api_manipulation_function_kwargs)
            api_manipulation_thread.start()
            api_manipulation_thread.join()
        waitfor_thread.join()

    def test_WHEN_pv_disconnected_and_reconnected_THEN_error_and_reconnection_printed(self):
        # Simulate waiting for 5000 frames or 10 seconds
        # While this is running 5 times mock disconnecting and reconnecting the pv
        disconnect_reconnect_repeat_amount = 5
        self._simulate_waiting_and_api_manipulation(frames=5000, maxwait=10,
                                                    api_manipulation_repeat_amount=disconnect_reconnect_repeat_amount,
                                                    api_manipulation_function=
                                                    self._api_manipulation_disconnect_then_reconnect,
                                                    api_manipulation_function_kwargs={"wait_before_step1": 0.5,
                                                                                      "wait_before_step2": 0.5})
        # Test output
        with open(TEST_OUTPUT_FILENAME, 'r') as test_output:
            # first and last lines are setup and closing (get rid of them)
            output_lines = self._strip_setup_and_closing_from_test_output(test_output.readlines())
            # Check that disconnection exception and reconnection is printed each time they occur
            num_of_lines = 0
            for line in output_lines:
                if num_of_lines % 2 == 0:
                    self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__), line)
                elif num_of_lines % 2 == 1:
                    self.assertIn("PV reconnected", line)
                num_of_lines += 1
            self.assertEqual(num_of_lines, 2*disconnect_reconnect_repeat_amount)

    def test_WHEN_pv_disconnected_THEN_error_printed_every_five_mins(self):
        # Simulate waiting for 5000 frames or 11 minutes
        # While this is running mock disconnecting once
        minutes_to_wait = 11
        self._simulate_waiting_and_api_manipulation(frames=5000, maxwait=minutes_to_wait*60,
                                                    api_manipulation_repeat_amount=1,
                                                    api_manipulation_function=self._api_manipulation_disconnect,
                                                    api_manipulation_function_kwargs=None)
        # Test output
        with open(TEST_OUTPUT_FILENAME, 'r') as test_output:
            # first and last lines are setup and closing (get rid of them)
            output_lines = self._strip_setup_and_closing_from_test_output(test_output.readlines())
            # Check that only the exception that is occurring is printed
            num_of_lines = 0
            for line in output_lines:
                self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__), line)
                num_of_lines += 1
            # Should have printed at the start and then every five minutes
            self.assertEqual(num_of_lines, (minutes_to_wait//5)+1)

    def test_WHEN_disconnect_then_pv_reconnected_for_1_min_THEN_nothing_printed(self):
        # Simulate waiting for 5000 frames or 60 seconds
        # While this is running mock disconnecting and reconnecting the pv
        self._simulate_waiting_and_api_manipulation(frames=5000, maxwait=60, api_manipulation_repeat_amount=1,
                                                    api_manipulation_function
                                                    =self._api_manipulation_disconnect_then_reconnect,
                                                    api_manipulation_function_kwargs={"wait_before_step1": 0.5,
                                                                                      "wait_before_step2": 0.5})
        # Test output
        with open(TEST_OUTPUT_FILENAME, 'r') as test_output:
            # first and last lines are setup and closing (get rid of them)
            output_lines = self._strip_setup_and_closing_from_test_output(test_output.readlines())
            # Check that prints only occur once for the exception and once for the reconnect
            num_of_lines = 0
            for line in output_lines:
                print(line)
                if num_of_lines % 2 == 0:
                    self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__), line)
                elif num_of_lines % 2 == 1:
                    self.assertIn("PV reconnected", line)
                num_of_lines += 1
            self.assertEqual(num_of_lines, 2)

    def _api_manipulation_disconnect_different_exception(self, wait=0):
        # Change the channel access exception from UnableToConnectToPVException to ReadAccessException
        sleep(wait)
        self.api.dae.get_good_frames.side_effect = ReadAccessException(pv_name="mocked pv")

    def _api_manipulation_disconnect_then_change_exception(self, wait_before_step1=0, wait_before_step2=0):
        # "Disconnect" the pv
        self._api_manipulation_disconnect(wait=wait_before_step1)
        # Change the exception, changing the reason for disconnection
        self._api_manipulation_disconnect_different_exception(wait=wait_before_step2)

    def test_WHEN_pv_error_changes_THEN_new_error_printed(self):
        # Simulate waiting for 5000 frames or 10 seconds
        # While this is running: 5 times mock disconnecting and then changing the exception reason for disconnection
        disconnect_reconnect_repeat_amount = 5
        self._simulate_waiting_and_api_manipulation(frames=5000, maxwait=10,
                                                    api_manipulation_repeat_amount=disconnect_reconnect_repeat_amount,
                                                    api_manipulation_function=
                                                    self._api_manipulation_disconnect_then_change_exception,
                                                    api_manipulation_function_kwargs={"wait_before_step1": 0.5,
                                                                                      "wait_before_step2": 0.5})
        # Test the output to the user
        with open(TEST_OUTPUT_FILENAME, 'r') as test_output:
            # first and last lines are setup and closing (get rid of them)
            output_lines = self._strip_setup_and_closing_from_test_output(test_output.readlines())
            # Check that exception prints only occur when changed (through counting lines)
            num_of_lines = 0
            for line in output_lines:
                if num_of_lines % 2 == 0:
                    self.assertIn("Exception in waitfor loop: {}".format(UnableToConnectToPVException.__name__), line)
                elif num_of_lines % 2 == 1:
                    self.assertIn("Exception in waitfor loop: {}".format(ReadAccessException.__name__), line)
                num_of_lines += 1
            self.assertEqual(num_of_lines, 2 * disconnect_reconnect_repeat_amount)
