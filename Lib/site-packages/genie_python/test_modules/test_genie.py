# This file is part of the ISIS IBEX application.
# Copyright (C) 2012-2016 Science & Technology Facilities Council.
# All rights reserved.
#
# This program is distributed in the hope that it will be useful.
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v1.0 which accompanies this distribution.
# EXCEPT AS EXPRESSLY SET FORTH IN THE ECLIPSE PUBLIC LICENSE V1.0, THE PROGRAM
# AND ACCOMPANYING MATERIALS ARE PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND.  See the Eclipse Public License v1.0 for more details.
#
# You should have received a copy of the Eclipse Public License v1.0
# along with this program; if not, you can obtain a copy from
# https://www.eclipse.org/org/documents/epl-v10.php or
# http://opensource.org/licenses/eclipse-1.0.php
from __future__ import absolute_import

import os
import unittest
from unittest import skipIf

import six
from genie_python import genie
from genie_python.genie_waitfor import WaitForController
import genie_python.genie_api_setup
from contextlib import contextmanager
from mock import MagicMock, call


class TestGenie(unittest.TestCase):
    def setUp(self):
        genie_python.genie_api_setup._exceptions_raised = True

    def tearDown(self):
        pass

    def test_GIVEN_no_script_WHEN_load_script_THEN_return_None(self):
        # Arrange

        # Act
        result = genie.load_script(None)

        # Assert
        self.assertIsNone(result)

    def test_GIVEN_error_script_WHEN_load_script_THEN_error(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error.py")

        # Act
        self.assertRaises(Exception, genie.load_script, script)

    def test_GIVEN_valid_script_WHEN_load_script_THEN_can_call_script(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "valid.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.valid())

    @skipIf(not six.PY2, "This test will only work on python 2")
    def test_GIVEN_valid_python_2_script_WHEN_load_script_THEN_can_call_script(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "valid_python_2.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.valid_py2())

    def test_GIVEN_valid_script_WHEN_load_script_THEN_can_import_from_script_directory(self):
        # Arrange
        script = os.path.join(os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts"), "valid.py")

        # Act
        genie.load_script(script)

        # Assert
        self.assertTrue(genie.check_import())

    def test_GIVEN_script_checker_error_WHEN_load_script_THEN_error(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error_for_script_checker.py")

        # Act
        self.assertRaises(Exception, genie.load_script, script)

    def test_GIVEN_script_checker_error_WHEN_load_script_without_script_checker_THEN_ok(self):
        # Arrange
        script = os.path.join(os.path.abspath(os.path.dirname(__file__)), "test_scripts", "error_for_script_checker.py")

        # Act
        genie.load_script(script, check_script=False)

    def test_WHEN_seconds_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(seconds=-1)

    def test_WHEN_minutes_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(minutes=-1)

    def test_WHEN_hours_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(hours=-1)

    def test_WHEN_time_is_0_seconds_THEN_waitfor_time_returns(self):
        genie.waitfor_time(seconds=0)

    def test_WHEN_time_is_0_minutes_THEN_waitfor_time_returns(self):
        genie.waitfor_time(minutes=0)

    def test_WHEN_time_is_0_hours_THEN_waitfor_time_returns(self):
        genie.waitfor_time(hours=0)

    def test_WHEN_time_is_0_string_THEN_waitfor_time_returns(self):
        genie.waitfor_time(time="00:00:00")

    def test_WHEN_time_is_float_THEN_waitfor_time_returns(self):
        genie.waitfor_time(minutes=0.0000001)

    def test_WHEN_time_is_float_and_negative_THEN_waitfor_time_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_time(minutes=-0.000001)

    def test_WHEN_raw_frames_negative_THEN_waitfor_raw_frames_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_raw_frames(raw_frames=-1)

    def test_WHEN_raw_frames_is_0_THEN_waitfor_raw_frames_returns(self):
        genie.waitfor_raw_frames(raw_frames=0)

    def test_WHEN_frames_negative_THEN_waitfor_frames_raises_error(self):
        with self.assertRaises(ValueError):
            genie.waitfor_frames(frames=-1)

    def test_WHEN_frames_is_0_THEN_waitfor_frames_returns(self):
        genie.waitfor_frames(frames=0)


    def test_WHEN_raw_frames_is_0_THEN_waitfor_returns(self):
        genie.waitfor(raw_frames=0)


    def test_WHEN_frames_is_0_THEN_waitfor_returns(self):
        genie.waitfor(frames=0)

    def test_WHEN_input_None_THEN_waitfor_uamps_returns(self):
        genie.waitfor_uamps(None)

    def test_GIVEN_frames_less_than_2_power_31_WHEN_reported_frames_increasing_THEN_waitfor_frames_waits_until_reported_frames_equals_requested_frames(self):
        frames = 5000
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 1, frames, frames + 1])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 2)

    def test_GIVEN_frames_greater_than_2_power_31_WHEN_reported_frames_increasing_THEN_waitfor_frames_waits_until_reported_frames_equals_requested_frames(self):
        frames = 2 ** 31
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 1, frames, frames + 1])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 2)

    def test_GIVEN_frames_less_than_2_power_31_WHEN_reported_frames_increasing_skips_requested_THEN_waitfor_frames_waits_until_next_reported_frames_equals_above_requested_frames(self):
        frames = 5000
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 2, frames - 1, frames + 1, frames + 2])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 3)

    def test_GIVEN_frames_greater_than_2_power_31_WHEN_reported_frames_increasing_skips_requested_THEN_waitfor_frames_waits_until_next_reported_frames_equals_above_requested_frames(self):
        frames = 2 ** 31
        self.api = MagicMock()
        self.api.dae.get_good_frames = MagicMock(side_effect=[frames - 2, frames - 1, frames + 1, frames + 2])
        controller = WaitForController(self.api)
        controller.start_waiting(frames=frames)
        self.assertEqual(self.api.dae.get_good_frames.call_count, 3)

    @contextmanager
    def _mock_get_blocks(self, blocks):
        oldapi = getattr(genie, "__api")  # Have to use getattr and setattr because of the name mangling
        setattr(genie, "__api", MagicMock(get_blocks=lambda: blocks))
        try:
            yield
        finally:
            setattr(genie, "__api", oldapi)

    def test_WHEN_waitfor_is_given_a_valid_block_as_a_keyword_argument_THEN_no_exception_raised(self):
        with self._mock_get_blocks(["blockname"]):
            genie.waitfor(blockname=5)

    def test_WHEN_waitfor_is_given_a_non_existent_block_as_a_keyword_argument_THEN_exception_raised(self):
        with self._mock_get_blocks([]), self.assertRaises(ValueError):
            genie.waitfor(blockname=5)

    @contextmanager
    def _mock_set_block_value(self):
        oldapi = getattr(genie, "__api")  # Have to use getattr and setattr because of the name mangling

        mocked_check_alarms = MagicMock(return_value=([], [], []))
        mocked_api = MagicMock(check_alarms=mocked_check_alarms)

        setattr(genie, "__api", mocked_api)
        try:
            yield mocked_api
        finally:
            setattr(genie, "__api", oldapi)

    def test_WHEN_cset_is_called_with_string_blockname_THEN_exactly_one_call_to_set_pv_value(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(blockname, value)
            mocked_api.set_block_value.assert_called_with(blockname, value, None, None, None, None)

    def test_WHEN_cset_is_called_with_kwarg_syntax_THEN_exactly_one_call_to_set_pv_value(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(**{blockname: value})
            mocked_api.set_block_value.assert_called_with(blockname, value, None, None, None, None)

    def test_WHEN_cset_is_called_with_kwarg_syntax_with_multiple_blocks_THEN_exactly_one_call_to_set_multiple_blocks_which_contains_the_blocknames_and_values(self):
        blocks = {
            "MY_BLOCK_NAME": "abc123",
            "ANOTHER_BLOCK": 42,
            "THE_LAST_BLOCK": True,
        }

        with self._mock_set_block_value() as mocked_api:
            genie.cset(**blocks)
            mocked_api.set_multiple_blocks.assert_called_with(
                [name for name in blocks.keys()],
                [value for value in blocks.values()]
            )

    def test_WHEN_cset_is_called_with_string_blockname_THEN_exactly_one_call_to_get_alarms(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(blockname, value)
            mocked_api.check_alarms.assert_called_with((blockname, ))

    def test_WHEN_cset_is_called_with_kwarg_syntax_THEN_exactly_one_call_to_get_alarms(self):
        value = 3
        blockname = "MY_BLOCK_NAME"
        with self._mock_set_block_value() as mocked_api:
            genie.cset(**{blockname: value})
            mocked_api.check_alarms.assert_called_with((blockname, ))

    def test_WHEN_cset_is_called_with_kwarg_syntax_with_multiple_blocks_THEN_each_block_is_sent_to_check_alarms(self):
        blocks = {
            "MY_BLOCK_NAME": "abc123",
            "ANOTHER_BLOCK": 42,
            "THE_LAST_BLOCK": True,
        }

        with self._mock_set_block_value() as mocked_api:
            genie.cset(**blocks)
            self.assertEqual(mocked_api.check_alarms.call_count, len(blocks))
            mocked_api.check_alarms.assert_has_calls([call((x, )) for x in blocks.keys()], any_order=True)
 
    def test_WHEN_change_tables_is_called_with_no_file_paths_THEN_exception_thrown(self):
        self.assertRaises(ValueError, genie.change_tables)